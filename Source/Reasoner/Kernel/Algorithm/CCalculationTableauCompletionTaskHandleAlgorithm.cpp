/*
 *		Copyright (C) 2013-2015, 2019 by the Konclude Developer Team.
 *
 *		This file is part of the reasoning system Konclude.
 *		For details and support, see <http://konclude.com/>.
 *
 *		Konclude is free software: you can redistribute it and/or modify
 *		it under the terms of version 3 of the GNU Lesser General Public
 *		License (LGPLv3) as published by the Free Software Foundation.
 *
 *		Konclude is distributed in the hope that it will be useful,
 *		but WITHOUT ANY WARRANTY; without even the implied warranty of
 *		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *		GNU (Lesser) General Public License for more details.
 *
 *		You should have received a copy of the GNU (Lesser) General Public
 *		License along with Konclude. If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "CCalculationTableauCompletionTaskHandleAlgorithm.h"








#ifdef KONCLUDE_FORCE_ALL_DEBUG_DEACTIVATED
#define KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(a)
#define KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(a)

#define KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(a)

#define KONCLUCE_TASK_ALGORITHM_MERGING_DEBUGGING_INSTRUCTION(a)
#define KONCLUCE_TASK_ALGORITHM_VARIABLE_PROPAGATION_BLOCKING_DEBUGGING_INSTRUCTION(a)

#else

//#define KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(a) a
#define KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(a)

//#define KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(a) a
#define KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(a) 

#define KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(a) a
//#define KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(a)


#define KONCLUCE_TASK_ALGORITHM_MERGING_DEBUGGING_INSTRUCTION(a)
#define KONCLUCE_TASK_ALGORITHM_VARIABLE_PROPAGATION_BLOCKING_DEBUGGING_INSTRUCTION(a)

#endif









namespace Konclude {

	namespace Reasoner {

		namespace Kernel {

			namespace Algorithm {


				
				CCalculationTableauCompletionTaskHandleAlgorithm::CCalculationTableauCompletionTaskHandleAlgorithm(CUnsatisfiableCacheHandler* unsatCacheHandler, CSatisfiableExpanderCacheHandler* satExpCacheHandler, CReuseCompletionGraphCacheHandler* reuseCompGraphCacheHandler, CSaturationNodeExpansionCacheHandler* satNodeExpCacheHandler, CComputedConsequencesCacheHandler* compConsCacheHandler, CIndividualNodeBackendCacheHandler* backendCacheHandler, COccurrenceStatisticsCacheHandler* occStatsCacheHandler) {
					mConceptPriorityStrategy = new CConcreteConceptProcessingOperatorPriorityStrategy();
					mIndiAncDepthMasConProcPriStr = new CIndividualAncestorDepthMaximumConceptProcessingPriorityStrategy();
					//mTaskProcessingStrategy = new CEqualDepthTaskProcessingPriorityStrategy();
					mTaskProcessingStrategy = new CEqualDepthCacheOrientatedProcessingPriorityStrategy();
					mUnsatCachRetStrategy = new CGenerativeNonDeterministicUnsatisfiableCacheRetrievalStrategy();
					mGroundingHandler = new CConceptNominalSchemaGroundingHandler();
					mDatatypeHandler = new CDatatypeIndividualProcessNodeHandler();
					mIncExpHandler = new CIncrementalCompletionGraphCompatibleExpansionHandler();
					mProcessingDataBox = nullptr;
					mCalcAlgContext = nullptr;

					mClashDesFactory = new CClashDescriptorFactory();
					mIndiNodeManager = new CIndividualNodeManager();
					mDependencyFactory = new CDependencyFactory();
					mSatExpCacheHandler = satExpCacheHandler;
					mUnsatCacheHandler = unsatCacheHandler;
					mSatNodeExpCacheHandler = satNodeExpCacheHandler;
					mReuseCompGraphCacheHandler = reuseCompGraphCacheHandler;
					mCompConsCacheHandler = compConsCacheHandler;
					mBackendCacheHandler = backendCacheHandler;
					mOccStatsCacheHandler = occStatsCacheHandler;

					mCompGraphCacheHandler = new CCompletionGraphCacheHandler(mBackendCacheHandler);


					mIndividualPriorityStrategy = mIndiAncDepthMasConProcPriStr;

					mPosJumpFuncVec = &mPosTableauRuleJumpFuncVec[mRuleFuncCount/2];
					mNegJumpFuncVec = &mNegTableauRuleJumpFuncVec[mRuleFuncCount/2];

					for (cint64 i = 0; i < mRuleFuncCount; ++i) {
						mPosTableauRuleJumpFuncVec[i] = nullptr;
						mNegTableauRuleJumpFuncVec[i] = nullptr;
					}

					mConfSpecializedAutomateRules = true;
					mConfSubSetBlocking = false;
					mConfOptimizedSubSetBlocking = true;
					mConfEqualSetBlocking = false;
					mConfPairwiseEqualSetBlocking = false;
					mConfAncestorBlockingSearch = false;
					mConfAnywhereBlockingSearch = false;
					mConfAnywhereBlockingCandidateHashSearch = false;
					mConfAnywhereBlockingLinkedCandidateHashSearch = true;
					mConfSaveCoreBlockingConceptsCandidates = true;
					mConfSemanticBranching = false;
					mConfAtomicSemanticBranching = true;
					mConfBranchTriggering = true;
					mConfStrictIndiNodeProcessing = true;
					mConfIDIndiPriorization = true;
					mConfPropagateNodeProcessed = false;
					mConfDirectRulePreprocessing = true;
					mConfLazyNewNominalGeneration = true;
					mConfConsRestrictedNonStrictIndiNodeProcessing = true;
					mConfUniqueNameAssumption = false;

					mConfBuildDependencies = true;
					mConfDependencyBacktracking = true;
					mConfDependencyBackjumping = true;
					mConfBuildAllBranchingNodes = true;

					mConfWriteUnsatCaching = true;
					mConfTestedConceptWriteUnsatCaching = true;
					mConfTestOccurUnsatCached = true;
					mConfTestPrecheckUnsatCached = true;
					mConfMinimizeMerging = true;
					mConfUnsatCachingUseFullNodeDependency = false;
					mConfUnsatCachingUseNodeSignatureSet = false;

					mConfSatExpCacheRetrieval = true;
					mConfSatExpCacheConceptExpansion = true;
					mConfSatExpCacheSatisfiableBlocking = true;
					mConfSatExpCacheWriting = true;

					mConfSignatureSaving = false;
					mConfSignatureMirroringBlocking = false;

					mConfSatExpCachedDisjAbsorp = true;
					mConfSatExpCachedMergAbsorp = true;
					mConfSatExpCachedSuccAbsorp = true;

					mConfAnywhereBlockingSomeInitializationHashing = false;
					mConfAnywhereBlockingLazyExactHashing = true;

					mConfSkipANDConcepts = false;
					mConfPairwiseMerging = false;

					mConfDepthOrientatedProcessing = true;
					mConfLateBlockingResolving = true;
					mConfUnsatBranchSatisfiableCaching = true;
					mConfAtleastAtmostFastClashCheck = true;

					mOptSignatureMirroringBlockingForceSubset = false;
					mOptSignatureMirroringBlockingInBlocking = false;
					mConfIndividualReusingFromSignatureBlocking = false;

					mConfCompGraphReuseCacheRetrieval = false;
					mConfCompGraphDeterministicReuse = true;
					mConfCompGraphNonDeterministicReuse = true;

					mConfRepresentativePropagationRules = true;
					mMapComparisonDirectLookupFactor = 20;
					mConfCurrentIndividualQueuing = false;

					mConfGenerateQueries = false;
					mConfDebuggingWriteData = false;
					mConfDebuggingWriteDataComplationTasks = false;
					mConfDebuggingWriteDataOnlyOnSatisfiability = false;
					mConfDebuggingWriteDataForConsistencyTests = false;
					mConfDebuggingWriteDataForClassificationTests = false;
					mConfDebuggingWriteDataForAnsweringPropagationTests = false;
					mConfDebuggingWriteDataForIncrementalExpansionTests = false;
					mConfDebuggingWriteDataForRepCacheIndiComputationTests = false;
					mConfDebuggingWriteDataForAllTests = false;

					mConfExpandCreatedSuccessorsFromSaturation = true;
					// dependencies are not yet generated correctly for resolvings (must include resolved foralls as dependency in addition to the existential restriction)
					mConfSuccessorSaturationExpansionRestrictionsResolving = false;
					mConfCachingBlockingFromSaturation = true;

					mConfExactNominalDependencyTracking = true;
					mConfSaturationCachingWithNominals = true;
					mConfConceptUnsatisfiabilitySaturatedTesting = false;
					mConfSaturationConceptUnsatisfiabilitySaturatedCacheWriting = true;
					mConfSaturationSatisfiabilitiyExpansionCacheWriting = false;
					mConfSaturationCachingTestingDuringBlockingTests = true;
					mConfSaturationExpansionCacheReading = true;
					mConfSaturationIncompleteExpansionFromCache = false;

					mConfDatatypeReasoning = true;
					mConfCompletionGraphCaching = true;
					mConfDelayCompletionGraphCachingReactivation = false;
					mConfCollectCachingUpdatedBlockableIndiNodes = true;


					mConfAddCachedComputedConsequences = true;
					mConfCacheComputedConsequences = true;
					mConfIndividualsBackendCacheLoading = true;

					mConfMergeConstructedIndividualNode = false;
					mConfBranchingStatisticsAnalysing = true;
					mOptAnalogousPropagationPathBlocking = false;


					mConfPossibleInstanceIndividualsMerging = true;
					mConfAllowBackendNeighbourExpansionBlocking = true;
					mConfNewMergingsOnlyInferringExpansion = true;
					mConfAllowBackendSuccessorExpansionBlocking = true;


					mConfAnalogousPropagationPathBlockingWithAnsweringPropagationAdapters = true;

					mConfOccurrenceStatisticsCollecting = true;
					mOptCollectOccurrenceStatistics = false;

					mConfIgnoreBlockingCompletionGraphCachedNonBlockingNodes = true;

					mConfOnlyDeterministicRepresentativeBackendIndividualDataConsideration = true;

					mConfDelayedBackendInitializiation = true;

					mIndiAncDepthMasConProcPriStr->configureStrategy(mConfStrictIndiNodeProcessing,mConfIDIndiPriorization);

					mPosJumpFuncVec[CCTOP] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCBOTTOM] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBOTTOMRule;
					mPosJumpFuncVec[CCAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCIMPLAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCBRANCHAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					if (mConfSpecializedAutomateRules) {
						mPosJumpFuncVec[CCAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatANDRule;
						mPosJumpFuncVec[CCIMPLAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatANDRule;
						mPosJumpFuncVec[CCBRANCHAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatANDRule;
					}

					mPosJumpFuncVec[CCDATATYPE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATATYPERule;
					mNegJumpFuncVec[CCDATATYPE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATATYPERule;
					mPosJumpFuncVec[CCDATALITERAL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATALITERALRule;
					mNegJumpFuncVec[CCDATALITERAL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATALITERALRule;
					mPosJumpFuncVec[CCDATARESTRICTION] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATARESTRICTIONRule;
					mNegJumpFuncVec[CCDATARESTRICTION] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATARESTRICTIONRule;

					mPosJumpFuncVec[CCSUB] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCEQ] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCOR] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyORRule;
					mPosJumpFuncVec[CCALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mPosJumpFuncVec[CCAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mPosJumpFuncVec[CCIMPLAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mPosJumpFuncVec[CCBRANCHAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mPosJumpFuncVec[CCSOME] = &CCalculationTableauCompletionTaskHandleAlgorithm::applySOMERule;
					mPosJumpFuncVec[CCAQSOME] = &CCalculationTableauCompletionTaskHandleAlgorithm::applySOMERule;
					mPosJumpFuncVec[CCAQCHOOCE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatChooseRule;
					mPosJumpFuncVec[CCNOT] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyNegANDRule;
					mPosJumpFuncVec[CCSELF] = &CCalculationTableauCompletionTaskHandleAlgorithm::applySELFRule;
					mPosJumpFuncVec[CCATLEAST] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyATLEASTRule;
					mPosJumpFuncVec[CCATMOST] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyATMOSTRule;
					mPosJumpFuncVec[CCNOMINAL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyNOMINALRule;
					mPosJumpFuncVec[CCVALUE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVALUERule;

					mPosJumpFuncVec[CCIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyIMPLICATIONRule;
					mPosJumpFuncVec[CCIMPLTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCBRANCHTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mPosJumpFuncVec[CCIMPLALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mPosJumpFuncVec[CCBRANCHALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;

					mNegJumpFuncVec[CCAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyORRule;
					mNegJumpFuncVec[CCOR] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
					mNegJumpFuncVec[CCEQ] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyORRule;
					mNegJumpFuncVec[CCALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applySOMERule;
					mNegJumpFuncVec[CCNOT] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyNegANDRule;
					mNegJumpFuncVec[CCSOME] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule;
					mNegJumpFuncVec[CCAQCHOOCE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatChooseRule;
					mNegJumpFuncVec[CCSELF] = &CCalculationTableauCompletionTaskHandleAlgorithm::applySELFRule;
					mNegJumpFuncVec[CCATMOST] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyATLEASTRule;
					mNegJumpFuncVec[CCATLEAST] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyATMOSTRule;
					mNegJumpFuncVec[CCNOMINAL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyNOMINALRule;
					mNegJumpFuncVec[CCVALUE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVALUERule;

					// back propagation (propagation of candidates)
					mPosJumpFuncVec[CCPBINDVARIABLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDVARIABLERule;
					mPosJumpFuncVec[CCPBINDTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule;
					mPosJumpFuncVec[CCPBINDAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule;
					mPosJumpFuncVec[CCPBINDAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule;
					mPosJumpFuncVec[CCPBINDIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEIMPLICATIONRule;
					mPosJumpFuncVec[CCPBINDALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCPBINDAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCPBINDCYCLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATECYCLERule;
					mPosJumpFuncVec[CCPBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEGROUNDINGRule;
					mNegJumpFuncVec[CCPBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEGROUNDINGRule;

					// normal propagation
					mPosJumpFuncVec[CCVARBINDVARIABLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDVARIABLERule;
					mPosJumpFuncVec[CCVARBINDTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
					mPosJumpFuncVec[CCVARBINDAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
					mPosJumpFuncVec[CCVARBINDAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
					mPosJumpFuncVec[CCVARBINDIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEIMPLICATIONRule;
					mPosJumpFuncVec[CCVARBINDALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCVARBINDAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCVARBINDJOIN] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEJOINRule;
					mPosJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEGROUNDINGRule;
					mNegJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEGROUNDINGRule;

					// representative propagation
					if (mConfRepresentativePropagationRules) {
						mPosJumpFuncVec[CCVARBINDVARIABLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEBINDVARIABLERule;
						mPosJumpFuncVec[CCVARBINDTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
						mPosJumpFuncVec[CCVARBINDAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
						mPosJumpFuncVec[CCVARBINDAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
						mPosJumpFuncVec[CCVARBINDIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEIMPLICATIONRule;
						mPosJumpFuncVec[CCVARBINDALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEALLRule;
						mPosJumpFuncVec[CCVARBINDAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEALLRule;
						mPosJumpFuncVec[CCVARBINDJOIN] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEJOINRule;
						mPosJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEGROUNDINGRule;
						mNegJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEGROUNDINGRule;
					}


					mPosJumpFuncVec[CCBACKACTIVTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDFLAGALLRule;
					mPosJumpFuncVec[CCVARPBACKTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule;
					mPosJumpFuncVec[CCVARPBACKALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCVARPBACKAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule;
					mPosJumpFuncVec[CCVARPBACKAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEALLRule;
					mPosJumpFuncVec[CCBACKACTIVIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEIMPLICATIONRule;

					mPosJumpFuncVec[CCNOMINALIMPLI] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyNOMINALIMPLICATIONRule;
					mPosJumpFuncVec[CCDATATYPEIMPLI] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATATYPEIMPLICATIONRule;
					mPosJumpFuncVec[CCDATALITERALIMPLI] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATALITERALIMPLICATIONRule;
					mPosJumpFuncVec[CCDATARESTRICTIONIMPLI] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyDATARESTRICTIONIMPLICATIONRule;

					mPosJumpFuncVec[CCVARBINDPREPARE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPREPARERule;
					mPosJumpFuncVec[CCVARBINDFINALZE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDFINALIZERule;

					mLastConfig = nullptr;

					mAppliedALLRuleCount = 0;
					mAppliedSOMERuleCount = 0;
					mAppliedANDRuleCount = 0;
					mAppliedORRuleCount = 0;
					mAppliedATLEASTRuleCount = 0;
					mAppliedATMOSTRuleCount = 0;
					mAppliedTOTALRuleCount = 0;

					mStatVarBindingCreatedCount = 0;
					mStatVarBindingGroundingCount = 0;
					mStatVarBindingImplicationCount = 0;
					mStatVarBindingJoinCombinesCount = 0;
					mStatVarBindingPropagateSuccCount = 0;
					mStatVarBindingPropagateSuccFreshCount = 0;
					mStatVarBindingPropagateSuccInitialCount = 0;
					mStatVarBindingPropagateCount = 0;
					mStatVarBindingPropagateFreshCount = 0;
					mStatVarBindingPropagateInitialCount = 0;


					mStatRepresentativeCreatedCount = 0;
					mStatRepresentativeGroundingCount = 0;
					mStatRepresentativeImplicationCount = 0;
					mStatRepresentativeJoinCombinesCount = 0;
					mStatRepresentativePropagateSuccCount = 0;
					mStatRepresentativePropagateCount = 0;
					mStatRepresentativePropagateNewRepresentativeCount = 0;
					mStatRepresentativePropagateReusedRepresentativeCount = 0;
					mStatRepresentativePropagateUseRepresentativeCount = 0;
					mStatRepresentativeJoinCount = 0;
					mStatRepresentativeJoinedCount = 0;
					mStatRepresentativeJoinQuickFailCount = 0;

					mStatBackPropActivationCount = 0;

					mCurrentRecProcDepth = 0;
					mCurrentRecProcDepthLimit = 300;

					mMaxBlockingCachingSavedCandidateCount = 50;

					mStatConDesInsertionCount = 0;
					mStatConDesContainedCount = 0;

					mStatPossibleInstanceMergingCount = 0;
					mStatPossibleInstanceMergingSearchIndiCount = 0;
					mStatPossibleInstanceMergingFoundIndiCount = 0;
					mStatPossibleInstanceMergingTryingCount = 0;

					mStatPossibleInstanceMergingSkipIndiCount = 0;
					mStatPossibleInstanceMergingNotMergeableCount = 0;
					mStatPossibleInstanceMergingMaybeMergeableCount = 0;
					mStatPossibleInstanceMergingSuccessSubmitCount = 0;
					mStatPossibleInstanceMergingTriviallySuccessCount = 0;

					mStatStoppedCount = 0;
					mStatSatisfiableCount = 0;
					mStatClashCount = 0;

					//bool debug = true;
					//if (debug) {
					//	QStringList debugStringList;
					//	QFile debugTestFile("debugStop.txt");
					//	if (debugTestFile.open(QIODevice::ReadOnly)) {
					//		while (!debugTestFile.atEnd()) {
					//			QByteArray lineArray(debugTestFile.readLine());
					//			debugStringList.append(QString(lineArray));
					//		}
					//	}
					//	foreach (const QString& debugTestString, debugStringList) {
					//		QString testString(debugTestString);
					//		testString = testString.remove("^");
					//		testString = testString.remove("0");
					//		testString = testString.remove("1");
					//		testString = testString.remove("2");
					//		testString = testString.remove("3");
					//		testString = testString.remove("4");
					//		testString = testString.remove("5");
					//		testString = testString.remove("6");
					//		testString = testString.remove("7");
					//		testString = testString.remove("8");
					//		testString = testString.remove("9");
					//		testString = testString.trimmed();

					//		mCriticalConceptSetStringSet.insert(testString);
					//	}
					//	mFoundCriticalConceptSet = false;
					//}
					//mCriticalConceptSetStringSet.insert("? := ? ( ALL  http://www.owllink.org/testsuite/galen#hasState. ?~http://www.owllink.org/testsuite/galen#actuallyHollow)   ^");
					//mCriticalConceptSetStringSet.insert(" :=  (~http://www.owllink.org/testsuite/galen#Topology AND ? ( ALL  http://www.owllink.org/testsuite/galen#hasState. ?~http://www.owllink.org/testsuite/galen#actuallyHollow)  )   ^");
					//mCriticalConceptSetStringSet.insert("? := ? ( ALL  http://www.owllink.org/testsuite/galen#hasState. ?~http://www.owllink.org/testsuite/galen#trulyHollow)   ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Feature ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#StructuralFeature ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Morphology ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Appearance ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Topology ^");
					//mCriticalConceptSetStringSet.insert(" :=  (~http://www.owllink.org/testsuite/galen#Topology AND ? ( ALL  http://www.owllink.org/testsuite/galen#hasState. ?~http://www.owllink.org/testsuite/galen#trulyHollow)  )   ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#TopCategory ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#DomainCategory ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#ModifierConcept ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Aspect ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#Status ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#AbstractStatus ^");
					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#CountabilityStatus ^");

					//mCriticalConceptSetStringSet.insert("~http://www.owllink.org/testsuite/galen#StomachToDuodenum");


					for (cint64 i = 0; i < mDebugTaskIDVectorSize; ++i) {
						mDebugTaskIDVector[i] = 0;
					}
					mBacktrackingStep = 0;

					mFoundCriticalConceptSet = false;
					mBacktrackDebug = true;

					mNominalMerged = false;
					mNominalMergedCount = 0;

					mOverJumpedNonDeterministicDecisionCount = 0;
					mRelevantNonDeterministicDecisionCount = 0;

					mConfVariableBindingSteeringBackendNeighbourExpansion = true;

					mConfLimitBackendNeighbourExpansion = false;
					mConfMaxBackendNeighbourTotalExpansionCount = 5000;
					mConfCriticalBackendNeighbourTotalExpansionCount = 4000;
					mConfMinBackendNeighbourDirectExpansionCount = 10;
					mConfAllProblematicBackendNeighbourDirectExpansion = true;
					mConfAtmostAllDirectBackendNeighbourExpansion = true;
					mConfBackendExpansionReuse = true;
					mConfQueuedBackendNeighbourExpansionIndisBatchSize = 5;
					mConfQueuedBackendNeighbourExpansionRolesBatchCount = 3;

					mOptLimitBackendNeighbourExpansion = false;
					mOptBackendExpansionReuse = false;
					mConfBackendExpansionLateDynamicReuseActivation = true;

					mConfBackendExpansionNeighbourIndividualCountReuseActivation = 1;
					mConfBackendExpansionSameIndividualCountReuseActivation = 1;
				}

				CCalculationTableauCompletionTaskHandleAlgorithm::~CCalculationTableauCompletionTaskHandleAlgorithm() {
					delete mConceptPriorityStrategy;
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::readCalculationConfig(CSatisfiableCalculationTask* satCalcTask) {
					CCalculationConfigurationExtension *config = satCalcTask->getCalculationConfiguration();
					if (config != mLastConfig) {
						if (config) {
							mConfSpecializedAutomateRules = config->isSpecializedAutomateRuleActivated();
							mConfSubSetBlocking = config->isSubSetBlockingActivated();
							mConfOptimizedSubSetBlocking = config->isOptimizedBlockingActivated();
							mConfEqualSetBlocking = config->isEqualSetBlockingActivated();
							mConfPairwiseEqualSetBlocking = config->isPairwiseEqualSetBlockingActivated();
							mConfAncestorBlockingSearch = config->isAncestorBlockingSearchActivated();
							mConfAnywhereBlockingSearch = config->isAnywhereBlockingSearchActivated();
							mConfAnywhereBlockingCandidateHashSearch = config->isAnywhereBlockingCandidateHashSearchActivated();
							mConfSemanticBranching = config->isSemanticBranchingActivated();
							mConfAtomicSemanticBranching = config->isAtomicSemanticBranchingActivated();
							mConfBranchTriggering = config->isBranchTriggeringActivated();
							mConfStrictIndiNodeProcessing = config->isStrictIndiNodeProcessingActivated();
							mConfIDIndiPriorization = config->isIDIndiPriorizationActivated();
							mConfPropagateNodeProcessed = config->isPropagateNodeProcessedActivated();
							mConfDirectRulePreprocessing = config->isDirectRulePreprocessingActivated();
							mConfLazyNewNominalGeneration = config->isLazyNewNominalCreationActivated();
							mConfConsRestrictedNonStrictIndiNodeProcessing = config->isConsistenceRestrictedNonStictProcessingActivated();
							mConfUniqueNameAssumption = config->isUniqueNameAssumptionActivated();
							mConfDependencyBacktracking = config->isDependencyTrackingActivated();
							mConfBuildDependencies = mConfDependencyBacktracking;
							mConfDependencyBackjumping = config->isBackjumpingActivated();
							mConfWriteUnsatCaching = config->isSingleLevelUnsatisfiableCacheWritingActivated();
							mConfTestedConceptWriteUnsatCaching = config->isTestedConceptUnsatisfiableCacheWritingActivated();
							mConfTestOccurUnsatCached = config->isUnsatisfiableCacheRetrievalActivated();
							mConfTestPrecheckUnsatCached = mConfTestOccurUnsatCached;
							mConfMinimizeMerging = config->isMinimizeMergingBranchesActivated();
							mConfSatExpCacheRetrieval = config->isSatisfiableExpansionCacheRetrievalActivated();
							mConfSatExpCacheConceptExpansion = config->isSatisfiableExpansionCacheConceptExpansionActivated();
							mConfSatExpCacheSatisfiableBlocking = config->isSatisfiableExpansionCacheSatisfiableBlockingActivated();
							mConfSatExpCacheWriting = config->isSatisfiableExpansionCacheWritingActivated();
							mConfSignatureSaving = config->isSignatureSavingActivated();
							mConfSignatureMirroringBlocking = config->isSignatureMirroringBlockingActivated();
							mConfUnsatCachingUseFullNodeDependency = config->isUnsatisfiableCachingFullDependencyActivated();
							mConfUnsatCachingUseNodeSignatureSet = config->isUnsatisfiableCachingFullSignatureActivated();
							mConfPairwiseMerging = config->isPairwiseMergingActivated();
							mConfCompGraphReuseCacheRetrieval = config->isCompletionGraphReuseCachingRetrievalActivated();
							mConfCompGraphDeterministicReuse = config->isCompletionGraphDeterministicReuseActivated();
							mConfCompGraphNonDeterministicReuse = config->isCompletionGraphNonDeterministicReuseActivated();
							mConfAnywhereBlockingLinkedCandidateHashSearch = config->isAnywhereBlockingCoreConceptCandidateHashSearchActivated();
							mConfRepresentativePropagationRules = config->isRepresentativePropagationActivated();
							mConfDebuggingWriteData = config->isDebuggingWriteDataActivated();
							mConfGenerateQueries = config->isGeneratingTestQueriesActivated();

							mConfDebuggingWriteDataComplationTasks = config->isDebuggingWriteDataCompletionTasksActivated();
							mConfDebuggingWriteDataOnlyOnSatisfiability = config->isDebuggingWriteDataCompletionTasksOnlyOnSatisfiabilityActivated();
							mConfDebuggingWriteDataForConsistencyTests = config->isDebuggingWriteDataCompletionTasksForConsistencyTestsActivated();
							mConfDebuggingWriteDataForClassificationTests = config->isDebuggingWriteDataCompletionTasksForClassificationTestsActivated();
							mConfDebuggingWriteDataForAnsweringPropagationTests = config->isDebuggingWriteDataCompletionTasksForAnsweringPropagationTestsActivated();
							mConfDebuggingWriteDataForIncrementalExpansionTests = config->isDebuggingWriteDataCompletionTasksForIncrementalExpansionTestsActivated();
							mConfDebuggingWriteDataForRepCacheIndiComputationTests = config->isDebuggingWriteDataCompletionTasksForRepresentativeCacheRecomputationTestsActivated();
							mConfDebuggingWriteDataForAllTests = config->isDebuggingWriteDataCompletionTasksForAllTestsActivated();

							mConfExpandCreatedSuccessorsFromSaturation = config->isSuccessorConceptSaturationExpansionActivated();
							mConfCachingBlockingFromSaturation = config->isSaturationCachingActivated();
							mConfSaturationCachingWithNominals = config->isSaturationCachingWithNominalsByReactivationActivated();
							mConfSaturationConceptUnsatisfiabilitySaturatedCacheWriting = config->isSaturationUnsatisfiabilityCacheWritingActivated();
							mConfSaturationSatisfiabilitiyExpansionCacheWriting = config->isSaturationExpansionSatisfiabilityCacheWritingActivated();
							mConfDatatypeReasoning = config->isDatatypeReasoningActivated();

							mConfCompletionGraphCaching = config->isCompletionGraphCachingActivated();
							mConfDelayCompletionGraphCachingReactivation = config->isDelayedCompletionGraphCachingReactivationActivated();
							mConfIndividualsBackendCacheLoading = config->isIndividualsBackendCacheLoadingActivated();
							mConfAddCachedComputedConsequences = config->isComputedTypesCachingActivated();


							mConfMergeConstructedIndividualNode = config->isConstructionIndividualNodeMergingActivated();
							mCurrentRecProcDepthLimit = config->getMaximumRecursiveProcessingConceptCount();


							mConfNewMergingsOnlyInferringExpansion = config->isNewMergingsBackendOnlyInferringNeighbourExpansionActivated();
							mConfAllowBackendNeighbourExpansionBlocking = config->isAllowBackendNeighbourExpansionBlockingActivated();
							mConfAllowBackendSuccessorExpansionBlocking = config->isAllowBackendSuccessorExpansionBlockingActivated();
							mConfOccurrenceStatisticsCollecting = config->isOccurrenceStatisticsCollectionActivated();

							mConfIgnoreBlockingCompletionGraphCachedNonBlockingNodes = config->isBlockingTestsIgnoringCompletionGraphCachedNonBlockedNodesActivated();


							mConfDefaultIndividualPrecomputationCount = config->getDefaultIndividualPrecomputationCount();

							mConfLimitBackendNeighbourExpansion = config->isBackendCriticalNeighbourExpansionLimitationActivated();
							mConfMaxBackendNeighbourTotalExpansionCount = config->getBackendCriticalNeighbourExpansionLimit();
							mConfCriticalBackendNeighbourTotalExpansionCount = config->getBackendCriticalNeighbourExpansionPriorityReductionCount();
							mConfMinBackendNeighbourDirectExpansionCount = config->getBackendCriticalNeighbourDirectExpansionLimit();
							mConfBackendExpansionLimitReachedReuseActivation = config->isBackendExpansionLimitReachedReuseActivationActivated();
							mConfQueuedBackendNeighbourExpansionIndisBatchSize = config->getBackendCriticalNeighbourExpansionIndividualsBatchSize();
							mConfQueuedBackendNeighbourExpansionRolesBatchCount = config->getBackendCriticalNeighbourExpansionRolesBatchSize();

							mConfDelayedBackendInitializiation = config->isBackendDelayedSameInitializationCopyingActivated();

							mConfNeighbourLabelRepresentativeExpansionDelaying = config->isBackendCriticalNeighbourRepresentativeExpansionDelayingActivated();
							mConfMinDirectNeighbourExpansionOverCriticalReductionSize = config->getBackendCriticalNeighbourDirectExpansionOverCriticalReductionSize();

							mConfOnlyDeterministicRepresentativeBackendIndividualDataConsideration = config->isBackendOnlyDeterministicRepresentativeIndividualDataConsiderationActivated();

							mConfBackendExpansionReuse = config->isBackendCriticalNeighbourExpansionReusingActivated();
							mConfBackendExpansionLateDynamicReuseActivation = config->isBackendCriticalNeighbourExpansionLateDynamicReusingActivated();


							mConfBackendExpansionNeighbourIndividualCountReuseActivation = config->getBackendExpansionReuseActivationNeighbourIndividualCount();
							mConfBackendExpansionSameIndividualCountReuseActivation = config->getBackendExpansionReuseActivationSameIndividualCount();


							mConfExpandDeterministicMergedHandledNeighbours = config->isBackendExpandDeterministicallyMergedHandledNeighboursActivated();
							mConfCardinalityNeighbourExpansionRepresentativeCounting = config->isBackendCardinalityNeighbourExpansionRepresentativeCountingActivated();


						} else {
							mConfCompletionGraphCaching = true;
							mConfDelayCompletionGraphCachingReactivation = false;
							mConfSpecializedAutomateRules = true;
							mConfSubSetBlocking = false;
							mConfOptimizedSubSetBlocking = true;
							mConfEqualSetBlocking = false;
							mConfPairwiseEqualSetBlocking = false;
							mConfAncestorBlockingSearch = false;
							mConfAnywhereBlockingSearch = false;
							mConfAnywhereBlockingCandidateHashSearch = false;
							mConfAnywhereBlockingLinkedCandidateHashSearch = true;
							mConfSemanticBranching = false;
							mConfAtomicSemanticBranching = true;
							mConfBranchTriggering = true;
							mConfStrictIndiNodeProcessing = true;
							mConfIDIndiPriorization = true;
							mConfPropagateNodeProcessed = false;
							mConfDirectRulePreprocessing = true;
							mConfLazyNewNominalGeneration = true;
							mConfConsRestrictedNonStrictIndiNodeProcessing = true;
							mConfUniqueNameAssumption = false;
							mConfBuildDependencies = true;
							mConfDependencyBacktracking = true;
							mConfDependencyBackjumping = true;
							mConfWriteUnsatCaching = true;
							mConfTestedConceptWriteUnsatCaching = true;
							mConfTestOccurUnsatCached = true;
							mConfTestPrecheckUnsatCached = true;
							mConfMinimizeMerging = true;
							mConfSatExpCacheRetrieval = true;
							mConfSatExpCacheConceptExpansion = true;
							mConfSatExpCacheSatisfiableBlocking = true;
							mConfSatExpCacheWriting = true;
							mConfSignatureSaving = false;
							mConfSignatureMirroringBlocking = false;
							mConfUnsatCachingUseFullNodeDependency = false;
							mConfUnsatCachingUseNodeSignatureSet = false;
							mConfCompGraphReuseCacheRetrieval = false;
							mConfCompGraphDeterministicReuse = true;
							mConfCompGraphNonDeterministicReuse = true;
							mConfRepresentativePropagationRules = true;
							mConfDebuggingWriteData = false;
							mConfGenerateQueries = false;
							mConfDebuggingWriteDataComplationTasks = false;
							mConfDebuggingWriteDataOnlyOnSatisfiability = false;
							mConfDebuggingWriteDataForConsistencyTests = false;
							mConfDebuggingWriteDataForClassificationTests = false;
							mConfDebuggingWriteDataForAnsweringPropagationTests = false;
							mConfDebuggingWriteDataForIncrementalExpansionTests = false;
							mConfDebuggingWriteDataForRepCacheIndiComputationTests = false;
							mConfDebuggingWriteDataForAllTests = false;
							mConfExpandCreatedSuccessorsFromSaturation = true;
							mConfCachingBlockingFromSaturation = true;
							mConfSaturationCachingWithNominals = true;
							mConfSaturationConceptUnsatisfiabilitySaturatedCacheWriting = true;
							mConfSaturationSatisfiabilitiyExpansionCacheWriting = false;
							mConfDatatypeReasoning = true;
							mConfIndividualsBackendCacheLoading = true;
							mConfAddCachedComputedConsequences = true;
							mConfMergeConstructedIndividualNode = false;
							mConfAllowBackendNeighbourExpansionBlocking = true;
							mConfNewMergingsOnlyInferringExpansion = true;
							mConfAllowBackendSuccessorExpansionBlocking = true;
							mCurrentRecProcDepthLimit = 300;
							mConfOccurrenceStatisticsCollecting = true;
							mConfIgnoreBlockingCompletionGraphCachedNonBlockingNodes = true;


							mConfLimitBackendNeighbourExpansion = false;
							mConfMaxBackendNeighbourTotalExpansionCount = 15000;
							mConfDefaultIndividualPrecomputationCount = 1500;
							mConfCriticalBackendNeighbourTotalExpansionCount = 12000;
							mConfMinBackendNeighbourDirectExpansionCount = 10;
							mConfAllProblematicBackendNeighbourDirectExpansion = true;
							mConfAtmostAllDirectBackendNeighbourExpansion = true;
							mConfBackendExpansionReuse = true;
							mConfBackendExpansionLimitReachedReuseActivation = true;
							mConfQueuedBackendNeighbourExpansionIndisBatchSize = 5;
							mConfQueuedBackendNeighbourExpansionRolesBatchCount = 3;
							mConfMinDirectNeighbourExpansionOverCriticalReductionSize = 100;

							mConfNeighbourLabelRepresentativeExpansionDelaying = true;
							mConfOnlyDeterministicRepresentativeBackendIndividualDataConsideration = true;

							mConfDelayedBackendInitializiation = true;

							mConfBackendExpansionNeighbourIndividualCountReuseActivation = 1;
							mConfBackendExpansionSameIndividualCountReuseActivation = 1;

							mConfExpandDeterministicMergedHandledNeighbours = true;
							mConfCardinalityNeighbourExpansionRepresentativeCounting = false;

						}
						mLastConfig = config;

						mConfCollectCachingUpdatedBlockableIndiNodes = mConfCompletionGraphCaching; 

						mPosJumpFuncVec[CCAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule;
						if (mConfSpecializedAutomateRules) {
							mPosJumpFuncVec[CCAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatANDRule;
						}


						if (mConfRepresentativePropagationRules) {
							mPosJumpFuncVec[CCVARBINDVARIABLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEBINDVARIABLERule;
							mPosJumpFuncVec[CCVARBINDTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
							mPosJumpFuncVec[CCVARBINDAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
							mPosJumpFuncVec[CCVARBINDAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule;
							mPosJumpFuncVec[CCVARBINDIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEIMPLICATIONRule;
							mPosJumpFuncVec[CCVARBINDALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEALLRule;
							mPosJumpFuncVec[CCVARBINDAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEALLRule;
							mPosJumpFuncVec[CCVARBINDJOIN] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEJOINRule;
							mPosJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEGROUNDINGRule;
							mNegJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEGROUNDINGRule;
						} else {
							mPosJumpFuncVec[CCVARBINDVARIABLE] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDVARIABLERule;
							mPosJumpFuncVec[CCVARBINDTRIG] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
							mPosJumpFuncVec[CCVARBINDAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
							mPosJumpFuncVec[CCVARBINDAQAND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule;
							mPosJumpFuncVec[CCVARBINDIMPL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEIMPLICATIONRule;
							mPosJumpFuncVec[CCVARBINDALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEALLRule;
							mPosJumpFuncVec[CCVARBINDAQALL] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEALLRule;
							mPosJumpFuncVec[CCVARBINDJOIN] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEJOINRule;
							mPosJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEGROUNDINGRule;
							mNegJumpFuncVec[CCVARBINDGROUND] = &CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEGROUNDINGRule;
						}



					}


					mConceptPriorityStrategy->readCalculationConfig(satCalcTask);


					bool consPrepProcessing = satCalcTask->getConsistenceAdapter() != nullptr && satCalcTask->getTaskDepth() <= 0;
					mConfSaveCoreBlockingConceptsCandidates = mConfAnywhereBlockingLinkedCandidateHashSearch;


					mOptIncrementalExpansion = false;
					mOptIncrementalDeterministicExpansion = false;
					mOptIncrementalNondeterministicExpansion = false;
					mOptIncrementalCompatibleExpansion = false;
					mOptIncrementalCachingExpansion = false;
					if (satCalcTask->getSatisfiableTaskIncrementalConsistencyTestingAdapter()) {
						mOptIncrementalCompatibleExpansion = !satCalcTask->getProcessingDataBox()->isIncrementalExpansionCompatibleMerged();
						mOptIncrementalCachingExpansion = !mOptIncrementalCompatibleExpansion;
						mOptIncrementalExpansion = true;
						if (satCalcTask->getTaskDepth() <= 0) {
							consPrepProcessing = true;
							mOptIncrementalDeterministicExpansion = true;
						} else {
							mOptIncrementalNondeterministicExpansion = true;
						}
					}

					if (mConfAnalogousPropagationPathBlockingWithAnsweringPropagationAdapters && satCalcTask->getSatisfiableAnswererBindingPropagationAdapter()) {
						mOptAnalogousPropagationPathBlocking = true;
					} else {
						mOptAnalogousPropagationPathBlocking = false;
					}

					mOptMergeConstructedIndividualNode = mConfMergeConstructedIndividualNode;


					mOptCollectOccurrenceStatistics = false;
					CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repBackCacheUpAdapter = satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
					if (mConfOccurrenceStatisticsCollecting && (satCalcTask->getConsistenceAdapter() || repBackCacheUpAdapter)) {
						mOptCollectOccurrenceStatistics = true;
					}
					if (satCalcTask->getConsistenceAdapter() || repBackCacheUpAdapter) {
						mOptMergeConstructedIndividualNode = true;
					}


					mOptDelayedBackendInitializiation = false;
					mOptDelayedBackendInitializiationWithRootLinkers = false;
					mOptLimitBackendNeighbourExpansion = false;
					mOptBackendExpansionReuse = satCalcTask->getProcessingDataBox()->isBackendIndividualLateReuseExpansionActivated();
					mOptNeighbourLabelRepresentativeExpansionDelaying = false;

					if (repBackCacheUpAdapter) {
						double preCompIndiCountFactor = (double)(repBackCacheUpAdapter->getIndividualComputationCount() + repBackCacheUpAdapter->getAdditionalIndividualComputationSize()) / (double)mConfDefaultIndividualPrecomputationCount;

						mOptMinBackendNeighbourDirectExpansionCount = mConfMinBackendNeighbourDirectExpansionCount * preCompIndiCountFactor;
						mOptMaxBackendNeighbourTotalExpansionCount = mConfMaxBackendNeighbourTotalExpansionCount * preCompIndiCountFactor;
						mOptCriticalBackendNeighbourTotalExpansionCount = mConfCriticalBackendNeighbourTotalExpansionCount * preCompIndiCountFactor;
						mOptQueuedBackendNeighbourExpansionIndisBatchSize = mConfQueuedBackendNeighbourExpansionIndisBatchSize * preCompIndiCountFactor;
						mOptQueuedBackendNeighbourExpansionRolesBatchCount = mConfQueuedBackendNeighbourExpansionRolesBatchCount * preCompIndiCountFactor;
						mOptMinDirectNeighbourExpansionOverCriticalReductionSize = mConfMinDirectNeighbourExpansionOverCriticalReductionSize * preCompIndiCountFactor;

						if (mConfBackendExpansionLimitReachedReuseActivation && repBackCacheUpAdapter->hasExpansionLimitReached()) {
							mOptBackendExpansionReuse = true;
						}

						if (mConfDelayedBackendInitializiation) {
							mOptDelayedBackendInitializiation = true;
						}
						//mOptDelayedBackendInitializiationWithRootLinkers = true;

						if (mConfLimitBackendNeighbourExpansion) {
							mOptLimitBackendNeighbourExpansion = true;
						}
						if (mConfBackendExpansionReuse) {
							mOptBackendExpansionReuse = true;
						}
					}

					if (satCalcTask->getSatisfiablePossibleInstancesMergingAdapter() && mConfNeighbourLabelRepresentativeExpansionDelaying) {
						mOptNeighbourLabelRepresentativeExpansionDelaying = true;
						if (mConfLimitBackendNeighbourExpansion) {
							mOptLimitBackendNeighbourExpansion = true;

							mOptMinBackendNeighbourDirectExpansionCount = mConfMinBackendNeighbourDirectExpansionCount;
							mOptMaxBackendNeighbourTotalExpansionCount = -1;
							mOptCriticalBackendNeighbourTotalExpansionCount = mConfCriticalBackendNeighbourTotalExpansionCount;
							mOptQueuedBackendNeighbourExpansionIndisBatchSize = -1;
							mOptQueuedBackendNeighbourExpansionRolesBatchCount = -1;
							mOptMinDirectNeighbourExpansionOverCriticalReductionSize = mConfMinDirectNeighbourExpansionOverCriticalReductionSize;
						}
					}





					mOptConsistenceNodeMarking = consPrepProcessing && mConfConsRestrictedNonStrictIndiNodeProcessing;
					mOptDetExpPreporcessing = consPrepProcessing;

					//mOptProcessedNodePropagation = mConfPropagateNodeProcessed || !mConfStrictIndiNodeProcessing;
					//mOptProcessedConsNodePropagation = mConfConsRestrictedNonStrictIndiNodeProcessing;
					//mOptProcessingBlockingTests = !mConfStrictIndiNodeProcessing;
					//mOptConsNodeProcessingBlockingTests = mConfConsRestrictedNonStrictIndiNodeProcessing;
					
					//mOptNonStrictIndiNodeProcessing = !mConfStrictIndiNodeProcessing || consPrepProcessing && mConfConsRestrictedNonStrictIndiNodeProcessing;
					//mIndiAncDepthMasConProcPriStr->configureStrategy(!mOptNonStrictIndiNodeProcessing,mConfIDIndiPriorization);
					mOptNonStrictIndiNodeProcessing = true;



				}


				CCalculationAlgorithmContextBase* CCalculationTableauCompletionTaskHandleAlgorithm::createCalculationAlgorithmContext(CTaskProcessorContext *processorContext, CProcessContext* processContext, CSatisfiableCalculationTask* satCalcTask) {
					CCalculationAlgorithmContextBase* calcAlgContext = CObjectAllocator< CCalculationAlgorithmContextBase >::allocateAndConstruct(processContext->getUsedMemoryAllocationManager());
					calcAlgContext->initTaskProcessContext(processContext,satCalcTask);
					calcAlgContext->initCalculationAlgorithmContext(processorContext,mConceptPriorityStrategy,mIndividualPriorityStrategy,mTaskProcessingStrategy,mUnsatCachRetStrategy,
								mIndiNodeManager,mClashDesFactory,mDependencyFactory,mUnsatCacheHandler,mSatExpCacheHandler,mSatNodeExpCacheHandler);
					return calcAlgContext;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::handleTask(CTaskProcessorContext *processorContext, CTask* task) {

					//lastBranchingMergingProcRest = nullptr;

					CTaskHandleMemoryAllocationManager* processorMemoryManager = processorContext->getTaskHandleMemoryAllocationManager();
					CTaskProcessorCommunicator* processorCommunicator = processorContext->getTaskProcessorCommunicator();

					CTaskHandleMemoryAllocationManager* taskHandleMemMan = processorContext->getTaskHandleMemoryAllocationManager();
					taskHandleMemMan->releaseAllMemory();

					CSatisfiableCalculationTask* satCalcTask = dynamic_cast<CSatisfiableCalculationTask*>(task);
					if (satCalcTask) {

						if (!processorCommunicator->verifyContinueTaskProcessing(satCalcTask)) {
							if (!satCalcTask->getTaskStatus()->isProcessable()) {
								processorCommunicator->communicateTaskComplete(satCalcTask);
								return false;
							} else {
								// continue later
								return true;
							}
						}

						readCalculationConfig(satCalcTask);


						mLastUnsatCacheTestedIndiNode = nullptr;
						mLastAnalysingBranchNodeTree = nullptr;

						CProcessContext* processContext = satCalcTask->getProcessContext(processorContext);
						CCalculationAlgorithmContextBase* calcAlgContext = createCalculationAlgorithmContext(processorContext,processContext,satCalcTask);
						mCalcAlgContext = calcAlgContext;
						mProcessingDataBox = satCalcTask->getProcessingDataBox();
						bool clashed = false;
						bool satisfiable = false;
						bool completed = false;
						bool paused = false;
						bool error = false;
						bool canceled = false;
						cint64 errorCode = 0;

						CProcessTagger* processTagger = calcAlgContext->getUsedProcessTagger();

						CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();

						CNodeSwitchHistory* nodeSwitchHistory = processingDataBox->getNodeSwitchHistory(true);

						mProcessingQueue = nullptr;
						mDepthFirstProcessingQueue = nullptr;
						mSigBlockRevSet = nullptr; 
						mReusingReviewData = nullptr; 
						mIndiImmediateProQueue = nullptr; 
						mIndiDetExpProQueue = nullptr; 
						mIndiDetDeptFirstExpProQueue = nullptr; 
						mValueSpaceTriggeringProQueue = nullptr; 
						mValueSpaceSatCheckingQueue = nullptr; 
						mNominalProcessingQueue = nullptr; 
						mDepthProcessingQueue = nullptr; 
						mEarlyIndiReactProcessingQueue = nullptr; 
						mLateIndiReactProcessingQueue = nullptr; 
						mIndiBlockReactProQueue = nullptr; 
						mIndiSigBlockUpdProQueue = nullptr; 
						mDelayedNominalProcessingQueue = nullptr; 
						mVarBindConBatchProcessingQueue = nullptr; 
						mRoleAssertionProcessingQueue = nullptr;
						mIncrementalExpansionInitializingProcessingQueue = nullptr;
						mIncrementalExpansionProcessingQueue = nullptr;
						mIncrementalCompatibilityCheckingQueue = nullptr;
						mMinConceptProcessingPriorityLevel = 0;
						mIndiNodeConcludeUnsatCaching = false;

						mOccStatsCacheHandler->configureOntology(processingDataBox->getOntology());

						//CSatisfiableTaskClassificationMessageAdapter* adapter = satCalcTask->getClassificationMessageAdapter();
						//if (adapter) {
						//	CConcept* concept = adapter->getTestingConcept();
						//	if (concept && adapter->hasExtractionFlags(CSatisfiableTaskClassificationMessageAdapter::EFEXTRACTSUBSUMERSROOTNODE)) {
						//		QString className = CIRIName::getRecentIRIName(concept->getClassNameLinker());
						//		if (className == "http://reference.data.gov.uk/def/intervals/CalendarYear") {
						//			bool bug = true;
						//		}
						//	}
						//}
						CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repCacheUpdAd = satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();

						try {
							mBackendCacheHandler->setWorkingOntology(satCalcTask->getProcessingDataBox()->getOntology());


							if (repCacheUpdAd && !processingDataBox->hasBackendCacheUpdateIndividualsInitialized()) {
								QList<CIndividualReference>* indiComputationList = repCacheUpdAd->getIndividualComputationList();
								CIndividualVector* baseIndiVec = processingDataBox->getIndividualVector(true);
								CIndividualUnsortedProcessingQueue* indiNodeQueue = processingDataBox->getIndividualImmediatelyProcessingQueue(true);
								CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();
								CDependencyTrackPoint* independentBaseDepTrackPoint = processingDataBox->getBranchingTree(true)->getBaseDependencyNode(true)->getContinueDependencyTrackPoint();
								for (QList<CIndividualReference>::const_iterator it = indiComputationList->constBegin(), itEnd = indiComputationList->constEnd(); it != itEnd; ++it) {
									CIndividualReference individualReference = (*it);
									CIndividual* individual = individualReference.getIndividual();
									cint64 individualID = individualReference.getIndividualID();


									CBackendRepresentativeMemoryCacheIndividualAssociationData* assData = mBackendCacheHandler->getIndividualAssociationData(individualID, calcAlgContext);
									if (assData->isIncompletelyMarked()) {
										CBackendIndividualRetrievalComputationUpdateCoordinationHashData* coordData = repCacheUpdAd->getIndividualComputationCoordinationHash()->value(individualID);
										if (!coordData || !coordData->isComputationIntegrated()) {

											cint64 individualNodeID = -individualID;

											// does not use delayed backend initialization
											//CIndividualProcessNode* localIndi = getLocalizedIndividual(-individualID, calcAlgContext);

											if (!individual) {
												individual = baseIndiVec->getData(individualID);
											}
											if (!individual) {
												individual = CObjectAllocator<CIndividual>::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
												individual->initIndividual(individualID);
												individual->setTemporaryIndividual(true);
												baseIndiVec->setLocalData(individualID, individual);
											}
											CIndividualProcessNode* localIndi = indiNodeVec->getLocalData(individualNodeID);
											if (!localIndi) {
												localIndi = CObjectParameterizingAllocator< CIndividualProcessNode, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getProcessContext());
												localIndi->initDependencyTracker(independentBaseDepTrackPoint);
												localIndi->setIndividualNodeID(individualNodeID);
												localIndi->setAssertionDataLinker(individual->getAssertionDataLinker());
												localIndi->setAssertionConceptLinker(individual->getAssertionConceptLinker());
												localIndi->setAssertionRoleLinker(individual->getAssertionRoleLinker());
												localIndi->setReverseAssertionRoleLinker(individual->getReverseAssertionRoleLinker());
												localIndi->setNominalIndividual(individual);
												localIndi->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
												localIndi->setNominalIndividualTriplesAssertions(true);
												localIndi->setInitializingConceptLinker(nullptr);
												indiNodeVec->setLocalData(individualNodeID, localIndi);
											}

											indiNodeQueue->insertIndiviudalProcessNode(localIndi);

											if (processingDataBox->getConstructedIndividualNode() == nullptr) {
												processingDataBox->setConstructedIndividualNode(localIndi);
											}
										}
									}

								}
								processingDataBox->setBackendCacheUpdateIndividualsInitialized(true);
							}



							if (processingDataBox->getBranchingInstruction()) {
								CBranchingInstruction* branchingInstruction = processingDataBox->getBranchingInstruction();
								CBranchingInstruction::BRANCHINGINSTRUCTIONTYPE branchingInstructionType = branchingInstruction->getBranchingInstructionType();
								if (branchingInstructionType == CBranchingInstruction::BIADDINDIVIDUALCONCEPTSTYPE) {
									CBranchingInstructionAddIndividualConcepts* addConceptBrIn = (CBranchingInstructionAddIndividualConcepts*)branchingInstruction;

									CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(addConceptBrIn->getAddingIndividualNode(),false,calcAlgContext);
									CConceptProcessingQueue* newConProcQueue = newLocIndiNode->getConceptProcessingQueue(true);
									CDependencyTrackPoint* newDependencyTrackPoint = addConceptBrIn->getAddingDependencyTrackPoint();

									for (CSortedNegLinker<CConcept*>* addingConceptLinker = addConceptBrIn->getAddingConceptLinker(); addingConceptLinker; addingConceptLinker = addingConceptLinker->getNext()) {
										addConceptToIndividual(addingConceptLinker->getData(),addingConceptLinker->isNegated(),newLocIndiNode,newDependencyTrackPoint,false,true,calcAlgContext);
									}
									if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForBranchedDisjuncts(nullptr,newLocIndiNode,nullptr)) {
										addIndividualNodeForCacheUnsatisfiableRetrieval(newLocIndiNode,calcAlgContext);
									}
									addIndividualToProcessingQueue(newLocIndiNode,calcAlgContext);

								}
								processingDataBox->clearBranchingInstruction();
							}


							if (satCalcTask->getSatisfiableTaskIncrementalConsistencyTestingAdapter()) {
								if (!processingDataBox->isIncrementalExpansionInitialised()) {
									mIncrementalCompatibilityCheckingQueue = processingDataBox->getIncrementalCompatibilityCheckingQueue(true);
									CIndividualUnsortedProcessingQueue* indiNodeQueue = processingDataBox->getIndividualImmediatelyProcessingQueue(true);
									for (CXLinker<CIndividualProcessNode*>* indiNodeLinkerIt = indiNodeQueue->getProcessIndividualNodeLinker(); indiNodeLinkerIt; indiNodeLinkerIt = indiNodeLinkerIt->getNext()) {
										CIndividualProcessNode* indiNode = indiNodeLinkerIt->getData();
										CIndividualProcessNode* locIndiNode = getLocalizedIndividual(indiNode,true,calcAlgContext);
										locIndiNode->getIncrementalExpansionData(true)->setDirectlyChanged(true);
										locIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANDING | CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED);
										locIndiNode->setIncrementalExpansionID(calcAlgContext->getProcessingDataBox()->getIncrementalExpansionID());
										mIncrementalCompatibilityCheckingQueue->insertProcessIndiviudal(locIndiNode);
									}
									processingDataBox->setIncrementalExpansionInitialised(true);
								}
							}



							if (processingDataBox->isReapplicationLastConceptDesciptorOnLastIndividualNodeRequired()) {
								CIndividualProcessNode* lastProcessingIndiNode = nullptr;
								CConceptProcessDescriptor* lastProcessingConDes = nullptr;
								if (processingDataBox->getLastProcessingIndividualNodeAndConceptDescriptor(lastProcessingIndiNode,lastProcessingConDes)) {
									addCopiedConceptToProcessingQueue(lastProcessingConDes,lastProcessingIndiNode,calcAlgContext);
								}
								processingDataBox->setReapplicationLastConceptDesciptorOnLastIndividualNodeRequired(false);
							}


							if (mConfPossibleInstanceIndividualsMerging) {


								CSatisfiableTaskRealizationPossibleInstancesMergingAdapter* possibleInstancesMergingAdapter = satCalcTask->getSatisfiablePossibleInstancesMergingAdapter();
								if (possibleInstancesMergingAdapter) {

									CPossibleInstancesIndividualsMergingLinker* indiTestingMergingLinker = possibleInstancesMergingAdapter->getIndividualTestingMergingLinker();
									if (indiTestingMergingLinker && indiTestingMergingLinker->isSatisfiableMerged()) {
										canceled = true;
										satisfiable = true;
									}
								}
							}


							CIndividualProcessNode* indiProcNode = nullptr;
							if (!canceled) {
								indiProcNode = takeNextProcessIndividual(calcAlgContext);
							}
							CConceptProcessDescriptor* conProcDes = nullptr;

							mCurrentRecProcDepth = 0;
							mProcessRuleToTaskProcessingVerificationCount = 80;
							mRemainProcessRuleToTaskProcessingVerification = mProcessRuleToTaskProcessingVerificationCount;

							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeginTaskDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));



							CIndividualProcessNode* lastIndiProcNode = nullptr;
							STATINC(TASKPROCESSCHANGECOUNT,mCalcAlgContext);



							CSatisfiableTaskCancellationAdapter* cancellationAdapter = satCalcTask->getCancellationAdapter();
							if (cancellationAdapter && cancellationAdapter->canCancelTaskCalculation()) {
								canceled = true;
								throw CCalculationErrorProcessingException(CCalculationErrorProcessingException::ECCANCELED);
							}


							if (repCacheUpdAd && repCacheUpdAd->hasUnsatisfiableComputed()) {
								canceled = true;
								throw CCalculationErrorProcessingException(CCalculationErrorProcessingException::ECCANCELED);
							}


							CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repBackCacheUpAdapter = satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
							if (repBackCacheUpAdapter) {
								mBackendCacheHandler->checkRecomputationIdUsage(repBackCacheUpAdapter->getRepresentativeCacheRecomputationId());
							}


							while (indiProcNode && !canceled) {
								lastIndiProcNode = indiProcNode;
								conProcDes = nullptr;


								// TODO: signature cached, but empty processing queue
								//CConceptProcessingQueue* prevConProcQueue = indiProcNode->getConceptProcessingQueue(false);
								//if (!prevConProcQueue || !prevConProcQueue->isEmpty()) {
								if (true) {



									//CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repCacheUpdAd = satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
									//cint64 repCompId = -1;
									//if (repCompId && repCacheUpdAd) {
									//	repCompId = repCacheUpdAd->getRepresentativeCacheRecomputationId();
									//}
									//if (lastRecomputationTaskId != repCompId) {
									//	nextReportingExpansionCount = 1000;
									//	lastRecomputationTaskId = repCompId;
									//	lastTaskDepth = 100;
									//}


									//bool reporting = false;
									//cint64 currentExpansionCount = mProcessingDataBox->getBackendCacheIntegratedIndividualNodeCount();
									//if (currentExpansionCount > nextReportingExpansionCount && repCacheUpdAd) {
									//	reporting = true;
									//	nextReportingExpansionCount += 1000;
									//}
									//if (satCalcTask->getTaskDepth() > lastTaskDepth) {
									//	lastTaskDepth += 100;
									//	bool debug = true;
									//	reporting = true;
									//}
									//if (reporting) {
									//	LOG(INFO, "::Konclude::Reasoner::Kernel::Algorithm::TableauCompletionAlgorihm", logTr("Expansion reached size %1 (%6 same) for recomputation task %2 with limit %3 (%4 critical) at task depth %5.").arg(currentExpansionCount).arg(repCompId).arg(mOptMaxBackendNeighbourTotalExpansionCount).arg(mOptCriticalBackendNeighbourTotalExpansionCount).arg(satCalcTask->getTaskDepth()).arg(mProcessingDataBox->getBackendCacheIntegratedSameIndividualNodeCount()), this);
									//}


									processTagger->incNodeSwitchTag();
									nodeSwitchHistory->addIndividualProcessNodeSwitch(indiProcNode,processTagger->getCurrentNodeSwitchTag());
									mCalcAlgContext->setMinModificationIndividual(indiProcNode);
									STATINC(INDIVIDUALNODESWITCHCOUNT,mCalcAlgContext);

									//testCompletionGraphCachingAndBlocking(calcAlgContext);

									// initialize individual
									if (individualNodeInitializing(indiProcNode, calcAlgContext)) {

										bool indiStartProcessingDebug = false;
										if (indiStartProcessingDebug) {
											mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList(QString("./Debugging/CompletionTasks/indi-%1-start.txt").arg(indiProcNode->getIndividualNodeID()), calcAlgContext);
										}


										bool continueProcessingIndividual = continueIndividualProcessing(indiProcNode,calcAlgContext);

										while (continueProcessingIndividual && !canceled) {
											CConceptProcessingQueue* conProcQueue = indiProcNode->getConceptProcessingQueue(true);
											conProcDes = conProcQueue->takeNextConceptDescriptorProcess();

											processingDataBox->setLastProcessingIndividualNodeAndConceptDescriptor(indiProcNode,conProcDes);

											// process concept
											mCurrentRecProcDepth = 0;
											++mAppliedTOTALRuleCount;
											STATINC(RULEAPPLICATIONCOUNT,mCalcAlgContext);
											KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeRuleTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));
											KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeRuleDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));


											continueProcessingIndividual = tableauRuleProcessing(indiProcNode,conProcDes,mCalcAlgContext);


											KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mAfterRuleDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

											if (continueProcessingIndividual) {												
												continueProcessingIndividual = continueIndividualProcessing(indiProcNode,calcAlgContext);
											} else {
												addConceptToProcessingQueue(conProcDes,conProcQueue,indiProcNode,calcAlgContext);
											}


											if (--mRemainProcessRuleToTaskProcessingVerification <= 0) {
												mRemainProcessRuleToTaskProcessingVerification = mProcessRuleToTaskProcessingVerificationCount;

												if (cancellationAdapter && cancellationAdapter->canCancelTaskCalculation()) {
													canceled = true;
													throw CCalculationErrorProcessingException(CCalculationErrorProcessingException::ECCANCELED);
												}

												if (repCacheUpdAd && repCacheUpdAd->hasUnsatisfiableComputed()) {
													canceled = true;
													throw CCalculationErrorProcessingException(CCalculationErrorProcessingException::ECCANCELED);
												}

												if (!processorCommunicator->verifyContinueTaskProcessing(satCalcTask)) {
													STATINC(TASKPROCESSPAUSECOUNT,mCalcAlgContext);
													paused = true;
													calcAlgContext->setCurrentIndividualNode(nullptr);
													addIndividualToProcessingQueue(indiProcNode,calcAlgContext);
													throw CCalculationStopProcessingException(false);
												}
											}


										}

										individualNodeConclusion(indiProcNode,calcAlgContext);

									}

									if (mCalcAlgContext->isMinModificationUpdated()) {
										// update history
										nodeSwitchHistory->updateLastIndividualProcessNodeSwitch(mCalcAlgContext->getMinModificationAncestorDepth(),mCalcAlgContext->getMinModificationIndividualID());
									}
								}

								indiProcNode = nullptr;
								if (!canceled) {
									indiProcNode = takeNextProcessIndividual(calcAlgContext);
								}

							}


							if (mOptIncrementalExpansion && !mProcessingDataBox->isIncrementalExpansionCachingMerged()) {
								incrementalMergeWithPreviousNondeterministicCompletionGraph(calcAlgContext);
								mProcessingDataBox->setIncrementalExpansionCachingMerged(true);
							}


							//if (task->getTaskDepth() < 100) {

							//	CSatisfiableCalculationTask* tasks = createDependendBranchingTaskList(2,calcAlgContext);

							//	processorCommunicator->communicateTaskCreation(tasks);
							//	//throw CCalculationStopProcessingException(true);
							//	completed = true;
							//} else {
							//	//CClashedConceptDescriptor* clashDes = CObjectAllocator<CClashedConceptDescriptor>::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
							//	//throw clashDes;
							//	clashed = true;
							//}

							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mSatTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));




							if (mConfPossibleInstanceIndividualsMerging && !canceled) {



								CSatisfiableTaskRealizationPossibleInstancesMergingAdapter* possibleInstancesMergingAdapter = satCalcTask->getSatisfiablePossibleInstancesMergingAdapter();
								if (possibleInstancesMergingAdapter) {



									bool printMergingTask = false;
									if (printMergingTask) {
										QString writingFolder = "./Debugging/CompletionTasks/";
										mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
										QFile file(QString("%1%2-task.txt").arg(writingFolder, "possible-instance-individuals-merging"));
										if (file.open(QIODevice::WriteOnly)) {
											file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
											file.close();
										}
									}


									CPossibleInstancesIndividualsMergingData* possInstanceMergeingData = possibleInstancesMergingAdapter->getPossibleInstanceMergingData();
									if (possInstanceMergeingData) {
										CPossibleInstancesIndividualsMergingLinker* lastMergedPossibleInstanceIndividualLinker = (CPossibleInstancesIndividualsMergingLinker*)processingDataBox->getLastMergedPossibleInstanceIndividualLinker();
										if (lastMergedPossibleInstanceIndividualLinker) {
											if (!lastMergedPossibleInstanceIndividualLinker->isSatisfiableMerged()) {
												++mStatPossibleInstanceMergingSuccessSubmitCount;
												possInstanceMergeingData->incMergingSuccess();
												lastMergedPossibleInstanceIndividualLinker->setSatisfiableMerged();
											}
										}
										CXLinker<CPossibleInstancesIndividualsMergingLinker*>* currentMergedPossibleInstanceIndividualLinkersLinker = (CXLinker<CPossibleInstancesIndividualsMergingLinker*>*)processingDataBox->getCurrentMergedPossibleInstanceIndividualLinkersLinker();
										while (currentMergedPossibleInstanceIndividualLinkersLinker) {
											CPossibleInstancesIndividualsMergingLinker* currentMergedPossibleInstanceIndividualLinker = currentMergedPossibleInstanceIndividualLinkersLinker->getData();
											if (!currentMergedPossibleInstanceIndividualLinker->isSatisfiableMerged()) {
												++mStatPossibleInstanceMergingSuccessSubmitCount;
												possInstanceMergeingData->incMergingSuccess();
												currentMergedPossibleInstanceIndividualLinker->setSatisfiableMerged();
											}
											currentMergedPossibleInstanceIndividualLinkersLinker = (CXLinker<CPossibleInstancesIndividualsMergingLinker*>*)currentMergedPossibleInstanceIndividualLinkersLinker->getNext();
										}


										cint64 testingIndiId = possibleInstancesMergingAdapter->getTestingIndividualReference().getIndividualID();

										// try merging possible Instances
										if (!processingDataBox->isPossibleInstanceIndividualMergingStopped()) {
											CIndividualProcessNode* testingIndiNode = getCorrectedNominalIndividualNode(-testingIndiId, calcAlgContext);
											tryPossibleInstanceMerging(testingIndiNode, possInstanceMergeingData, calcAlgContext);
										} else {
											possInstanceMergeingData->incMergingStreakFails();
										}
									}

								}
							}


							satisfiable = true;


							if (mConfGenerateQueries) {
								CCompletionGraphRandomWalkQueryGenerator queryGen;
								queryGen.generateQueries(calcAlgContext->getSatisfiableCalculationTask());
							}




							//lastBranchingMergingProcRest = lastBranchingMergingProcRest;
							//if (lastBranchingMergingProcRest) {
							//	lastBranchingMergingProcRest->printIndividualContainer();
							//}

							//analyzeCompletionGraphStatistics(calcAlgContext);
							//writeCompletionGraphStatistics(calcAlgContext);

							//testCompletionGraphCachingAndBlocking(calcAlgContext);

						} catch (const CClashedConceptDescriptor*& clashConLinker) {
							clashed = true;
							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mClashedDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));
						} catch (const CCalculationClashProcessingException& calcClashProcException) {
							clashed = true;
							CClashedDependencyDescriptor* clashConLinker = calcClashProcException.getClashedDependencyDescriptor();
							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mClashedDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

							if (mConfDependencyBacktracking) {
								clashedBacktracking(clashConLinker,calcAlgContext);
							}
						} catch (const CCalculationStopProcessingException& calcStopProcException) {
							if (calcStopProcException.isTaskCompletedProcessed()) {
								completed = true;
							}
						} catch (const CCalculationErrorProcessingException& calcErrorProcException) {
							if (calcErrorProcException.hasError()) {
								error = true;
								errorCode = (cint64)calcErrorProcException.getErrorCode();
								if (errorCode != CCalculationErrorProcessingException::ECCANCELED) {
									LOG(ERROR, "::Konclude::Reasoner::Kernel::Algorithm::TableauCompletionAlgorihm", logTr("Error occured, computation stopped."), this);
								}
							}
						} catch (const CMemoryAllocationException& memAllocException) {
							error = true;
							errorCode = 2;
						} catch (...) {
							error = true;
							errorCode = 3;
						}

						KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mEndTaskDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

						if (!error && repCacheUpdAd && repCacheUpdAd->hasUnsatisfiableComputed()) {
							error = true;
							completed = false;
							clashed = false;
						}

						bool xDebug = false;

						//if (satCalcTask->getTaskDepth() % 500 == 0) {
						//	xDebug = true;
						//}

						bool sDebug = false;
						//if (satCalcTask->getClassificationMessageAdapter()) {
						//	CIndividualProcessNode* node = getUpToDateIndividual(calcAlgContext->getProcessingDataBox()->getConstructedIndividualNode(), calcAlgContext);
						//	CIndividualMergingHash* mergingHash = node->getIndividualMergingHash(false);
						//	if (mergingHash) {
						//		bool slected = true;
						//		for (CIndividualMergingHash::const_iterator it = mergingHash->constBegin(), itEnd = mergingHash->constEnd(); it != itEnd && slected; ++it) {
						//			cint64 mergedIndi = it.key();
						//			CIndividualProcessNode* mergedNode = getUpToDateIndividual(-mergedIndi, calcAlgContext);
						//			if (mergedNode && mergedNode->getNominalIndividual()) {
						//				QString mergedIndiName = CIRIName::getRecentIRIName(mergedNode->getNominalIndividual()->getNameLinker());
						//				if (mergedIndiName != "http://www.semanticweb.org/ontologies/2010/9/Ontology1288387737869.owl#Ind350399375764604218" && mergedIndiName != "http://www.semanticweb.org/ontologies/2010/9/Ontology1288387737869.owl#Ind968776124155655128" && mergedIndiName != "http://www.semanticweb.org/ontologies/2010/9/Ontology1288387737869.owl#Swede") {
						//					slected = false;
						//				}
						//			}
						//		}
						//		if (slected) {
						//			bool otherNodesMerged = false;
						//			for (cint64 i = 0; i < 130 && !otherNodesMerged; ++i) {
						//				CIndividualProcessNode* checkNode = getUpToDateIndividual(i, calcAlgContext);
						//				if (checkNode) {
						//					if (node->getIndividualNodeID() != i && checkNode->getMergedIntoIndividualNodeID() == node->getIndividualNodeID()) {
						//						otherNodesMerged = true;
						//					}
						//				}
						//			}
						//			if (!otherNodesMerged) {
						//				sDebug = true;
						//			}
						//		}
						//	}
						//}


						if (mDebug && sDebug || xDebug || mConfDebuggingWriteData && mConfDebuggingWriteDataComplationTasks) {

							CSatisfiableTaskClassificationMessageAdapter* classificationAdapter = satCalcTask->getClassificationMessageAdapter();
							CTaskPreyingAdapter* consistencyAdapter = satCalcTask->getConsistenceAdapter();

							QString writingFolder = "./Debugging/CompletionTasks/";
							QString specializedWritingFileName;

							bool writeDebuggingData = xDebug || mDebug;
							if (classificationAdapter && (mConfDebuggingWriteDataForClassificationTests || mConfDebuggingWriteDataForAllTests) && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;

								CConcept* concept = classificationAdapter->getTestingConcept();
								if (concept && classificationAdapter->hasExtractionFlags(CSatisfiableTaskClassificationMessageAdapter::EFEXTRACTSUBSUMERSROOTNODE)) {
									QString className = CIRIName::getRecentIRIName(concept->getClassNameLinker());
									if (className.contains("/")) {
										className = className.mid(className.lastIndexOf("/") + 1);
									}
									specializedWritingFileName += QString("classification-class-name-%1-satisfiability-test").arg(className);
								}

							} else if (satCalcTask->getSatisfiableTaskIncrementalConsistencyTestingAdapter() && (mConfDebuggingWriteDataForIncrementalExpansionTests || mConfDebuggingWriteDataForAllTests) && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;
								specializedWritingFileName += QString("consistency-incremental-expansion-%1-test").arg(mProcessingDataBox->getIncrementalExpansionID());
							} else if (satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter() && (mConfDebuggingWriteDataForRepCacheIndiComputationTests || mConfDebuggingWriteDataForAllTests) && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;
								CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repCacheUpdAd = satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
								specializedWritingFileName += QString("representative-cache-individual-recomputation-%1-starting-individual-%2-test").arg(repCacheUpdAd->getRepresentativeCacheRecomputationId()).arg(repCacheUpdAd->getFirstIndividualRecomputationId());
							} else if (satCalcTask->getConsistenceAdapter() && (mConfDebuggingWriteDataForConsistencyTests || mConfDebuggingWriteDataForAllTests) && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;
								specializedWritingFileName += "consistency-test";
							} else if (satCalcTask->getSatisfiableAnswererBindingPropagationAdapter() && (mConfDebuggingWriteDataForAnsweringPropagationTests || mConfDebuggingWriteDataForAllTests) && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;
								specializedWritingFileName += "answering-propagation-test";
							} else if (mConfDebuggingWriteDataForAllTests && (!mConfDebuggingWriteDataOnlyOnSatisfiability || satisfiable)) {
								writeDebuggingData = true;
							}/* else if (satCalcTask->getSatisfiableAnswererMaterializationAdapter() && satisfiable) {
								writeDebuggingData = true;
								specializedWritingFileName += QString("query-materilization-test");
							} else if (satCalcTask->getSatisfiableAnswererInstancePropagationMessageAdapter()) {
								writeDebuggingData = true;
								specializedWritingFileName += QString("answering-instance-propagation-test");
							}*/


							if (writeDebuggingData) {
								QString satStopString = QString("stopped");
								if (satisfiable) {
									satStopString = QString("satisfied");
								}
								if (clashed) {
									satStopString = QString("clashed");
								}

								if (specializedWritingFileName.isEmpty()) {
									specializedWritingFileName += "uncategorized-test";
								}

								QString fileName = QString("%1%2-task-%3-%4-%5.txt").arg(writingFolder, specializedWritingFileName, QString::number(satCalcTask->getTaskDepth()), QString::number(satCalcTask->getTaskID()), satStopString);
								mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList(fileName, calcAlgContext);

							}

							

						}








						if (completed) {
							++mStatStoppedCount;
						}
						CBooleanTaskResult* satResult = satCalcTask->getSatisfiableCalculationTaskResult();
						if (clashed) {
							++mStatClashCount;
							if (!satResult->hasResult()) {
								satResult->installResult(false);
							}

							//writeSatisfiableCachedIndividualNodesOfUnsatisfiableBranch(mCalcAlgContext);

							completed = true;
						}
						if (satisfiable) {
							++mStatSatisfiableCount;
							STATINC(ROOTTASKSATISFIABLECOUNT, calcAlgContext);
							satResult->installResult(true);



							//CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(false);
							//if (useBackendConceptSetLabelProcessingHash) {
							//	for (CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash::iterator it = useBackendConceptSetLabelProcessingHash->begin(), itEnd = useBackendConceptSetLabelProcessingHash->end(); it != itEnd; ++it) {
							//		CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& data = it.value();
							//		if (data.getOnlyConceptSetProcessedCount() <= 0) {
							//			CIndividualRepresentativeBackendCacheConceptSetLabelNodeQueuingLinker* queringNodeLinker = data.getQueuingNodeLinker();
							//			while (queringNodeLinker) {
							//				CIndividualProcessNode* queuingIndiNode = queringNodeLinker->getIndividualProcessNode();
							//				queuingIndiNode = getUpToDateIndividual(queuingIndiNode, calcAlgContext);

							//				if (queuingIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENPROCESSINGDELAYING)) {
							//					bool bug = true;
							//				}

							//				queringNodeLinker = queringNodeLinker->getNext();
							//			}
							//		}
							//	}
							//}




							if (!canceled && (mSatTaskConsAnalyser.analyseSatisfiableTask(satCalcTask,mCalcAlgContext) || mSatTaskIncConsAnalyser.analyseSatisfiableTask(satCalcTask,mCalcAlgContext))) {
								rebuildSignatureBlockingCandidateHash(mCalcAlgContext);
							}

							if (!canceled && (satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter() || (satCalcTask->getConsistenceAdapter() && satCalcTask->getConsistenceAdapter()->getConsitenceObserver()))) {
								
								mBackendCacheHandler->tryAssociateNodesWithBackendCache(processingDataBox->getLastBackendCacheIntegratedIndividualNodeLinker(), satCalcTask->getSatisfiableRepresentativeBackendCacheUpdatingAdapter(), calcAlgContext);

								//CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(false);
								//if (expContData && expContData->getCutBackendNeighbourExpansionIndividualLinker()) {
								//	QSet<cint64> expandedIndiIdSet;
								//	CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinker = calcAlgContext->getUsedProcessingDataBox()->getLastBackendCacheIntegratedIndividualNodeLinker();
								//	for (CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinkerIt = expandedIndiNodeLinker; expandedIndiNodeLinkerIt && expandedIndiNodeLinkerIt; expandedIndiNodeLinkerIt = expandedIndiNodeLinkerIt->getNext()) {
								//		cint64 indiId = expandedIndiNodeLinkerIt->getData()->getNominalIndividual()->getIndividualID();
								//		expandedIndiIdSet.insert(indiId);
								//	}


								//	for (CXLinker<CIndividualProcessNode*>* propCutIndiLinkerIt = expContData->getCutBackendNeighbourExpansionIndividualLinker(); propCutIndiLinkerIt; propCutIndiLinkerIt = propCutIndiLinkerIt->getNext()) {
								//		CIndividualProcessNode* propCutIndiNode = propCutIndiLinkerIt->getData();

								//		CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* propCutIndiBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)propCutIndiNode->getIndividualBackendCacheSynchronisationData(false);
								//		CBackendRepresentativeMemoryCacheIndividualAssociationData* propCutIndiAssocData = propCutIndiBackendSyncData->getAssocitaionData();

								//		CBackendNeighbourExpansionQueue* remainNeighExpQueue = propCutIndiBackendSyncData->getBackendNeighbourExpansionQueue(false);
								//		if (remainNeighExpQueue) {
								//			remainNeighExpQueue->visitNeighbourExpansionQueueDataLinkers([&](CBackendNeighbourExpansionQueueDataLinker* expQueuedLinker)->bool {
								//				cint64 cursor = expQueuedLinker->getNeighbourVisitingCursor();
								//				cint64 arrayIndex = expQueuedLinker->getNeighbourArrayId();
								//				CConcept* concept = expQueuedLinker->getConcept();
								//				bool conNegation = expQueuedLinker->getConceptNegation();

								//				CConcept* opConcept = nullptr; 
								//				bool opConceptTestingNegation = false;
								//				if (concept) {
								//					opConcept = concept->getOperandList()->getData();
								//					bool opConceptNegation = concept->getOperandList()->isNegated();
								//					opConceptTestingNegation = opConceptNegation;
								//					if (conNegation && opConcept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
								//						opConceptTestingNegation = !opConceptTestingNegation;
								//					}
								//				}

								//				mBackendCacheHandler->visitNeighbourIndividualIdsForNeighbourArrayIdFromCursor(propCutIndiAssocData, arrayIndex, [&](cint64 neighbourIndividualId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic, cint64 cursor)->bool {

								//					bool affected = false;
								//					CBackendRepresentativeMemoryCacheIndividualAssociationData* neighIndiAssocData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndividualId, calcAlgContext);
								//					if (!opConcept || !mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighIndiAssocData, neighIndiAssocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConceptTestingNegation, true, calcAlgContext)) {
								//						affected = true;
								//					}

								//					if (affected && !expandedIndiIdSet.contains(neighbourIndividualId)) {
								//						mPropCuttedIndiIds.insert(neighbourIndividualId);
								//					}

								//					return true;
								//				}, false, cursor, calcAlgContext);

								//				return true;
								//			});
								//		}

								//	}
								//}
							}

							//testProblematicConceptSet(mCalcAlgContext);

							//analyzeABoxCompressionPossibilities(calcAlgContext);


							//analyzeBranchingMemoryWasting(calcAlgContext);

							if (!canceled) {
								mClassMessAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mClassMessAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								mSatTaskPropClassAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mSatTaskPropClassAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								mMarkerPropRealMessAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mMarkerPropRealMessAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								mPossAssCollAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mPossAssCollAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								mSatTaskCompAnswerAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mSatTaskCompAnswerAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								mSatTaskPropBindingAnswerAnalyser.readCalculationConfig(satCalcTask->getCalculationConfiguration());
								mSatTaskPropBindingAnswerAnalyser.analyseSatisfiableTask(satCalcTask, mCalcAlgContext);

								cacheSatisfiableIndividualNodes(mCalcAlgContext);
							}
							analyseBranchingStatistics(mCalcAlgContext);

							completed = true;
						}
						commitCacheMessages(calcAlgContext);

						if (error) {
							if (satCalcTask->hasActiveReferencedTask()) {
								satCalcTask->clearUninitializedReferenceTasks();
							}
							satCalcTask->getTaskStatus()->setError(error,errorCode);
							processorCommunicator->communicateTaskError(satCalcTask);
							return false;
						}

						if (completed) {
							processorCommunicator->communicateTaskComplete(satCalcTask);
							return false;
						} 
						return true;

					}

					return false;
				}




























				bool CCalculationTableauCompletionTaskHandleAlgorithm::findNextPossibleInstanceMergingIndividual(CIndividualProcessNode* processIndi, CPossibleInstancesIndividualsMergingData* possInstanceMergingData, CCalculationAlgorithmContextBase* calcAlgContext,
							CPROCESSHASH<CBackendRepresentativeMemoryLabelCacheItem*, bool>*& testConceptLabelSetHash, CIndividualProcessNode** foundMergingIndiNode, cint64* foundMergingIndiId, bool* ruleApplicationFreeMerging) {

					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					if (possInstanceMergingData->areAllPossibleInstancesIndividualsNonMerging() || processingDataBox->getRemainingPossibleInstanceIndividualMergingLimit() == 0) {
						return false;
					}

					cint64 maxMergingAttemptCount = possInstanceMergingData->getMaxMergingAttemptCount();
					bool foundPossIndiMerging = false;
					for (cint64 i = 0; i < maxMergingAttemptCount && !foundPossIndiMerging; ++i) {
						foundPossIndiMerging = findNextPossibleInstanceMergingIndividual(processIndi, possInstanceMergingData, calcAlgContext, testConceptLabelSetHash, i, foundMergingIndiNode, foundMergingIndiId, ruleApplicationFreeMerging);
					}
					return foundPossIndiMerging;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::findNextPossibleInstanceMergingIndividual(CIndividualProcessNode* processIndi, CPossibleInstancesIndividualsMergingData* possInstanceMergingData, CCalculationAlgorithmContextBase* calcAlgContext, 
					CPROCESSHASH<CBackendRepresentativeMemoryLabelCacheItem*, bool>*& testConceptLabelSetHash, cint64 individualMaxMergingAttemptCount, CIndividualProcessNode** foundMergingIndiNode, cint64* foundMergingIndiId, bool* ruleApplicationFreeMerging) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();

					if (possInstanceMergingData->areAllPossibleInstancesIndividualsNonMerging() || processingDataBox->getRemainingPossibleInstanceIndividualMergingLimit() == 0) {
						return false;
					}

					if (processingDataBox->getRemainingPossibleInstanceIndividualMergingLimit() == -1) {
						// TODO: set a limit
					} else if (processingDataBox->getRemainingPossibleInstanceIndividualMergingLimit() > 0) {
						processingDataBox->setRemainingPossibleInstanceIndividualMergingLimit(processingDataBox->getRemainingPossibleInstanceIndividualMergingLimit() - 1);
					}

					CPossibleInstancesIndividualsMergingLinker* nextMergedPossibleInstanceIndividualLinker = nullptr;
					CPossibleInstancesIndividualsMergingLinker* initialMergedPossibleInstanceIndividualLinker = (CPossibleInstancesIndividualsMergingLinker*)processingDataBox->getLastMergedPossibleInstanceIndividualLinker();
					CPossibleInstancesIndividualsMergingLinker* lastMergedPossibleInstanceIndividualLinker = initialMergedPossibleInstanceIndividualLinker;
					CPossibleInstancesIndividualsMergingLinker* foundMergedPossibleInstanceIndividualLinker = nullptr;

					bool allPossibleInstancesIndividualsNonMerging = false;


					if (lastMergedPossibleInstanceIndividualLinker) {
						nextMergedPossibleInstanceIndividualLinker = lastMergedPossibleInstanceIndividualLinker->getNextPossibleInstancesIndividualsMergingLinker();
					} else {
						nextMergedPossibleInstanceIndividualLinker = possInstanceMergingData->getPossibleInstancesIndividualsMergingLinker();
						allPossibleInstancesIndividualsNonMerging = true;
					}

					CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher conceptSetBackendLabelOnlyHasher;
					bool conceptSetBackendLabelOnlyRelevant = false;
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)processIndi->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && !backendSyncData->hasNonConceptSetBackendLabelRelatedProcessing()) {
						conceptSetBackendLabelOnlyRelevant = true;
						conceptSetBackendLabelOnlyHasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(backendSyncData->getAssocitaionData(), calcAlgContext);
					}





					bool foundPossibleInstanceMerging = false;
					while (nextMergedPossibleInstanceIndividualLinker && (!foundPossibleInstanceMerging)) {

						// TODO: based on attempts do a more ore less sophisticated checking whether the individual could possibly be considered for merging
						if (!nextMergedPossibleInstanceIndividualLinker->isSatisfiableMerged() && nextMergedPossibleInstanceIndividualLinker->getMergingAttemptCount() <= individualMaxMergingAttemptCount && !nextMergedPossibleInstanceIndividualLinker->isFullTestingScheduled()) {
							allPossibleInstancesIndividualsNonMerging = false;
							nextMergedPossibleInstanceIndividualLinker->incMergingAttempt();
							possInstanceMergingData->incMergingAttempt();

							++mStatPossibleInstanceMergingSearchIndiCount;

							cint64 mergingIndiId = nextMergedPossibleInstanceIndividualLinker->getMergingIndividualId();



							bool mergingTryable = false;
							bool possiblyRequiresRuleApplication = true;
							CIndividualProcessNode* mergingIndiNode = nullptr;

							if (isNominalIndividualNodeAvailable(-mergingIndiId, calcAlgContext)) {

								CIndividualProcessNode* mergingIndiNode = getCorrectedNominalIndividualNode(-mergingIndiId, calcAlgContext);

								possiblyRequiresRuleApplication = false;
								if (isIndividualNodesMergeableWithoutNewRuleApplications(processIndi, mergingIndiNode, &possiblyRequiresRuleApplication, foundPossibleInstanceMerging, calcAlgContext)) {
									mergingTryable = true;
								} else {
									mergingTryable = false;
								}

							} else {

								CBackendRepresentativeMemoryCacheIndividualAssociationData* assData = mBackendCacheHandler->getIndividualAssociationData(mergingIndiId, calcAlgContext);
								if (assData) {
									if (conceptSetBackendLabelOnlyRelevant) {
										CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(assData, calcAlgContext);
										if (conceptSetBackendLabelOnlyHasher == hasher) {
											mergingTryable = true;
											possiblyRequiresRuleApplication = false;
										}
									}

									if (!mergingTryable) {
										// test whether there are some obvious clashes between atomic concepts
										CBackendRepresentativeMemoryLabelCacheItem* conceptSetLabelItem = assData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
										if (testConceptLabelSetHash && testConceptLabelSetHash->contains(conceptSetLabelItem)) {
											mergingTryable = testConceptLabelSetHash->value(conceptSetLabelItem);
										} else {
											bool containsAtomicClash = false;
											CReapplyConceptLabelSet* baseConceptSet = processIndi->getReapplyConceptLabelSet(false);
											mBackendCacheHandler->visitConceptsOfAssociatedFullConceptSetLabel(assData, conceptSetLabelItem, [&](CConcept* concept, bool negation, bool deterministic)->bool {
												if (baseConceptSet->containsConcept(concept, !negation)) {
													containsAtomicClash = true;
													return false;
												}
												return true;
											}, true, false, calcAlgContext);


											mergingTryable = !containsAtomicClash;

											if (!testConceptLabelSetHash) {
												testConceptLabelSetHash = CObjectParameterizingAllocator< CPROCESSHASH<CBackendRepresentativeMemoryLabelCacheItem*, bool>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(), calcAlgContext->getUsedTaskProcessorContext());
											}
											testConceptLabelSetHash->insert(conceptSetLabelItem, mergingTryable);
										}
									}
								}

							}



							if (mergingTryable) {
								if (!possiblyRequiresRuleApplication) {

									nextMergedPossibleInstanceIndividualLinker->incMergingAttempt();
									possInstanceMergingData->incMergingAttempt();
									++mStatPossibleInstanceMergingFoundIndiCount;

									if (!nextMergedPossibleInstanceIndividualLinker->isSatisfiableMerged()) {
										++mStatPossibleInstanceMergingSuccessSubmitCount;
										++mStatPossibleInstanceMergingTriviallySuccessCount;
										possInstanceMergingData->incMergingSuccess();
										nextMergedPossibleInstanceIndividualLinker->setSatisfiableMerged();
									}

								} else {

									if (!foundPossibleInstanceMerging) {
										++mStatPossibleInstanceMergingMaybeMergeableCount;
										foundPossibleInstanceMerging = true;

										if (!mergingIndiNode) {
											mergingIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(mergingIndiId, calcAlgContext);
										}

										if (foundMergingIndiNode) {
											*foundMergingIndiNode = mergingIndiNode;
										}
										if (foundMergingIndiId) {
											*foundMergingIndiId = mergingIndiId;
										}
										foundMergedPossibleInstanceIndividualLinker = nextMergedPossibleInstanceIndividualLinker;
									}
								}

							} else {
								++mStatPossibleInstanceMergingNotMergeableCount;
							}


						} else {
							++mStatPossibleInstanceMergingSkipIndiCount;
						}


						if (!foundMergedPossibleInstanceIndividualLinker) {
							foundMergedPossibleInstanceIndividualLinker = nextMergedPossibleInstanceIndividualLinker;
						}
						lastMergedPossibleInstanceIndividualLinker = nextMergedPossibleInstanceIndividualLinker;
						nextMergedPossibleInstanceIndividualLinker = nextMergedPossibleInstanceIndividualLinker->getNextPossibleInstancesIndividualsMergingLinker();
					}

					if (allPossibleInstancesIndividualsNonMerging) {
						possInstanceMergingData->setAllPossibleInstancesIndividualsNonMerging(true);
					}

					if (!foundMergedPossibleInstanceIndividualLinker) {
						foundMergedPossibleInstanceIndividualLinker = lastMergedPossibleInstanceIndividualLinker;
					}
					processingDataBox->setLastMergedPossibleInstanceIndividualLinker(foundMergedPossibleInstanceIndividualLinker);
					return foundPossibleInstanceMerging;
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryPossibleInstanceMerging(CIndividualProcessNode* processIndi, CPossibleInstancesIndividualsMergingData* possInstanceMergingData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					if (possInstanceMergingData && mConfPossibleInstanceIndividualsMerging) {
						CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

						++mStatPossibleInstanceMergingTryingCount;
						CPROCESSHASH<CBackendRepresentativeMemoryLabelCacheItem*, bool>* testConceptLabelSetHash = nullptr;

						cint64 foundMergingIndiId = -1;
						CIndividual* foundMergingIndi = nullptr;
						CIndividualProcessNode* foundMergingIndiNode = nullptr;
						bool ruleApplicationFreeMerging = false;
						CDependencyTrackPoint* initContinueDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
						bool hasNextMergingIndi = findNextPossibleInstanceMergingIndividual(processIndi, possInstanceMergingData, calcAlgContext, testConceptLabelSetHash, &foundMergingIndiNode, &foundMergingIndiId, &ruleApplicationFreeMerging);
						if (hasNextMergingIndi) {
							++mStatPossibleInstanceMergingCount;
							cint64 taskCreationCount = 2;

							CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(taskCreationCount, calcAlgContext);

							CSatisfiableCalculationTask* newTaskIt = newTaskList;


							CMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode* reuseDepNode = createMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode(processIndi, initContinueDepTrackPoint, foundMergingIndiNode, calcAlgContext);


							for (cint64 i = 0; i < taskCreationCount; ++i) {

								CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;

								CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
								CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext, newProcessContext, newSatCalcTask);
								CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

								bool mergingAlternative = i == 0;

								if (mergingAlternative) {

									CDependencyTrackPoint* mergeNonDetDepTrackPoint = nullptr;
									mergeNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode, false, newCalcAlgContext);


									CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();
									newProcessingDataBox->initProcessingDataBox(processingDataBox);
									newProcessingDataBox->setBackendCacheLoadedAssociationHash(processingDataBox->getBackendCacheLoadedAssociationHash(true));
									newProcessingDataBox->setPossibleInstanceIndividualMergedCount(processingDataBox->getPossibleInstanceIndividualMergedCount() + 1);
									newProcessingDataBox->setPossibleInstanceIndividualCurrentMergingCount(1);


									CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
									// dirty trick, but probably works since for the other alternative there is no processing required, i.e., we can simply overwrite/modify the existing data
									newProcessTagger->incBranchingTag();
									//newProcessTagger->incLocalizationTag();


									CIndividualProcessNode* newLocProcessIndiNode = getLocalizedIndividual(processIndi, false, newCalcAlgContext);
									CIndividualProcessNode* newLocMergingIndiNode = getLocalizedIndividual(foundMergingIndiNode, false, newCalcAlgContext);


									CIndividualProcessNode* locMergedIndiNode = getMergedIndividualNodes(newLocProcessIndiNode, newLocMergingIndiNode, mergeNonDetDepTrackPoint, newCalcAlgContext);



									if (possInstanceMergingData->getMergingStreakFailCount() <= 0) {
										cint64 furtherMergeCount = processingDataBox->getPossibleInstanceIndividualMergingSize();
										if (furtherMergeCount > 1) {
											// try to merge some additional individuals within the same task (to save some memory)

											CXLinker<CXLinker<cint64>*>* currentMergedPossibleInstanceIndividualLinkersLinker = CObjectAllocator< CXLinker<CXLinker<cint64>*> >::allocateAndConstruct(newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager());
											currentMergedPossibleInstanceIndividualLinkersLinker->initLinker(processingDataBox->getLastMergedPossibleInstanceIndividualLinker());


											cint64 currentlyMerged = 1;
											while (hasNextMergingIndi && currentlyMerged <= furtherMergeCount) {
												foundMergingIndiId = -1;
												foundMergingIndi = nullptr;
												foundMergingIndiNode = nullptr;
												ruleApplicationFreeMerging = false;
												hasNextMergingIndi = findNextPossibleInstanceMergingIndividual(locMergedIndiNode, possInstanceMergingData, newCalcAlgContext, testConceptLabelSetHash, &foundMergingIndiNode, &foundMergingIndiId, &ruleApplicationFreeMerging);
												if (hasNextMergingIndi) {
													++mStatPossibleInstanceMergingCount;
													++currentlyMerged;
													newLocMergingIndiNode = getLocalizedIndividual(foundMergingIndiNode, false, newCalcAlgContext);
													locMergedIndiNode = getMergedIndividualNodes(locMergedIndiNode, newLocMergingIndiNode, mergeNonDetDepTrackPoint, newCalcAlgContext);


													CXLinker<CXLinker<cint64>*>* nextMergedPossibleInstanceIndividualLinkersLinker = CObjectAllocator< CXLinker<CXLinker<cint64>*> >::allocateAndConstruct(newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager());
													nextMergedPossibleInstanceIndividualLinkersLinker->initLinker(newProcessingDataBox->getLastMergedPossibleInstanceIndividualLinker());

													currentMergedPossibleInstanceIndividualLinkersLinker = nextMergedPossibleInstanceIndividualLinkersLinker->append(currentMergedPossibleInstanceIndividualLinkersLinker);
												}
											}
											newProcessingDataBox->setPossibleInstanceIndividualCurrentMergingCount(currentlyMerged);
											newProcessingDataBox->setPossibleInstanceIndividualMergedCount(processingDataBox->getPossibleInstanceIndividualMergedCount() + currentlyMerged);
											newProcessingDataBox->setCurrentMergedPossibleInstanceIndividualLinkersLinker(currentMergedPossibleInstanceIndividualLinkersLinker);


										}
										if (furtherMergeCount < 10) {
											furtherMergeCount *= 2;
										} else {
											furtherMergeCount *= 20;
										}
										newProcessingDataBox->setPossibleInstanceIndividualMergingSize(furtherMergeCount);
									}


									prepareBranchedTaskProcessing(locMergedIndiNode, newSatCalcTask, newCalcAlgContext);


								} else {

									createNonDeterministicDependencyTrackPointBranch(reuseDepNode, false, newCalcAlgContext);

									// remove adapter such that no further merging tests are performed
									CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();
									newProcessingDataBox->setPossibleInstanceIndividualMergingStopped(true);
									newProcessingDataBox->setBackendCacheLoadedAssociationHash(processingDataBox->getBackendCacheLoadedAssociationHash(true));

									CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(processIndi, false, newCalcAlgContext);
									prepareBranchedTaskProcessing(newLocIndiNode, newSatCalcTask, newCalcAlgContext);
								}

								// set new task priority
								double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskReusing(newSatCalcTask, calcAlgContext->getUsedSatisfiableCalculationTask(), mergingAlternative);
								newSatCalcTask->setTaskPriority(newTaskPriority);

								newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();

							}


							processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

							throw CCalculationStopProcessingException(true);
						}
					}
					return false;
				}


















































				bool CCalculationTableauCompletionTaskHandleAlgorithm::continueIndividualProcessing(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool purgedIndiBlocked = indiProcNode->hasIndirectBlockedProcessingRestrictionFlags() || indiProcNode->hasPurgedBlockedProcessingRestrictionFlags();
					if (purgedIndiBlocked) {
						return false;
					}

					CConceptProcessingQueue* conProQue = indiProcNode->getConceptProcessingQueue(false);

					if (conProQue && !conProQue->isEmpty()) {
						CConceptProcessPriority conProPri;
						if (conProQue->getNextConceptProcessPriority(&conProPri)) {
							double priority = conProPri.getPriority();
							if (priority < mMinConceptProcessingPriorityLevel) {
								return false;
							}
						}
						return true;
					}
					return false;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::installSaturationCachingReactivation(CIndividualProcessNode* indiProcNode, CSaturationNodeAssociatedDependentNominalSet* nominalSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (nominalSet) {
						CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
						for (CSaturationNodeAssociatedDependentNominalSet::const_iterator it = nominalSet->constBegin(), itEnd = nominalSet->constEnd(); it != itEnd; ++it) {
							cint64 nominalID(*it);
							CIndividualProcessNode* nominalNode = getUpToDateIndividual(-nominalID,calcAlgContext);
							nominalNode->setCachingLossNodeReactivationInstalled(true);
							CIndividualProcessNode* locNominalNode = getLocalizedIndividual(nominalNode,true,calcAlgContext);
							CNominalCachingLossReactivationData* locNominalReactivationData = locNominalNode->getNominalCachingLossReactivationData(true);
							bool nominalBasedCachingPossible = true;
							if (nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) ||
								!nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED) && !nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
								nominalBasedCachingPossible = false;
							}
							if (locNominalReactivationData->hasReactivated()) {
								nominalBasedCachingPossible = false;
							}
							if (!nominalBasedCachingPossible) {
								CIndividualUnsortedProcessingQueue* reactivationQueue = processingDataBox->getNominalCachingLossReactivationProcessingQueue(true);
								reactivationQueue->insertIndiviudalProcessNode(indiProcNode);
							} else {
								locNominalReactivationData->addReactivationIndividualNode(indiProcNode);
							}
						}
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryInstallSaturationCachingReactivation(CIndividualProcessNode* indiProcNode, CSuccessorConnectedNominalSet* nominalSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
					for (CSuccessorConnectedNominalSet::const_iterator it = nominalSet->constBegin(), itEnd = nominalSet->constEnd(); it != itEnd; ++it) {
						cint64 nominalID(*it);
						CIndividualProcessNode* nominalNode = getUpToDateIndividual(-nominalID,calcAlgContext);
						if (nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || 
								!nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED) && !nominalNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
							return false;
						}
						nominalNode->setCachingLossNodeReactivationInstalled(true);
						CNominalCachingLossReactivationData* nominalReactivationData = nominalNode->getNominalCachingLossReactivationData(false);
						if (nominalReactivationData && nominalReactivationData->hasReactivated()) {
							return false;
						}
						CIndividualProcessNode* locNominalNode = getLocalizedIndividual(nominalNode,true,calcAlgContext);
						CNominalCachingLossReactivationData* locNominalReactivationData = locNominalNode->getNominalCachingLossReactivationData(true);
						locNominalReactivationData->addReactivationIndividualNode(indiProcNode);
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::checkIndividualNodesReactivationDueToNominalCachingLoss(CIndividualProcessNode* nominalProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {					
					if (nominalProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) ||
							!nominalProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED) && !nominalProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
						return reactivateIndividualNodesDueToNominalCachingLoss(nominalProcNode,calcAlgContext);
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndividualNodesDueToNominalCachingLoss(CIndividualProcessNode* nominalProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool nodesReactivated = false;
					CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
					CNominalCachingLossReactivationData* nominalReactivationData = nominalProcNode->getNominalCachingLossReactivationData(false);
					CIndividualUnsortedProcessingQueue* reactivationQueue = nullptr;
					if (nominalReactivationData) {
						if (!nominalReactivationData->hasReactivated()) {
							nominalReactivationData = nominalProcNode->getNominalCachingLossReactivationData(true);
							nominalReactivationData->setReactivated(true);
							for (CXLinker<CIndividualProcessNode*>* reactivationLinkerIt = nominalReactivationData->takeReactivationIndividualNodeLinker(); reactivationLinkerIt; reactivationLinkerIt = reactivationLinkerIt->getNext()) {
								CIndividualProcessNode* reactivationIndiNode = reactivationLinkerIt->getData();
								if (!reactivationQueue) {
									reactivationQueue = processingDataBox->getNominalCachingLossReactivationProcessingQueue(true);
								}
								reactivationQueue->insertIndiviudalProcessNode(reactivationIndiNode);
								nodesReactivated = true;
							}
						}
					}
					return nodesReactivated;
				}



				bool individualIDGreaterThan(CXLinker<CIndividualProcessNode*>*& s1, CXLinker<CIndividualProcessNode*>*& s2) {
					return s1->getData()->getIndividualNodeID() > s2->getData()->getIndividualNodeID();
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::takeNextProcessIndividual(CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* indiProcNode = nullptr;
					mIndiNodeConcludeUnsatCaching = false;
					mIndiNodeFromQueueType = INQT_NONE;

					if (!indiProcNode) {
						mMinConceptProcessingPriorityLevel = mImmediatelyProcessPriority;
						if (mProcessingDataBox->hasCacheTestingIndividualNodes()) {
							indiProcNode = mProcessingDataBox->takeNextCacheTestingIndividualNode();
							mIndiNodeConcludeUnsatCaching = true;
							mIndiNodeFromQueueType = INQT_CACHETEST;
						}
					}
					if (!indiProcNode) {
						mIndiImmediateProQueue = mProcessingDataBox->getIndividualImmediatelyProcessingQueue(false);
						if (mIndiImmediateProQueue && !mIndiImmediateProQueue->isEmpty()) {
							mIndiImmediateProQueue = mProcessingDataBox->getIndividualImmediatelyProcessingQueue(true);
							indiProcNode = mIndiImmediateProQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_IMMEDIATE;
						}
					}
					if (!indiProcNode) {
						CIndividualDelayedBackendInitializationProcessingQueue* delayedBackendInitProcQueue = mProcessingDataBox->getDelayedBackendConceptSetLabelProcessingInitializationQueue(false);
						while (delayedBackendInitProcQueue && !delayedBackendInitProcQueue->isEmpty() && !indiProcNode) {
							delayedBackendInitProcQueue = mProcessingDataBox->getDelayedBackendConceptSetLabelProcessingInitializationQueue(true);
							indiProcNode = delayedBackendInitProcQueue->takeNextProcessIndividualNode();

							indiProcNode = getUpToDateIndividual(indiProcNode, calcAlgContext);

							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiProcNode->getIndividualBackendCacheSynchronisationData(false);
							if (backendSyncData && !backendSyncData->isBackendConceptSetInitialized()) {
								mIndiNodeFromQueueType = INQT_DELAYEDBACKENDINIT;
							} else {
								indiProcNode = nullptr;
							}
						}
					}
					if (!indiProcNode) {
						mRoleAssertionProcessingQueue = mProcessingDataBox->getRoleAssertionExpansionProcessingQueue(false);
						if (mRoleAssertionProcessingQueue && !mRoleAssertionProcessingQueue->isEmpty()) {
							mRoleAssertionProcessingQueue = mProcessingDataBox->getRoleAssertionExpansionProcessingQueue(true);
							indiProcNode = mRoleAssertionProcessingQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_ROLEASS;
						}
					}
					if (!indiProcNode) {
						mMinConceptProcessingPriorityLevel = mDeterministicProcessPriority;
						mIndiDetExpProQueue = mProcessingDataBox->getIndividualDepthDeterministicExpansionPreprocessingQueue(false);
						if (mIndiDetExpProQueue && !mIndiDetExpProQueue->isEmpty()) {
							mIndiDetExpProQueue = mProcessingDataBox->getIndividualDepthDeterministicExpansionPreprocessingQueue(true);
							indiProcNode = mIndiDetExpProQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_DETEXP;
						}
					}
					if (!indiProcNode) {
						mIndiDetDeptFirstExpProQueue = mProcessingDataBox->getIndividualDepthFirstDeterministicExpansionProcessingQueue(false);
						if (mIndiDetDeptFirstExpProQueue && !mIndiDetDeptFirstExpProQueue->isEmpty()) {
							mIndiDetDeptFirstExpProQueue = mProcessingDataBox->getIndividualDepthFirstDeterministicExpansionProcessingQueue(true);
							indiProcNode = mIndiDetDeptFirstExpProQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_DEPTHFIRST;
						}
					}





					if (!indiProcNode) {
						mValueSpaceSatCheckingQueue = mProcessingDataBox->getDistinctValueSpaceSatisfiabilityCheckingQueue(false);
						if (mValueSpaceSatCheckingQueue && !mValueSpaceSatCheckingQueue->isEmpty()) {
							mValueSpaceSatCheckingQueue = mProcessingDataBox->getDistinctValueSpaceSatisfiabilityCheckingQueue(true);
							indiProcNode = mValueSpaceSatCheckingQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_VSTSATTESTING;
							if (indiProcNode) {
								indiProcNode = getLocalizedIndividual(indiProcNode,true,calcAlgContext);
							}
						}
					}
					if (!indiProcNode) {
						mValueSpaceTriggeringProQueue = mProcessingDataBox->getValueSpaceTriggeringProcessingQueue(false);
						if (mValueSpaceTriggeringProQueue && !mValueSpaceTriggeringProQueue->isEmpty()) {
							mValueSpaceTriggeringProQueue = mProcessingDataBox->getValueSpaceTriggeringProcessingQueue(true);
							indiProcNode = mValueSpaceTriggeringProQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_VSTRIGGERING;
							if (indiProcNode) {
								indiProcNode = getLocalizedIndividual(indiProcNode,true,calcAlgContext);
							}
						}
					}

					if (!indiProcNode) {
						mBackendSyncRetestProcessingQueue = mProcessingDataBox->getBackendCacheSynchronizationProcessingQueue(false);
						if (mBackendSyncRetestProcessingQueue && !mBackendSyncRetestProcessingQueue->isEmpty()) {
							mBackendSyncRetestProcessingQueue = mProcessingDataBox->getBackendCacheSynchronizationProcessingQueue(true);
							indiProcNode = mBackendSyncRetestProcessingQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_BACKENDSYNCRETEST;
						}
					}
					if (!indiProcNode) {
						mBackendDirectInfluenceExpansionQueue = mProcessingDataBox->getBackendDirectInfluenceExpansionQueue(false);
						if (mBackendDirectInfluenceExpansionQueue && !mBackendDirectInfluenceExpansionQueue->isEmpty()) {
							mBackendDirectInfluenceExpansionQueue = mProcessingDataBox->getBackendDirectInfluenceExpansionQueue(true);
							indiProcNode = mBackendDirectInfluenceExpansionQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_BACKENDDIRECTINFLUENCEEXPANSION;
						}
					}

					if (!indiProcNode) {
						mVarBindConBatchProcessingQueue = mProcessingDataBox->getVariableBindingConceptBatchProcessingQueue(false);
						if (mVarBindConBatchProcessingQueue && !mVarBindConBatchProcessingQueue->isEmpty()) {
							mVarBindConBatchProcessingQueue = mProcessingDataBox->getVariableBindingConceptBatchProcessingQueue(true);

							CConcept* varBindConcept = nullptr;
							CConceptProcessDescriptor* conProDes = nullptr;
							indiProcNode = nullptr;
							mVarBindConBatchProcessingQueue->takeNextConceptProcessIndividual(varBindConcept,indiProcNode,conProDes);
							if (indiProcNode) {
								indiProcNode = getLocalizedIndividual(indiProcNode,true,calcAlgContext);

								indiProcNode->getConceptProcessingQueue(true)->insertConceptProcessDescriptor(conProDes);

								mIndiNodeFromQueueType = INQT_VARBINDBATCHQUE;
							}
						}
					}


					if (!indiProcNode) {
						mIncrementalCompatibilityCheckingQueue = mProcessingDataBox->getIncrementalCompatibilityCheckingQueue(false);
						if (mIncrementalCompatibilityCheckingQueue && !mIncrementalCompatibilityCheckingQueue->isEmpty()) {
							mIncrementalCompatibilityCheckingQueue = mProcessingDataBox->getIncrementalCompatibilityCheckingQueue(true);




							while (!mIncrementalCompatibilityCheckingQueue->isEmpty()) {
								CIndividualProcessNode* compCheckIndiNode = mIncrementalCompatibilityCheckingQueue->takeNextProcessIndividual();
								compCheckIndiNode = getLocalizedIndividual(compCheckIndiNode,true,calcAlgContext);
								compCheckIndiNode->setIncrementalCompatibilityCheckingQueued(false);
								if (compCheckIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED)) {
									compCheckIndiNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED);
								}
								checkCompatibilityUpdateDirectlyChangedPropagation(compCheckIndiNode,calcAlgContext);								
							}
						}
					}
					if (!indiProcNode) {
						mIncrementalExpansionInitializingProcessingQueue = mProcessingDataBox->getIncrementalExpansionInitializingProcessingQueue(false);
						if (mIncrementalExpansionInitializingProcessingQueue && !mIncrementalExpansionInitializingProcessingQueue->isEmpty()) {
							mIncrementalExpansionInitializingProcessingQueue = mProcessingDataBox->getIncrementalExpansionInitializingProcessingQueue(true);


							//if (mIncExpCompIndiModelString.isEmpty()) {
							//	mIncExpCompIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
							//	QFile compFile(QString("./Debugging/CompletionTasks/task-inc-exp-check-compatible-%1.txt").arg(mProcessingDataBox->getIncrementalExpansionID()));
							//	if (compFile.open(QIODevice::WriteOnly)) {
							//		compFile.write(mIncExpCompIndiModelString.replace("<br>","\r\n").toLocal8Bit());
							//		compFile.close();
							//	}
							//}

							while (!mIncrementalExpansionInitializingProcessingQueue->isEmpty()) {
								CIndividualProcessNode* incExpInitIndiNode = mIncrementalExpansionInitializingProcessingQueue->takeNextProcessIndividual();
								incExpInitIndiNode = getLocalizedIndividual(incExpInitIndiNode,true,calcAlgContext);
								incExpInitIndiNode->setIncrementalExpansionQueued(false);
								if (requiresIncrementalNodeExpansion(incExpInitIndiNode,calcAlgContext)) {
									initializeIncrementalIndividualExpansion(incExpInitIndiNode,calcAlgContext);								
								}
							}
						}
					}
					if (!indiProcNode) {
						mIncrementalExpansionProcessingQueue = mProcessingDataBox->getIncrementalExpansionProcessingQueue(false);
						if (mIncrementalExpansionProcessingQueue && !mIncrementalExpansionProcessingQueue->isEmpty()) {
							mIncrementalExpansionProcessingQueue = mProcessingDataBox->getIncrementalExpansionProcessingQueue(true);
							while (!indiProcNode && !mIncrementalExpansionProcessingQueue->isEmpty()) {
								CIndividualProcessNode* incExpIndiNode = mIncrementalExpansionProcessingQueue->takeNextProcessIndividual();
								incExpIndiNode = getLocalizedIndividual(incExpIndiNode,true,calcAlgContext);
								incExpIndiNode->setIncrementalExpansionQueued(false);
								if (requiresIncrementalNodeExpansion(incExpIndiNode,calcAlgContext)) {
									indiProcNode = incrementalNodeExpansion(incExpIndiNode,calcAlgContext);		
								}
							}
						}
					}

					if (!indiProcNode) {
						if (mOptIncrementalExpansion && !mProcessingDataBox->isIncrementalExpansionCompatibleMerged()) {

							//mIncExpCompIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
							//QFile compFile(QString("./Debugging/CompletionTasks/task-inc-exp-compatible-%1.txt").arg(mProcessingDataBox->getIncrementalExpansionID()));
							//if (compFile.open(QIODevice::WriteOnly)) {
							//	compFile.write(mIncExpCompIndiModelString.replace("<br>","\r\n").toLocal8Bit());
							//	compFile.close();
							//}

							incrementalMergeWithPreviousDeterministicCompletionGraph(calcAlgContext);
							mProcessingDataBox->setIncrementalExpansionCompatibleMerged(true);
							mOptIncrementalCompatibleExpansion = false;
							mOptIncrementalCachingExpansion = true;

							//mIncExpMergedIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
							//QFile mergeFile(QString("./Debugging/CompletionTasks/task-inc-exp-merged-%1.txt").arg(mProcessingDataBox->getIncrementalExpansionID()));
							//if (mergeFile.open(QIODevice::WriteOnly)) {
							//	mergeFile.write(mIncExpMergedIndiModelString.replace("<br>","\r\n").toLocal8Bit());
							//	mergeFile.close();
							//}

						}
					}


					if (!indiProcNode) {
						mEarlyIndiReactProcessingQueue = mProcessingDataBox->getEarlyIndividualReactivationProcessingQueue(false);
						if (mEarlyIndiReactProcessingQueue && !mEarlyIndiReactProcessingQueue->isEmpty()) {
							mEarlyIndiReactProcessingQueue = mProcessingDataBox->getEarlyIndividualReactivationProcessingQueue(true);
							CIndividualProcessNode* reactIndiNode = nullptr;
							bool forceReactivation = false;
							mEarlyIndiReactProcessingQueue->takeNextReactivationIndividual(reactIndiNode,forceReactivation);
							indiProcNode = getLocalizedIndividual(reactIndiNode,true,calcAlgContext);
							if (forceReactivation) {
								if (indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
									indiProcNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED);
									reapplySatisfiableCachedAbsorbedDisjunctionConcepts(indiProcNode,calcAlgContext);
									reapplySatisfiableCachedAbsorbedGeneratingConcepts(indiProcNode,calcAlgContext);
								}
								indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED);
							}
							mIndiNodeFromQueueType = INQT_COMPCACHEDREACT;
						}
					}
					if (!indiProcNode) {
						if (!mProcessingDataBox->hasNominalNonDeterministicProcessingNodesSorted()) {
							// sort nominal processing nodes
							CXLinker<CIndividualProcessNode*>* nomNonDetProLinker = mProcessingDataBox->getSortedNominalNonDeterministicProcessingNodeLinker();
							CPROCESSINGLIST< CXLinker<CIndividualProcessNode*>* > nomNonDetProLinkerList(calcAlgContext->getUsedTaskProcessorContext());
							while (nomNonDetProLinker) {
								CXLinker<CIndividualProcessNode*>* tmpNomNonDetProLinker = nomNonDetProLinker;
								nomNonDetProLinker = nomNonDetProLinker->getNext();
								tmpNomNonDetProLinker->clearNext();
								nomNonDetProLinkerList.append(tmpNomNonDetProLinker);
							}
							mProcessingDataBox->clearSortedNominalNonDeterministicProcessingNodeLinker();
							qSort(nomNonDetProLinkerList.begin(),nomNonDetProLinkerList.end(),individualIDGreaterThan);
							for (CPROCESSINGLIST< CXLinker<CIndividualProcessNode*>* >::const_iterator it = nomNonDetProLinkerList.constBegin(), itEnd = nomNonDetProLinkerList.constEnd(); it != itEnd; ++it) {
								CXLinker<CIndividualProcessNode*>* tmpNomNonDetProLinker(*it);
								mProcessingDataBox->addSortedNominalNonDeterministicProcessingNodeLinker(tmpNomNonDetProLinker);
							}
							mProcessingDataBox->setNominalNonDeterministicProcessingNodesSorted(true);
						}
					}





					// prepare reuse of backend expansion
					if (!indiProcNode && mOptBackendExpansionReuse) {
						prepareBackendExpansionReuseBranching(calcAlgContext);
					}


					if (!indiProcNode && mOptBackendExpansionReuse) {
						CBackendNeighbourExpansionControllingData* expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
						if (expContData->isFixedReuseExpansionMode()) {
							mBackendReuseExpansionQueue = mProcessingDataBox->getBackendIndividualReuseExpansionQueue(false);
							if (mBackendReuseExpansionQueue && !mBackendReuseExpansionQueue->isEmpty()) {
								mBackendReuseExpansionQueue = mProcessingDataBox->getBackendIndividualReuseExpansionQueue(true);
								indiProcNode = mBackendReuseExpansionQueue->takeNextProcessIndividualNode();
								mIndiNodeFromQueueType = INQT_BACKENDEXPANSIONREUSE;
							}
						}
					}




					if (!indiProcNode) {
						mMinConceptProcessingPriorityLevel = 0;
						mProcessingQueue = mProcessingDataBox->getIndividualProcessingQueue(false);
						if (mProcessingQueue && !mProcessingQueue->isEmpty()) {
							mProcessingQueue = mProcessingDataBox->getIndividualProcessingQueue(true);
							CIndividualProcessNodeDescriptor* indiProcessNodeDes = mProcessingQueue->takeNextProcessIndividualDescriptor();
							indiProcNode = indiProcessNodeDes->getIndividual();
							mIndiNodeFromQueueType = INQT_OUTDATED;
						}
					}
					if (!indiProcNode) {
						// process remaining concepts on nominal nodes
						mNominalProcessingQueue = mProcessingDataBox->getNominalProcessingQueue(false);
						if (mNominalProcessingQueue && !mNominalProcessingQueue->isEmpty()) {
							mNominalProcessingQueue = mProcessingDataBox->getNominalProcessingQueue(true);
							indiProcNode = mNominalProcessingQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_NOMINAL;
						}
					}




					if (!indiProcNode && mOptLimitBackendNeighbourExpansion) {
						// remaining backend neighbour expansion
						mBackendNeighbourExpansionQueue = mProcessingDataBox->getBackendIndividualNeighbourExpansionQueue(false);

						CBackendNeighbourExpansionControllingData* expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
						while (!indiProcNode && mBackendNeighbourExpansionQueue && !mBackendNeighbourExpansionQueue->isEmpty()) {
							mBackendNeighbourExpansionQueue = mProcessingDataBox->getBackendIndividualNeighbourExpansionQueue(true);

							CIndividualProcessNode* baseIndiNode = mBackendNeighbourExpansionQueue->takeNextProcessIndividualNode();

							indiProcNode = queuedIndividualBackendNeighbourExpansion(baseIndiNode, expContData, calcAlgContext);
						}
					}

					if (!indiProcNode && mOptLimitBackendNeighbourExpansion) {
						bool propCutExpanded = false;
						CBackendNeighbourExpansionControllingData* expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(false);
						if (!indiProcNode && expContData && expContData->getLastBackendExpandedEnsuringExistingIndividualLinksLinker() != mProcessingDataBox->getLastBackendCacheIntegratedIndividualNodeLinker()) {
							expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
							CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinker = mProcessingDataBox->getLastBackendCacheIntegratedIndividualNodeLinker();
							for (CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinkerIt = expandedIndiNodeLinker; expandedIndiNodeLinkerIt && expandedIndiNodeLinkerIt != expContData->getLastBackendExpandedEnsuringExistingIndividualLinksLinker(); expandedIndiNodeLinkerIt = expandedIndiNodeLinkerIt->getNext()) {
								CIndividualProcessNode* expandedIndiNode = expandedIndiNodeLinkerIt->getData();
								cint64 neighbourIndiId = expandedIndiNode->getNominalIndividual()->getIndividualID();
								for (CXLinker<CIndividualProcessNode*>* propCutIndiNodeLinkerIt = expContData->getLastCutBackendNeighbourExpansionEnsuringExistingIndividualLinksLinker(); propCutIndiNodeLinkerIt; propCutIndiNodeLinkerIt = propCutIndiNodeLinkerIt->getNext()) {
									CIndividualProcessNode* propCutIndiNode = propCutIndiNodeLinkerIt->getData();
									propCutIndiNode = getLocalizedIndividual(propCutIndiNode, true, calcAlgContext);
									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locPropCutIndiBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(propCutIndiNode, calcAlgContext);
									CBackendRepresentativeMemoryCacheIndividualAssociationData* propCutIndiAssocData = locPropCutIndiBackendSyncData->getAssocitaionData();
									CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel = propCutIndiAssocData->getNeighbourRoleSetHash()->getNeighbourRoleSetLabel(neighbourIndiId);
									if (neighbourRoleSetLabel) {
										cint64 arrayIndex = propCutIndiAssocData->getRoleSetNeighbourArray()->getIndexData()->getIndex(neighbourRoleSetLabel);
										if (arrayIndex >= 0) {
											CBackendNeighbourExpansionQueue* neighExpQueue = locPropCutIndiBackendSyncData->getBackendNeighbourExpansionQueue(false);
											if (neighExpQueue) {
												CBackendNeighbourExpansionQueueDataLinker* backendNeighbourExpDataLinker = neighExpQueue->findNeighbourExpansionQueueDataLinker(arrayIndex);
												if (neighExpQueue->hasCuttedPropagationCutPropagation() || backendNeighbourExpDataLinker) {
													ensurePropagationCutLinksToExpandedIndividual(propCutIndiNode, locPropCutIndiBackendSyncData, backendNeighbourExpDataLinker, neighbourIndiId, calcAlgContext);
													propCutExpanded = true;
												}

											}
										}
									}
								}

							}
							expContData->setLastBackendExpandedEnsuringExistingIndividualLinksLinker(expandedIndiNodeLinker);
						}


						if (!indiProcNode && expContData && expContData->getLastCutBackendNeighbourExpansionEnsuringExistingIndividualLinksLinker() != expContData->getCutBackendNeighbourExpansionIndividualLinker()) {
							expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
							for (CXLinker<CIndividualProcessNode*>* propCutIndiNodeLinkerIt = expContData->getCutBackendNeighbourExpansionIndividualLinker(); propCutIndiNodeLinkerIt && propCutIndiNodeLinkerIt != expContData->getLastCutBackendNeighbourExpansionEnsuringExistingIndividualLinksLinker(); propCutIndiNodeLinkerIt = propCutIndiNodeLinkerIt->getNext()) {
								CIndividualProcessNode* propCutIndiNode = propCutIndiNodeLinkerIt->getData();
								propCutIndiNode = getLocalizedIndividual(propCutIndiNode, true, calcAlgContext);
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locPropCutIndiBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(propCutIndiNode, calcAlgContext);
								CBackendRepresentativeMemoryCacheIndividualAssociationData* propCutIndiAssocData = locPropCutIndiBackendSyncData->getAssocitaionData();
								CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinker = mProcessingDataBox->getLastBackendCacheIntegratedIndividualNodeLinker();
								for (CXLinker<CIndividualProcessNode*>* expandedIndiNodeLinkerIt = expandedIndiNodeLinker; expandedIndiNodeLinkerIt && expandedIndiNodeLinkerIt; expandedIndiNodeLinkerIt = expandedIndiNodeLinkerIt->getNext()) {
									CIndividualProcessNode* expandedIndiNode = expandedIndiNodeLinkerIt->getData();
									cint64 neighbourIndiId = expandedIndiNode->getNominalIndividual()->getIndividualID();
									CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel = propCutIndiAssocData->getNeighbourRoleSetHash()->getNeighbourRoleSetLabel(neighbourIndiId);
									if (neighbourRoleSetLabel) {
										cint64 arrayIndex = propCutIndiAssocData->getRoleSetNeighbourArray()->getIndexData()->getIndex(neighbourRoleSetLabel);
										if (arrayIndex >= 0) {
											CBackendNeighbourExpansionQueue* neighExpQueue = locPropCutIndiBackendSyncData->getBackendNeighbourExpansionQueue(false);
											if (neighExpQueue) {
												CBackendNeighbourExpansionQueueDataLinker* backendNeighbourExpDataLinker = neighExpQueue->findNeighbourExpansionQueueDataLinker(arrayIndex);
												if (neighExpQueue->hasCuttedPropagationCutPropagation() || backendNeighbourExpDataLinker) {
													ensurePropagationCutLinksToExpandedIndividual(propCutIndiNode, locPropCutIndiBackendSyncData, backendNeighbourExpDataLinker, neighbourIndiId, calcAlgContext);
													propCutExpanded = true;
												}
											}
										}
									}
								}

							}
							expContData->setLastCutBackendNeighbourExpansionEnsuringExistingIndividualLinksLinker(expContData->getCutBackendNeighbourExpansionIndividualLinker());
						}
						if (!indiProcNode && propCutExpanded) {
							indiProcNode = takeNextProcessIndividual(calcAlgContext);
						}
					}


					if (!indiProcNode) {
						if (mProcessingDataBox->hasSortedNominalNonDeterministicProcessingNodes()) {
							indiProcNode = mProcessingDataBox->takeSortedNominalNonDeterministicProcessingNode();
							mIndiNodeFromQueueType = INQT_NOMINAL;
						}
					}
					if (!indiProcNode) {
						// depth based processing for blockable node
						mDepthProcessingQueue = mProcessingDataBox->getIndividualDepthProcessingQueue(false);
						if (mDepthProcessingQueue && !mDepthProcessingQueue->isEmpty()) {
							mDepthProcessingQueue = mProcessingDataBox->getIndividualDepthProcessingQueue(true);
							indiProcNode = mDepthProcessingQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_DEPTHNORMAL;
						}
					}
					if (!indiProcNode) {
						// processing of new nodes with depth first
						mNominalCachingLossReactivationProcessingQueue = mProcessingDataBox->getNominalCachingLossReactivationProcessingQueue(false);
						if (mNominalCachingLossReactivationProcessingQueue && !mNominalCachingLossReactivationProcessingQueue->isEmpty()) {
							mNominalCachingLossReactivationProcessingQueue = mProcessingDataBox->getNominalCachingLossReactivationProcessingQueue(true);
							CIndividualProcessNode* tmpIndiProcNode = mNominalCachingLossReactivationProcessingQueue->takeNextProcessIndividualNode();
							tmpIndiProcNode = getUpToDateIndividual(tmpIndiProcNode,calcAlgContext);
							if (tmpIndiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
								indiProcNode = getLocalizedIndividual(tmpIndiProcNode,false,calcAlgContext);
								indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDINVALIDATED);
							}
							mIndiNodeFromQueueType = INQT_NOMINALCACHINGLOSSREACTIVATION;
						}
					}
					if (!indiProcNode) {
						// processing of new nodes with depth first
						mDepthFirstProcessingQueue = mProcessingDataBox->getIndividualDepthFirstProcessingQueue(false);
						if (mDepthFirstProcessingQueue && !mDepthFirstProcessingQueue->isEmpty()) {
							mDepthFirstProcessingQueue = mProcessingDataBox->getIndividualDepthFirstProcessingQueue(true);
							indiProcNode = mDepthFirstProcessingQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_DEPTHFIRST;
						}
					}


					if (!indiProcNode) {
						mLateIndiReactProcessingQueue = mProcessingDataBox->getLateIndividualReactivationProcessingQueue(false);
						if (mLateIndiReactProcessingQueue && !mLateIndiReactProcessingQueue->isEmpty()) {
							mLateIndiReactProcessingQueue = mProcessingDataBox->getLateIndividualReactivationProcessingQueue(true);
							CIndividualProcessNode* reactIndiNode = nullptr;
							bool forceReactivation = false;
							mLateIndiReactProcessingQueue->takeNextReactivationIndividual(reactIndiNode,forceReactivation);
							indiProcNode = getLocalizedIndividual(reactIndiNode,true,calcAlgContext);
							if (forceReactivation) {
								if (indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
									indiProcNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED);
									reapplySatisfiableCachedAbsorbedDisjunctionConcepts(indiProcNode,calcAlgContext);
									reapplySatisfiableCachedAbsorbedGeneratingConcepts(indiProcNode,calcAlgContext);
								}
								indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED);
							}
							mIndiNodeFromQueueType = INQT_COMPCACHEDREACT;
						}
					}


					if (!indiProcNode) {
						mOptDetExpPreporcessing = false;
						mIndiSigBlockUpdProQueue = mProcessingDataBox->getBlockingUpdateReviewProcessingQueue(false);
						if (mIndiSigBlockUpdProQueue && !mIndiSigBlockUpdProQueue->isEmpty()) {
							mIndiSigBlockUpdProQueue = mProcessingDataBox->getBlockingUpdateReviewProcessingQueue(true);
							indiProcNode = mIndiSigBlockUpdProQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_BLOCKUP;
						}
					}
					if (!indiProcNode) {
						mIndiBlockReactProQueue = mProcessingDataBox->getBlockedReactivationProcessingQueue(false);
						if (mIndiBlockReactProQueue && !mIndiBlockReactProQueue->isEmpty()) {
							mIndiBlockReactProQueue = mProcessingDataBox->getBlockedReactivationProcessingQueue(true);
							indiProcNode = mIndiBlockReactProQueue->takeNextProcessIndividual();
							mIndiNodeFromQueueType = INQT_BLOCKREACT;
						}
					}

					if (!indiProcNode) {
						mSigBlockRevSet = mProcessingDataBox->getSignatureBlockingReviewSet(false);
						if (mSigBlockRevSet && !mSigBlockRevSet->isEmpty()) {
							mSigBlockRevSet = mProcessingDataBox->getSignatureBlockingReviewSet(true);
							bool isNonSubSetData = true;
							CSignatureBlockingReviewData* reviewData = mSigBlockRevSet->getNonSubsetReviewData();
							if (reviewData->isEmpty()) {
								isNonSubSetData = false;
								reviewData = mSigBlockRevSet->getSubsetReviewData();
							}

							CSignatureBlockingReviewDataIterator revIt = reviewData->getIterator();

							if (revIt.hasNext()) {

								cint64 blockedIndiID = revIt.next(false);
								revIt.removeAndMoveNext();

								indiProcNode = getLocalizedIndividual(blockedIndiID,calcAlgContext);

								if (!isNonSubSetData && mConfIndividualReusingFromSignatureBlocking) {
									// try to establish individual reusing
									upgradeSignatureBlockingToIndividualReusing(indiProcNode,calcAlgContext);
								}

								CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
								CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = indiProcNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
								if (!locSigBlockingData) {
									CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = indiProcNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
									locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locSigBlockingData->initBlockingExpansionData(sigBlockingData);
									indiProcNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
								}
								if (!locSigBlockingData->isIdenticConceptSetRequired()) {
									locSigBlockingData->setIdenticConceptSetRequired(true);
									indiProcNode->setLastSearchBlockerCandidateCount(0);
									detectIndividualNodeSignatureBlockingStatus(indiProcNode,calcAlgContext);
								}
							}

						}
					}
					if (!indiProcNode) {
						mReusingReviewData = calcAlgContext->getProcessingDataBox()->getReusingReviewData(false);
						if (mReusingReviewData && !mReusingReviewData->isEmpty()) {
							mReusingReviewData = calcAlgContext->getProcessingDataBox()->getReusingReviewData(false);

							while (mReusingReviewData->hasNextIndividualID() && !indiProcNode) {
								cint64 indiNodeID = mReusingReviewData->takeNextIndividualID();

								indiProcNode = getLocalizedIndividual(indiNodeID,calcAlgContext);
								CReusingIndividualNodeConceptExpansionData* reuseData = indiProcNode->getReusingIndividualNodeConceptExpansionData(false);
								if (!reuseData->isConceptSetStillSubset()) {
									removeIndividualReusing(indiProcNode,calcAlgContext);
								} else {
									indiProcNode = nullptr;
								}
							}
						}
					}

					if (!indiProcNode && mOptLimitBackendNeighbourExpansion) {
						mBackendLateNeighbourExpansionQueue = mProcessingDataBox->getBackendLateIndividualNeighbourExpansionQueue(false);
						if (mBackendLateNeighbourExpansionQueue && !mBackendLateNeighbourExpansionQueue->isEmpty()) {
							mBackendLateNeighbourExpansionQueue = mProcessingDataBox->getBackendLateIndividualNeighbourExpansionQueue(true);
							mBackendNeighbourExpansionQueue = mProcessingDataBox->getBackendIndividualNeighbourExpansionQueue(true);
							CBackendNeighbourExpansionControllingData* expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
							while (!mBackendLateNeighbourExpansionQueue->isEmpty()) {
								CIndividualProcessNode* expQueNode = mBackendLateNeighbourExpansionQueue->takeNextProcessIndividualNode();
								if (!indiProcNode) {
									indiProcNode = queuedIndividualBackendNeighbourExpansion(expQueNode, expContData, calcAlgContext);
								} else {
									mBackendNeighbourExpansionQueue->insertIndiviudalProcessNode(expQueNode);
								}
							}
						}
					}

					if (!indiProcNode && mOptBackendExpansionReuse) {
						CBackendNeighbourExpansionControllingData* expContData = mProcessingDataBox->getBackendNeighbourExpansionControllingData(true);
						if (expContData->isPrioritizedReuseExpansionMode()) {
							mBackendReuseExpansionQueue = mProcessingDataBox->getBackendIndividualReuseExpansionQueue(false);
							if (mBackendReuseExpansionQueue && !mBackendReuseExpansionQueue->isEmpty()) {
								mBackendReuseExpansionQueue = mProcessingDataBox->getBackendIndividualReuseExpansionQueue(true);
								indiProcNode = mBackendReuseExpansionQueue->takeNextProcessIndividualNode();
								mIndiNodeFromQueueType = INQT_BACKENDEXPANSIONREUSE;
							}
						}
					}


					if (!indiProcNode) {
						mDelayedNominalProcessingQueue = mProcessingDataBox->getDelayingNominalProcessingQueue(false);
						if (mDelayedNominalProcessingQueue) {
							mDelayedNominalProcessingQueue = mProcessingDataBox->getDelayingNominalProcessingQueue(true);
							indiProcNode = mDelayedNominalProcessingQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_DELAYEDNOMINAL;
						}
					}

					if (!indiProcNode) {
						mBackendIndirectCompatibilityExpansionQueue = mProcessingDataBox->getBackendIndirectCompatibilityExpansionQueue(false);
						while (!indiProcNode && mBackendIndirectCompatibilityExpansionQueue && !mBackendIndirectCompatibilityExpansionQueue->isEmpty()) {
							mBackendIndirectCompatibilityExpansionQueue = mProcessingDataBox->getBackendIndirectCompatibilityExpansionQueue(true);
							indiProcNode = mBackendIndirectCompatibilityExpansionQueue->takeNextProcessIndividualNode();
							mIndiNodeFromQueueType = INQT_BACKENDINDIRECTCOMPATIBILITYEXPANSION;

							if (!indiProcNode->hasPurgedBlockedProcessingRestrictionFlags()) {
								cint64 prevId = indiProcNode->getIndividualNodeID();
								indiProcNode = getCorrectedNominalIndividualNode(prevId, calcAlgContext);
								indiProcNode = getLocalizedIndividual(indiProcNode, false, calcAlgContext);
								if (!indiProcNode->hasPurgedBlockedProcessingRestrictionFlags()) {
									if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED) && !indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION)) {
										detectIndividualNodeBackendCacheSynchronized(indiProcNode, calcAlgContext);
									}
									expandDirectlyInfluencedIndividualNeighbourNodesFromBackendCache(indiProcNode, calcAlgContext);

									if (indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSINGINDIVIDUAL) && !indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED)) {
										reuseIndividualBackendExpansion(indiProcNode, calcAlgContext);
									} else {

										// Check whether this is indeed necessary in case of backend expansion reuse
										expandIndirectCompatibleRequiredIndividualNeighbourNodesFromBackendCache(indiProcNode, calcAlgContext);
									}
								} else {
									indiProcNode = nullptr;
								}
							} else {
								indiProcNode = nullptr;
							}
						}
					}


					return indiProcNode;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::analyzeCompletionGraphStatistics(CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();
					cint64 indiCount = indiNodeVec->getItemCount();
					cint64 indiStart = indiNodeVec->getItemMinIndex();
					for (cint64 indiIdx = indiStart; indiIdx < indiCount; ++indiIdx) {
						CIndividualProcessNode* indiNode = getLocalizedIndividual(indiIdx,calcAlgContext);
						if (indiNode) {
							cint64 conSigValue = indiNode->getReapplyConceptLabelSet(false)->getConceptSignatureValue();
							mSignatureIndiNodeStatusHash.insertMulti(conSigValue,indiNode->getProcessingRestrictionFlags());

							if (!mSignatureIndiNodePredDepHash.contains(conSigValue)) {
								CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
								if (conSet && indiNode->getIndividualAncestorDepth() > 0) {
									cint64 conFromPredCount = 0;
									CConceptDescriptor* conDesIt = conSet->getAddingSortedConceptDescriptionLinker();
									while (conDesIt) {
										if (conDesIt->getConceptTag() != 1) {
											if (isConceptFromPredecessorDependent(indiNode,conDesIt,conDesIt->getDependencyTrackPoint(),calcAlgContext)) {
												++conFromPredCount;
											}
										}
										conDesIt = conDesIt->getNext();
									}
									mSignatureIndiNodePredDepHash.insert(conSigValue,conFromPredCount);
								}
							}
						}
					}
					mIndiNodeCountMap.insert(indiCount,mIndiNodeCountMap.value(indiCount,0)+1);
					mIndiNodeCountList.append(indiCount);
				}















































				bool CCalculationTableauCompletionTaskHandleAlgorithm::areAllDependentFactsUnchanged(CIndividualProcessNode* individualNode, CIndividualProcessNode* backtrackedIndividualNode, CDependencyTrackPoint* prevConDepTrackPoint, CIndividualProcessNodeVector* prevIndiNodeVec, cint64& remBacktrackCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (--remBacktrackCount < 0) {
						return false;
					}
					CDependencyNode* depNode = prevConDepTrackPoint->getDependencyNode();
					if (depNode) {
						CIndividualProcessNode* assocIndiNode = depNode->getAppropriateIndividualNode();
						if (assocIndiNode) {
							if (assocIndiNode->isBlockableIndividual()) {
								return false;
							}
							CIndividualProcessNode* locAssIndiNode = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector()->getData(assocIndiNode->getIndividualNodeID());
							if (locAssIndiNode) {
								return false;
							}
						}
						bool addRoleExistDep = false;
						CDependencyIterator addDepIt = depNode->getAdditionalDependencyIterator(true,true);
						while (addDepIt.hasNext()) {
							CDependency* addDep = addDepIt.nextDependency();
							CDependencyTrackPoint* prevAddDepTrackPoint = addDep->getPreviousDependencyTrackPoint();
							CDependencyNode* prevAddDepNode = addDep->getPreviousTrackedDependency();
							if (prevAddDepNode->getDependencyType() == CDependencyNode::DNTROLEASSERTIONDEPENDENCY) {
								if (addRoleExistDep) {
									return false;
								}
								addRoleExistDep = true;
							} else if (prevAddDepNode->getDependencyType() == CDependencyNode::DNTSOMEDEPENDENCY) {
								if (addRoleExistDep) {
									return false;
								}
								CIndividualProcessNode* addAssocIndiNode = prevAddDepNode->getAppropriateIndividualNode();
								if (addAssocIndiNode && addAssocIndiNode->isBlockableIndividual()) {
									return false;
								}
								if (!areAllDependentFactsUnchanged(individualNode,addAssocIndiNode?addAssocIndiNode:backtrackedIndividualNode,prevAddDepTrackPoint,prevIndiNodeVec,remBacktrackCount,calcAlgContext)) {
									return false;
								}
								addRoleExistDep = true;
							} else if (prevAddDepTrackPoint) {
								if (!areAllDependentFactsUnchanged(individualNode,assocIndiNode?assocIndiNode:backtrackedIndividualNode,prevAddDepTrackPoint,prevIndiNodeVec,remBacktrackCount,calcAlgContext)) {
									return false;
								}
							}
						}
						if (depNode->getDependencyType() != CDependencyNode::DNTINDEPENDENTBASE) {
							CDependencyTrackPoint* prevDepTrackPoint = depNode->getPreviousDependencyTrackPoint();
							if (prevDepTrackPoint) {
								if (!areAllDependentFactsUnchanged(individualNode,assocIndiNode?assocIndiNode:backtrackedIndividualNode,prevDepTrackPoint,prevIndiNodeVec,remBacktrackCount,calcAlgContext)) {
									return false;
								}
								return true;
							}
						} else if (backtrackedIndividualNode && backtrackedIndividualNode != individualNode) {
							return true;
						}

					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::initializeIncrementalIndividualExpansion(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (!incExpData || !incExpData->isIncremetnalExpansionListInitialized()) {
						incExpData = individualNode->getIncrementalExpansionData(true);
						CIndividualProcessNodeVector* indiNodeVec = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector();

						CPROCESSINGSET<cint64>* searchingNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
						CPROCESSINGLIST<cint64>* searchingNodeList = CObjectParameterizingAllocator< CPROCESSINGLIST<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());

						CPROCESSLIST<CIndividual*>* expList = nullptr;

						CSatisfiableCalculationTask* prevCalcTask = mIncExpHandler->getPreviousDeterministicCompletionGraphTask(calcAlgContext);
						CProcessingDataBox* prevDataBox = prevCalcTask->getProcessingDataBox();
						CIndividualProcessNodeVector* prevIndiNodeVec = prevDataBox->getIndividualProcessNodeVector();

						CIndividualProcessNode* prevIndiNode = incExpData->getPreviousCompletionGraphCorrespondenceIndividualNode();
						if (prevIndiNode) {
							CReapplyConceptLabelSet* conSet = individualNode->getReapplyConceptLabelSet(false);
							CReapplyConceptLabelSet* prevConSet = prevIndiNode->getReapplyConceptLabelSet(false);
							if (conSet && prevConSet) {
								CReapplyConceptLabelSetIterator conSetIt = conSet->getConceptLabelSetIterator(true);
								CReapplyConceptLabelSetIterator prevConSetIt = prevConSet->getConceptLabelSetIterator(true);
								while (conSetIt.hasNext() && prevConSetIt.hasNext()) {
									cint64 conTag = conSetIt.getDataTag();
									cint64 prevConTag = prevConSetIt.getDataTag();
									CConceptDescriptor* conDes = conSetIt.getConceptDescriptor();
									CConceptDescriptor* prevConDes = prevConSetIt.getConceptDescriptor();
									if (conTag == prevConTag) {
										conSetIt.moveNext();
										prevConSetIt.moveNext();
									} else if (prevConTag < conTag) {
										// concept is missing, analyse dependencies whether it can be directly added
										CDependencyTrackPoint* prevConDepTrackPoint = prevConSetIt.getDependencyTrackPoint();
										cint64 remMaxBacktrackingCount = 15;
										if (areAllDependentFactsUnchanged(individualNode,nullptr,prevConDepTrackPoint,prevIndiNodeVec,remMaxBacktrackingCount,calcAlgContext)) {
											addConceptToIndividual(prevConDes->getConcept(),prevConDes->isNegated(),individualNode,prevConDepTrackPoint,false,false,calcAlgContext);
										}
										prevConSetIt.moveNext();
									} else if (conTag < prevConTag) {
										conSetIt.moveNext();
									}
								}

								while (prevConSetIt.hasNext()) {
									// concept is missing, analyse dependencies whether it can be directly added
									CConceptDescriptor* prevConDes = prevConSetIt.getConceptDescriptor();
									CDependencyTrackPoint* prevConDepTrackPoint = prevConSetIt.getDependencyTrackPoint();
									cint64 remMaxBacktrackingCount = 15;
									if (areAllDependentFactsUnchanged(individualNode,nullptr,prevConDepTrackPoint,prevIndiNodeVec,remMaxBacktrackingCount,calcAlgContext)) {
										addConceptToIndividual(prevConDes->getConcept(),prevConDes->isNegated(),individualNode,prevConDepTrackPoint,false,false,calcAlgContext);
									}
									prevConSetIt.moveNext();
								}
							}
						}



						searchingNodeSet->insert(individualNode->getIndividualNodeID());
						searchingNodeList->append(individualNode->getIndividualNodeID());

						while (!searchingNodeList->isEmpty()) {
							cint64 searchIndiNodeID = searchingNodeList->takeFirst();
							CIndividualProcessNode* searchIndiNode = prevIndiNodeVec->getData(searchIndiNodeID);

							if (searchIndiNode) {

								CIndividual* nominalIndi = searchIndiNode->getNominalIndividual();
								if (searchIndiNode->getIndividualNodeID() != individualNode->getIndividualNodeID()) {
									if (nominalIndi) {
										if (!indiNodeVec->getData(-nominalIndi->getIndividualID())) {
											if (!expList) {
												expList = incExpData->getIncrementalExpansionList(true);
											}
											expList->append(nominalIndi);
										}
									}
								}

								if (!nominalIndi && searchIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION) || searchIndiNodeID == individualNode->getIndividualNodeID()) {
									CSuccessorIterator succIt = searchIndiNode->getSuccessorIterator(); 
									while (succIt.hasNext()) {
										CIndividualLinkEdge* succLink = succIt.nextLink();
										cint64 succIndiID = succLink->getOppositeIndividualID(searchIndiNodeID);
										if (!searchingNodeSet->contains(succIndiID)) {
											searchingNodeSet->insert(succIndiID);
											searchingNodeList->append(succIndiID);
										}
									}
									CConnectionSuccessorSetIterator connIt = searchIndiNode->getConnectionSuccessorIterator();
									while (connIt.hasNext()) {
										cint64 connIndiID = connIt.next();
										if (!searchingNodeSet->contains(connIndiID)) {
											searchingNodeSet->insert(connIndiID);
											searchingNodeList->append(connIndiID);
										}
									}
									CIndividualMergingHash* mergeHash = searchIndiNode->getIndividualMergingHash(false);
									if (mergeHash) {
										for (CPROCESSHASH<cint64,CIndividualMergingHashData>::const_iterator it = mergeHash->constBegin(), itEnd = mergeHash->constEnd(); it != itEnd; ++it) {
											cint64 mergedIndiID = it.key();											
											if (it.value().isMergedWithIndividual() && !searchingNodeSet->contains(mergedIndiID)) {
												searchingNodeSet->insert(mergedIndiID);
												searchingNodeList->append(mergedIndiID);
											}
										}
									}
								}
							}
						}
						incExpData->setIncremetnalExpansionListInitialized(true);
						addIndividualToIncrementalExpansionQueue(individualNode,calcAlgContext);
						return true;
					}
					return false;
				}





				CIndividual* CCalculationTableauCompletionTaskHandleAlgorithm::getNextIncrementalExpansionIndividual(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (incExpData && incExpData->requiresFurtherIncrementalExpansion()) {
						incExpData = individualNode->getIncrementalExpansionData(true);	
						while (incExpData->requiresFurtherIncrementalExpansion()) {
							CIndividual* nextIndi = incExpData->takeNextIncrementalExpansionIndividual();
							CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
							if (!indiProcNodeVec->getData(-nextIndi->getIndividualID())) {
								return nextIndi;
							}
						}
					}
					return nullptr;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::incrementalNodeExpansion(CIndividualProcessNode* expandNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					CIndividual* expIndi = getNextIncrementalExpansionIndividual(expandNode,calcAlgContext);
					if (expIndi) {
						CIndividualProcessNode* expandedIndiNode = getUpToDateIndividual(-expIndi->getIndividualID(),calcAlgContext);
						addIndividualToIncrementalExpansionQueue(expandNode,calcAlgContext);
						return expandedIndiNode;
					}
					return nullptr;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::requiresIncrementalNodeExpansion(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (!incExpData->isPreviousCompletionGraphCompatible() && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
						return true;
					}
					return false;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::incrementalMergeWithPreviousNondeterministicCompletionGraph(CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNodeVector* indiNodeVec = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector();
					cint64 indiCount = indiNodeVec->getItemCount();
					cint64 indiStart = indiNodeVec->getItemMinIndex();

					CSatisfiableCalculationTask* prevDetCalcTask = mIncExpHandler->getPreviousDeterministicCompletionGraphTask(calcAlgContext);
					CSatisfiableCalculationTask* prevNondetCalcTask = mIncExpHandler->getPreviousNondeterministicCompletionGraphTask(calcAlgContext);

					if (prevDetCalcTask && prevNondetCalcTask && prevDetCalcTask != prevNondetCalcTask) {
						CProcessingDataBox* prevDetDataBox = prevDetCalcTask->getProcessingDataBox();
						CIndividualProcessNodeVector* prevDetIndiNodeVec = prevDetDataBox->getIndividualProcessNodeVector();
						cint64 prevDetIndiNodeCount = prevDetIndiNodeVec->getItemCount();

						CProcessingDataBox* prevNondetDataBox = prevNondetCalcTask->getProcessingDataBox();
						CIndividualProcessNodeVector* prevNondetIndiNodeVec = prevNondetDataBox->getIndividualProcessNodeVector();
						cint64 prevNondetIndiNodeCount = prevNondetIndiNodeVec->getItemCount();


						CPROCESSINGSET<cint64>* transformNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());


						CIndividualProcessNodeVector* mergedIndiNodeVec = CObjectParameterizingAllocator< CIndividualProcessNodeVector,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getProcessContext());
						mergedIndiNodeVec->referenceVector(indiNodeVec);
						calcAlgContext->getUsedProcessingDataBox()->setIndividualProcessNodeVector(mergedIndiNodeVec);

						for (cint64 i = indiStart; i < indiCount; ++i) {
							CIndividualProcessNode* indiNode = indiNodeVec->getData(i);
							CIndividualProcessNode* prevDetIndiNode = prevDetIndiNodeVec->getData(i);
							CIndividualProcessNode* prevNondetIndiNode = prevNondetIndiNodeVec->getData(i);
							if (!indiNode && prevNondetIndiNode) {
								mergedIndiNodeVec->setLocalData(i,prevNondetIndiNode);
							} else if (indiNode == prevDetIndiNode) {
								if (prevNondetIndiNode != prevDetIndiNode) {
									mergedIndiNodeVec->setLocalData(i,prevNondetIndiNode);
								}
							} else {
								if (!indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
									if (indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED) && !indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED)) {
										transformNodeSet->insert(i);
									}
								}
							}
						}

						for (CPROCESSINGSET<cint64>::const_iterator it = transformNodeSet->constBegin(), itEnd = transformNodeSet->constEnd(); it != itEnd; ++it) {
							cint64 transformNodeID(*it);
							CIndividualProcessNode* locIndiNode = getLocalizedIndividual(transformNodeID,calcAlgContext);
							CIndividualProcessNode* prevNondetIndiNode = prevNondetIndiNodeVec->getData(transformNodeID);
							locIndiNode->setReapplyConceptLabelSet(prevNondetIndiNode->getReapplyConceptLabelSet(false));

							CSuccessorIterator prevSuccIt = prevNondetIndiNode->getSuccessorIterator();
							while (prevSuccIt.hasNext()) {
								CIndividualLinkEdge* succLinkEdge = prevSuccIt.nextLink();
								cint64 succIndiID = succLinkEdge->getOppositeIndividualID(transformNodeID);
								CIndividualProcessNode* succIndiNode = getUpToDateIndividual(succIndiID,calcAlgContext);
								if (!succIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
									CIndividualProcessNode* locSuccIndiNode = getLocalizedIndividual(succIndiNode,false,calcAlgContext);
									CSuccessorRoleIterator succRoleIt = prevNondetIndiNode->getSuccessorRoleIterator(locSuccIndiNode);
									while (succRoleIt.hasNext()) {
										CIndividualLinkEdge* succLink = succRoleIt.next();
										if (!locSuccIndiNode->hasRoleSuccessorToIndividual(succLink->getLinkRole(),locIndiNode,true)) {
											CIndividualLinkEdge* newSuccLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getUsedProcessContext());
											newSuccLink->initIndividualLinkEdge(succLink);
											CReapplyQueueIterator reapplyIterator = installIndividualNodeRoleLinkReapplied(locIndiNode,locSuccIndiNode,newSuccLink,calcAlgContext);
											applyReapplyQueueConceptsRestricted(locIndiNode,&reapplyIterator,newSuccLink,calcAlgContext);
										}
									}
								}
							}

							CConnectionSuccessorSetIterator connIt = prevNondetIndiNode->getConnectionSuccessorIterator();
							if (connIt.hasNext()) {
								CConnectionSuccessorSet* connSet = locIndiNode->getConnectionSuccessorSet(false);
								CConnectionSuccessorSet* locConnSet = nullptr;
								while (connIt.hasNext()) {
									cint64 connID = connIt.next();
									if (!connSet || !connSet->hasConnectionSuccessor(connID)) {
										CIndividualProcessNode* connIndiNode = getUpToDateIndividual(connID,calcAlgContext);
										if (!connIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
											if (!locConnSet) {
												locConnSet = locIndiNode->getConnectionSuccessorSet(true);
											}
											locConnSet->insertConnectionSuccessor(connID);
										}
									}
								}
							}

							CDistinctHash* prevDistinctHash = prevNondetIndiNode->getDistinctHash(false);
							if (prevDistinctHash) {
								CDistinctHash* distinctHash = locIndiNode->getDistinctHash(false);
								CDistinctHash* locDistinctHash = nullptr;
								for (CDistinctHash::const_iterator it = distinctHash->constBegin(), itEnd = distinctHash->constEnd(); it != itEnd; ++it) {
									cint64 distinctIndiID(it.key());
									CDistinctEdge* distinctEdge(it.value());
									if (!distinctHash || distinctHash->isIndividualDistinct(distinctIndiID)) {
										CIndividualProcessNode* distinctIndiNode = getUpToDateIndividual(distinctIndiID,calcAlgContext);
										if (!distinctIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
											if (!locDistinctHash) {
												locDistinctHash = locIndiNode->getDistinctHash(true);
											}
											CDistinctEdge* newDistinctLink = CObjectParameterizingAllocator< CDistinctEdge,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getUsedProcessContext());
											newDistinctLink->initDistinctEdge(locIndiNode,distinctIndiNode,distinctEdge->getDependencyTrackPoint());
											locDistinctHash->insertDistinctIndividual(distinctIndiID,newDistinctLink);
										}
									}
								}
							}

							CIndividualMergingHash* prevIndiMergingHash = prevNondetIndiNode->getIndividualMergingHash(false);
							if (prevIndiMergingHash) {
								CIndividualMergingHash* indiMergingHash = locIndiNode->getIndividualMergingHash(false);
								CIndividualMergingHash* locIndiMergingHash = nullptr;
								for (CIndividualMergingHash::const_iterator it = indiMergingHash->constBegin(), itEnd = indiMergingHash->constEnd(); it != itEnd; ++it) {
									cint64 mergedIndiId(it.key());
									CIndividualMergingHashData prevMergingData = it.value();
									if (!indiMergingHash || indiMergingHash->contains(mergedIndiId)) {
										if (!locIndiMergingHash) {
											locIndiMergingHash = locIndiNode->getIndividualMergingHash(true);
										}
										CIndividualMergingHashData& locMergingData = (*locIndiMergingHash)[mergedIndiId];
										if (!prevMergingData.getReapplyQueue()->isEmpty()) {
											CCondensedReapplyQueueIterator reapplyIt = prevMergingData.getReapplyQueue()->getIterator(true, true);
											applyReapplyQueueConcepts(locIndiNode, &reapplyIt, calcAlgContext);
										}
										if (!locMergingData.isMergedWithIndividual()) {
											locMergingData.setMergedWithIndividual(prevMergingData.isMergedWithIndividual());
										}
										if (!locMergingData.getDependencyTrackPoint()) {
											CDependencyTrackPoint* depTrackPoint(it.value().getDependencyTrackPoint());
											locMergingData.setDependencyTrackPoint(prevMergingData.getDependencyTrackPoint());
										}
									}
								}
							}
						}
						return true;

					}
					return false;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::incrementalMergeWithPreviousDeterministicCompletionGraph(CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNodeVector* indiNodeVec = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector();
					cint64 indiMaxIdx = indiNodeVec->getItemMaxIndex();
					cint64 indiMinIdx = indiNodeVec->getItemMinIndex();

					CSatisfiableCalculationTask* prevCalcTask = mIncExpHandler->getPreviousDeterministicCompletionGraphTask(calcAlgContext);
					if (prevCalcTask) {
						CPROCESSINGSET<cint64>* nonCompatibleChangedNominalNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
						CPROCESSINGSET<cint64>* compatibleNominalNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
						CPROCESSINGSET<cint64>* redundantNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
						CPROCESSINGSET<cint64>* newNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());

						identifyCompatibilityChangedNominalIndividualNodes(nonCompatibleChangedNominalNodeSet,compatibleNominalNodeSet,redundantNodeSet,newNodeSet,calcAlgContext);

						CPROCESSINGSET<cint64>* pruningNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<cint64>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());



						CProcessingDataBox* prevDataBox = prevCalcTask->getProcessingDataBox();
						CIndividualProcessNodeVector* prevIndiNodeVec = prevDataBox->getIndividualProcessNodeVector();
						cint64 prevIndiNodeMaxIdx = prevIndiNodeVec->getItemMaxIndex();
						cint64 prevIndiNodeMinIdx = prevIndiNodeVec->getItemMinIndex();

						for (CPROCESSINGSET<cint64>::const_iterator it = redundantNodeSet->constBegin(), itEnd = redundantNodeSet->constEnd(); it != itEnd; ++it) {
							cint64 redundantNodeID(*it);
							CIndividualProcessNode* redundantNode = indiNodeVec->getData(redundantNodeID);
							if (redundantNode && redundantNode->getNominalIndividual()) {
								redundantNode = getLocalizedIndividual(redundantNode,false,calcAlgContext);
								pruneIncrementalRemovedSuccessors(redundantNode,compatibleNominalNodeSet,pruningNodeSet,calcAlgContext);
							}
						}

						CIndividualProcessNodeVector* mergedIndiNodeVec = CObjectParameterizingAllocator< CIndividualProcessNodeVector,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getProcessContext());
						mergedIndiNodeVec->referenceVector(prevIndiNodeVec);
						calcAlgContext->getUsedProcessingDataBox()->setIndividualProcessNodeVector(mergedIndiNodeVec);


						for (CPROCESSINGSET<cint64>::const_iterator it = nonCompatibleChangedNominalNodeSet->constBegin(), itEnd = nonCompatibleChangedNominalNodeSet->constEnd(); it != itEnd; ++it) {
							cint64 changedNominalID(*it);
							CIndividualProcessNode* prevChangedNode = mergedIndiNodeVec->getData(changedNominalID);
							if (prevChangedNode) {
								prevChangedNode = getLocalizedIndividual(prevChangedNode,false,calcAlgContext);
								pruneIncrementalRemovedSuccessors(prevChangedNode,compatibleNominalNodeSet,pruningNodeSet,calcAlgContext);
							}
						}

						for (CPROCESSINGSET<cint64>::const_iterator it = nonCompatibleChangedNominalNodeSet->constBegin(), itEnd = nonCompatibleChangedNominalNodeSet->constEnd(); it != itEnd; ++it) {
							cint64 changedNominalID(*it);
							CIndividualProcessNode* changedNode = indiNodeVec->getData(changedNominalID);
							mergedIndiNodeVec->setData(changedNominalID,changedNode);
						}

						for (CPROCESSINGSET<cint64>::const_iterator it = compatibleNominalNodeSet->constBegin(), itEnd = compatibleNominalNodeSet->constEnd(); it != itEnd; ++it) {
							cint64 compNominalID(*it);
							CIndividualProcessNode* newCompNode = indiNodeVec->getData(compNominalID);
							mergedIndiNodeVec->setData(compNominalID,newCompNode);

							// TODO: add nodes to cached completion graph checking queue?

							CIndividualProcessNode* prevCompIndiNode = prevIndiNodeVec->getData(compNominalID);
							if (prevCompIndiNode) {

								CIndividualProcessNode* locNewCompNode = getLocalizedIndividual(newCompNode,false,calcAlgContext);

								CSuccessorIterator prevSuccIt = prevCompIndiNode->getSuccessorIterator();
								while (prevSuccIt.hasNext()) {
									CIndividualLinkEdge* succLinkEdge = prevSuccIt.nextLink();
									CIndividualProcessNode* succIndiNode = getSuccessorIndividual(prevCompIndiNode,succLinkEdge,calcAlgContext);
									if (succIndiNode->isNominalIndividualNode() || succIndiNode->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
										cint64 succIndiID = succIndiNode->getIndividualNodeID();
										if (!compatibleNominalNodeSet->contains(succIndiID) && !nonCompatibleChangedNominalNodeSet->contains(succIndiID) && !pruningNodeSet->contains(succIndiID)) {
											CSuccessorRoleIterator succRoleIt = prevCompIndiNode->getSuccessorRoleIterator(succIndiNode);
											while (succRoleIt.hasNext()) {
												CIndividualLinkEdge* succLink = succRoleIt.next();

												CIndividualLinkEdge* newSuccLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getUsedProcessContext());
												newSuccLink->initIndividualLinkEdge(succLink);

												CReapplyQueueIterator reapplyIterator = installIndividualNodeRoleLinkReapplied(locNewCompNode,succIndiNode,newSuccLink,calcAlgContext);
												applyReapplyQueueConceptsRestricted(locNewCompNode,&reapplyIterator,newSuccLink,calcAlgContext);
											}
										}
									}
								}

								CConnectionSuccessorSetIterator conIt = prevCompIndiNode->getConnectionSuccessorIterator();
								while (conIt.hasNext()) {
									cint64 connNodeID = conIt.next();
									if (!compatibleNominalNodeSet->contains(connNodeID) && !nonCompatibleChangedNominalNodeSet->contains(connNodeID) && !pruningNodeSet->contains(connNodeID)) {
										locNewCompNode->getConnectionSuccessorSet(true)->insertConnectionSuccessor(connNodeID);
									}
								}

								CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
								CIndividualReactivationProcessingQueue* reactProcQueue = nullptr;
								if (mConfDelayCompletionGraphCachingReactivation) {
									reactProcQueue = processingDataBox->getLateIndividualReactivationProcessingQueue(true);
								} else {
									reactProcQueue = processingDataBox->getEarlyIndividualReactivationProcessingQueue(true);
								}
								reactProcQueue->insertReactivationIndiviudal(locNewCompNode,false);

							}
						}

						for (cint64 i = prevIndiNodeMinIdx; i >= indiMinIdx; --i) {
							CIndividualProcessNode* newIndiNode = indiNodeVec->getData(i);
							if (newIndiNode) {
								mergedIndiNodeVec->setData(i,newIndiNode);
							}
						}
						for (cint64 i = prevIndiNodeMaxIdx; i <= indiMaxIdx; ++i) {
							CIndividualProcessNode* newIndiNode = indiNodeVec->getData(i);
							if (newIndiNode) {
								mergedIndiNodeVec->setData(i,newIndiNode);
							}
						}


						return true;
					}
					return false;
				}











				void CCalculationTableauCompletionTaskHandleAlgorithm::pruneIncrementalRemovedSuccessors(CIndividualProcessNode*& indi, CPROCESSINGSET<cint64>* compatibleNominalNodeSet, CPROCESSINGSET<cint64>* pruningNodeSet, CCalculationAlgorithmContextBase* calcAlgContext) {

					CPROCESSINGLIST<CIndividualProcessNode*>* pruningNodeList = CObjectParameterizingAllocator< CPROCESSINGLIST<CIndividualProcessNode*>,CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
					pruningNodeList->append(indi);

					while (!pruningNodeList->isEmpty()) {
						CIndividualProcessNode* pruningNode = pruningNodeList->takeFirst();

						if (pruningNode != indi && !pruningNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
							pruningNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED);
							eliminiateBlockedIndividuals(pruningNode,calcAlgContext);
						}

						CConnectionSuccessorSet* connSuccSet = pruningNode->getConnectionSuccessorSet(false);
						if (connSuccSet) {
							if (connSuccSet->getConnectionSuccessorCount() > 0) {
								CConnectionSuccessorSetIterator conSuccIt = connSuccSet->getConnectionSuccessorIterator();
								while (conSuccIt.hasNext()) {
									cint64 connID = conSuccIt.next(true);
									if (!pruningNodeSet->contains(connID) && !compatibleNominalNodeSet->contains(connID)) {
										CIndividualProcessNode* nomIndi = getUpToDateIndividual(connID,calcAlgContext);
										if (!nomIndi->getNominalIndividual() && !nomIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
											pruningNodeSet->insert(connID);
											CIndividualProcessNode* locNomIndi = getLocalizedIndividual(nomIndi,false,calcAlgContext);
											pruningNodeList->append(locNomIndi);
										}
									}
								}
							}
						}


						CSuccessorIterator succIt = pruningNode->getSuccessorIterator();
						cint64 ancDepth = pruningNode->getIndividualAncestorDepth();
						while (succIt.hasNext()) {
							CIndividualLinkEdge* succLink = succIt.nextLink(true);
							CIndividualProcessNode* succIndi = getSuccessorIndividual(pruningNode,succLink,calcAlgContext);
							if (!succIndi->getNominalIndividual() && !succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
								cint64 succIndiID = succIndi->getIndividualNodeID();
								if (!pruningNodeSet->contains(succIndiID) && !compatibleNominalNodeSet->contains(succIndiID)) {
									pruningNodeSet->insert(succIndiID);
									CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
									pruningNodeList->append(locSuccIndi);
								}
							}
						}
					}
				}









				bool CCalculationTableauCompletionTaskHandleAlgorithm::identifyCompatibilityChangedNominalIndividualNodes(CPROCESSINGSET<cint64>* nonCompatibleChangedNominalNodeSet, CPROCESSINGSET<cint64>* compatibleNominalNodeSet, CPROCESSINGSET<cint64>* redundantNodeSet, CPROCESSINGSET<cint64>* newNodeSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNodeVector* indiNodeVec = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector();
					cint64 indiCount = indiNodeVec->getItemCount();
					cint64 indiStart = indiNodeVec->getItemMinIndex();
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indiNode = indiNodeVec->getData(i);
						if (indiNode) {
							CIndividualNodeIncrementalExpansionData* incExpData = indiNode->getIncrementalExpansionData(false);
							if (indiNode->getNominalIndividual()) {
								if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
									if (!incExpData->isPreviousCompletionGraphCompatible()) {
										nonCompatibleChangedNominalNodeSet->insert(i);
									} else {
										compatibleNominalNodeSet->insert(i);
									}
								}
							} else {
								if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
									newNodeSet->insert(i);
								}
							}
							if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged())) {
								redundantNodeSet->insert(i);
							}
						}
					}
					return true;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::checkCompatibilityUpdateDirectlyChangedPropagation(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool compatible = mIncExpHandler->isIndividualNodePreviousCompletionGraphCompatible(individualNode,calcAlgContext);
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (compatible) {
						clearPropagatedDirectlyChangedNeighbourConnection(individualNode,true,calcAlgContext);
					} else {
						if (incExpData->isDirectlyChanged()) {
							addIndividualToIncrementalExpansionQueue(individualNode,calcAlgContext);
						}
						if (!incExpData->isDirectlyChanged() && !incExpData->hasDirectlyChangedNeighbourConnection()) {
							CIndividualProcessNode* directlyChangedConnNode = searchDirectlyChangedNeighbourNodeConnection(individualNode,calcAlgContext);
							if (directlyChangedConnNode && establishDirectlyChangedNeighbourConnection(individualNode,directlyChangedConnNode,true,calcAlgContext)) {
								propagateDirectlyChangedNeighbourNodeConnection(individualNode,true,calcAlgContext);
							}
						}
					}
					return compatible;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::linkCreationDirectlyChangedNeighbourConnectionUpdate(CIndividualProcessNode* sourceIndi, CIndividualProcessNode* destIndi, bool queueIncrementalExpansion, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool updatedNeighbourConnection = false;
					if (establishDirectlyChangedNeighbourConnection(sourceIndi,destIndi,true,calcAlgContext)) {
						propagateDirectlyChangedNeighbourNodeConnection(sourceIndi,true,calcAlgContext);
						updatedNeighbourConnection = true;
					}
					if (establishDirectlyChangedNeighbourConnection(destIndi,sourceIndi,true,calcAlgContext)) {
						propagateDirectlyChangedNeighbourNodeConnection(destIndi,true,calcAlgContext);
						updatedNeighbourConnection = true;
					}
					return updatedNeighbourConnection;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::establishDirectlyChangedNeighbourConnection(CIndividualProcessNode* individualNode, CIndividualProcessNode* neighbourNodeCandidate, bool queueIncrementalExpansion, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (!incExpData || !incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged()) {
						CIndividualNodeIncrementalExpansionData* candIncExpData = neighbourNodeCandidate->getIncrementalExpansionData(false);
						if (candIncExpData && (candIncExpData->hasDirectlyChangedNeighbourConnection() || candIncExpData->isDirectlyChanged())) {
							CIndividualNodeIncrementalExpansionData* locIncExpData = individualNode->getIncrementalExpansionData(true);
							CIndividualProcessNode* locNeighbourNodeCandidate = getLocalizedIndividual(neighbourNodeCandidate,false,calcAlgContext);
							locIncExpData->setDirectlyChangedNeighbourConnectionNode(locNeighbourNodeCandidate);
							CIndividualNodeIncrementalExpansionData* locCandIncExpData = locNeighbourNodeCandidate->getIncrementalExpansionData(true);
							locCandIncExpData->addNeighbourPropagatedDirectlyChanged(individualNode);
							if (queueIncrementalExpansion && individualNode->getNominalIndividual()) {
								addIndividualToIncrementalExpansionQueue(individualNode,calcAlgContext);
							}
							return true;
						}
					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateDirectlyChangedNeighbourNodeConnection(CIndividualProcessNode* individualNode, bool queueIncrementalExpansion, CCalculationAlgorithmContextBase* calcAlgContext) {

					CPROCESSINGLIST<CIndividualProcessNode*> propNodeList(calcAlgContext->getUsedTaskProcessorContext());
					propNodeList.append(individualNode);
					bool propagatedDirectlyChanged = false;

					while (!propNodeList.isEmpty()) {
						CIndividualProcessNode* propIndiNode = propNodeList.takeFirst();

						CSuccessorIterator succIt(propIndiNode->getSuccessorIterator());
						while (succIt.hasNext()) {
							CIndividualLinkEdge* succLink = succIt.nextLink();
							CIndividualProcessNode* succIndi = getSuccessorIndividual(propIndiNode,succLink,calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = succIndi->getIncrementalExpansionData(false);
							if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
								CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
								if (establishDirectlyChangedNeighbourConnection(locSuccIndi,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
									propagatedDirectlyChanged = true;
									propNodeList.append(locSuccIndi);
								}
							}
						}
						CConnectionSuccessorSetIterator connIt(propIndiNode->getConnectionSuccessorIterator());
						while (connIt.hasNext()) {
							cint64 connID = connIt.next();
							CIndividualProcessNode* connIndiNode = getUpToDateIndividual(connID,calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = connIndiNode->getIncrementalExpansionData(false);
							if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
								CIndividualProcessNode* locConnIndiNode = getLocalizedIndividual(connIndiNode,false,calcAlgContext);
								if (establishDirectlyChangedNeighbourConnection(locConnIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
									propagatedDirectlyChanged = true;
									propNodeList.append(locConnIndiNode);
								}
							}
						}
						if (propIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
							for (CXLinker<CIndividualProcessNode*>* blockedNodeLinkerIt = propIndiNode->getBlockedIndividualsLinker(); blockedNodeLinkerIt; blockedNodeLinkerIt = blockedNodeLinkerIt->getNext()) {
								CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedNodeLinkerIt->getData(),calcAlgContext);
								CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
								if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
									CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,false,calcAlgContext);
									if (establishDirectlyChangedNeighbourConnection(locBlockedIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
										propagatedDirectlyChanged = true;
										propNodeList.append(locBlockedIndiNode);
									}
								}
							}
							for (CXLinker<CIndividualProcessNode*>* blockedNodeLinkerIt = propIndiNode->getProcessingBlockedIndividualsLinker(); blockedNodeLinkerIt; blockedNodeLinkerIt = blockedNodeLinkerIt->getNext()) {
								CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedNodeLinkerIt->getData(),calcAlgContext);
								CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
								if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
									CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,false,calcAlgContext);
									if (establishDirectlyChangedNeighbourConnection(locBlockedIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
										propagatedDirectlyChanged = true;
										propNodeList.append(locBlockedIndiNode);
									}
								}
							}
							CBlockingFollowSet* followSet = propIndiNode->getBlockingFollowSet(false);
							if (followSet) {
								for (CBlockingFollowSet::const_iterator it = followSet->constBegin(), itEnd = followSet->constEnd(); it != itEnd; ++it) {
									cint64 blockedIndiNodeID = *it;
									CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedIndiNodeID,calcAlgContext);
									CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
									if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
										CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,false,calcAlgContext);
										if (establishDirectlyChangedNeighbourConnection(locBlockedIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
											propagatedDirectlyChanged = true;
											propNodeList.append(locBlockedIndiNode);
										}
									}
								}
							}
							CIndividualProcessNode* blockerIndiNode = propIndiNode->getBlockerIndividualNode();
							if (blockerIndiNode) {
								blockerIndiNode = getUpToDateIndividual(blockerIndiNode,calcAlgContext);
								CIndividualNodeIncrementalExpansionData* incExpData = blockerIndiNode->getIncrementalExpansionData(false);
								if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
									CIndividualProcessNode* locBlockerIndiNode = getLocalizedIndividual(blockerIndiNode,false,calcAlgContext);
									if (establishDirectlyChangedNeighbourConnection(locBlockerIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
										propagatedDirectlyChanged = true;
										propNodeList.append(locBlockerIndiNode);
									}
								}
							}
							CIndividualProcessNode* followingIndiNode = propIndiNode->getFollowingIndividualNode();
							if (followingIndiNode) {
								followingIndiNode = getUpToDateIndividual(followingIndiNode,calcAlgContext);
								CIndividualNodeIncrementalExpansionData* incExpData = followingIndiNode->getIncrementalExpansionData(false);
								if (!incExpData || (!incExpData->hasDirectlyChangedNeighbourConnection() && !incExpData->isDirectlyChanged() && !incExpData->isPreviousCompletionGraphCompatible())) {
									CIndividualProcessNode* locFollowingIndiNode = getLocalizedIndividual(followingIndiNode,false,calcAlgContext);
									if (establishDirectlyChangedNeighbourConnection(locFollowingIndiNode,propIndiNode,queueIncrementalExpansion,calcAlgContext)) {
										propagatedDirectlyChanged = true;
										propNodeList.append(locFollowingIndiNode);
									}
								}
							}
						}
					}
					return propagatedDirectlyChanged;
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::searchDirectlyChangedNeighbourNodeConnection(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt(individualNode->getSuccessorIterator());
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink();
						CIndividualProcessNode* succIndi = getSuccessorIndividual(individualNode,succLink,calcAlgContext);
						CIndividualNodeIncrementalExpansionData* incExpData = succIndi->getIncrementalExpansionData(false);
						if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
							return succIndi;
						}
					}
					CConnectionSuccessorSetIterator connIt(individualNode->getConnectionSuccessorIterator());
					while (connIt.hasNext()) {
						cint64 connID = connIt.next();
						CIndividualProcessNode* connIndiNode = getUpToDateIndividual(connID,calcAlgContext);
						CIndividualNodeIncrementalExpansionData* incExpData = connIndiNode->getIncrementalExpansionData(false);
						if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
							return connIndiNode;
						}
					}
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
						for (CXLinker<CIndividualProcessNode*>* blockedNodeLinkerIt = individualNode->getBlockedIndividualsLinker(); blockedNodeLinkerIt; blockedNodeLinkerIt = blockedNodeLinkerIt->getNext()) {
							CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedNodeLinkerIt->getData(),calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
							if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
								return blockedIndiNode;
							}
						}
						for (CXLinker<CIndividualProcessNode*>* blockedNodeLinkerIt = individualNode->getProcessingBlockedIndividualsLinker(); blockedNodeLinkerIt; blockedNodeLinkerIt = blockedNodeLinkerIt->getNext()) {
							CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedNodeLinkerIt->getData(),calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
							if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
								return blockedIndiNode;
							}
						}
						CBlockingFollowSet* followSet = individualNode->getBlockingFollowSet(false);
						if (followSet) {
							for (CBlockingFollowSet::const_iterator it = followSet->constBegin(), itEnd = followSet->constEnd(); it != itEnd; ++it) {
								cint64 blockedIndiNodeID = *it;
								CIndividualProcessNode* blockedIndiNode = getUpToDateIndividual(blockedIndiNodeID,calcAlgContext);
								CIndividualNodeIncrementalExpansionData* incExpData = blockedIndiNode->getIncrementalExpansionData(false);
								if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
									return blockedIndiNode;
								}
							}
						}
						CIndividualProcessNode* blockerIndiNode = individualNode->getBlockerIndividualNode();
						if (blockerIndiNode) {
							blockerIndiNode = getUpToDateIndividual(blockerIndiNode,calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = blockerIndiNode->getIncrementalExpansionData(false);
							if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
								return blockerIndiNode;
							}
						}
						CIndividualProcessNode* followingIndiNode = individualNode->getFollowingIndividualNode();
						if (followingIndiNode) {
							followingIndiNode = getUpToDateIndividual(followingIndiNode,calcAlgContext);
							CIndividualNodeIncrementalExpansionData* incExpData = followingIndiNode->getIncrementalExpansionData(false);
							if (incExpData && (incExpData->hasDirectlyChangedNeighbourConnection() || incExpData->isDirectlyChanged())) {
								return followingIndiNode;
							}
						}
					}
					return nullptr;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::clearDirectlyChangedNeighbourConnection(CIndividualProcessNode* individualNode, bool queueCompatibilityChecks, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (incExpData && incExpData->hasDirectlyChangedNeighbourConnection()) {
						CIndividualNodeIncrementalExpansionData* locIncExpData = individualNode->getIncrementalExpansionData(true);
						locIncExpData->setDirectlyChangedNeighbourConnectionNode(nullptr);
						if (queueCompatibilityChecks && individualNode->isNominalIndividualNode()) {
							calcAlgContext->getUsedProcessingDataBox()->getIncrementalCompatibilityCheckingQueue(true)->insertProcessIndiviudal(individualNode);
						}
						clearPropagatedDirectlyChangedNeighbourConnection(individualNode,true,calcAlgContext);
						return true;
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::clearPropagatedDirectlyChangedNeighbourConnection(CIndividualProcessNode* individualNode, bool queueCompatibilityChecks, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool propCleared = false;
					CIndividualNodeIncrementalExpansionData* incExpData = individualNode->getIncrementalExpansionData(false);
					if (incExpData && incExpData->hasNeighbourPropagatedDirectlyChanged()) {
						CPROCESSINGLIST<CIndividualProcessNode*> clearPropNodeList(calcAlgContext->getUsedTaskProcessorContext());
						clearPropNodeList.append(individualNode);
						while (!clearPropNodeList.isEmpty()) {
							CIndividualProcessNode* clearPropIndiNode = clearPropNodeList.takeFirst();
							CIndividualNodeIncrementalExpansionData* clearIncExpData = clearPropIndiNode->getIncrementalExpansionData(false);

							CPROCESSLIST<CIndividualProcessNode*>* propIndiNodeList = clearIncExpData->getNeighbourPropagatedDirectlyChangedList(false);
							if (propIndiNodeList && !propIndiNodeList->isEmpty()) {
								clearIncExpData = clearPropIndiNode->getIncrementalExpansionData(true);
								propIndiNodeList = clearIncExpData->getNeighbourPropagatedDirectlyChangedList(true);

								for (CPROCESSLIST<CIndividualProcessNode*>::const_iterator it = propIndiNodeList->constBegin(), itEnd = propIndiNodeList->constEnd(); it != itEnd; ++it) {
									CIndividualProcessNode* propNode(*it);
									propNode = getUpToDateIndividual(propNode,calcAlgContext);
									CIndividualNodeIncrementalExpansionData* propIncExpData = propNode->getIncrementalExpansionData(false);
									if (propIncExpData && propIncExpData->hasDirectlyChangedNeighbourConnection()) {
										if (propIncExpData->getDirectlyChangedNeighbourConnectionNode()->getIndividualNodeID() == clearPropIndiNode->getIndividualNodeID()) {
											propCleared = true;
											propNode = getLocalizedIndividual(propNode,false,calcAlgContext);
											propIncExpData = propNode->getIncrementalExpansionData(true);
											propIncExpData->setDirectlyChangedNeighbourConnectionNode(nullptr);
											if (propIncExpData->hasNeighbourPropagatedDirectlyChanged()) {
												clearPropNodeList.append(propNode);
											}											
											if (queueCompatibilityChecks && individualNode->isNominalIndividualNode()) {
												calcAlgContext->getUsedProcessingDataBox()->getIncrementalCompatibilityCheckingQueue(true)->insertProcessIndiviudal(individualNode);
											}
										}
									}
								}
								clearIncExpData->clearNeighbourPropagatedDirectlyChangedList();
							}
						}
					}
					return false;
				}













































































































				bool CCalculationTableauCompletionTaskHandleAlgorithm::trackIndividualReferredDependence(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					return trackIndividualDependence(indiID,true,false,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::trackIndividualExtendedDependence(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					return trackIndividualDependence(indiID,false,true,calcAlgContext);
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::trackIndividualDependence(cint64 indiID, bool indiReferred, bool indiExtended, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (calcAlgContext->getUsedProcessingDataBox()->isIndividualDependenceTrackingRequired()) {
						CReferredIndividualTrackingVector* indiTrackVec = calcAlgContext->getUsedProcessingDataBox()->getReferredIndividualTrackingVector();
						if (!indiTrackVec) {
							CSatisfiableCalculationTask* satCalcTask = calcAlgContext->getSatisfiableCalculationTask();
							CSatisfiableTaskIndividualDependenceTrackingAdapter* indiDepTrackAdapter = satCalcTask->getSatisfiableTaskIndividualDependenceTrackingAdapter();
							if (indiDepTrackAdapter) {
								CIndividualDependenceTrackingMarker* indiDepTrackMarker = indiDepTrackAdapter->getIndividualDependenceTrackingMarker();
								if (indiDepTrackMarker) {
									indiDepTrackMarker->setIndividualDependenceTracked();
								}
								CIndividualDependenceTrackingObserver* indDepTrackObserver = indiDepTrackAdapter->getIndividualDependenceTrackingObserver();
								if (indDepTrackObserver) {
									CIndividualDependenceTracking* extendingIndiDepTrack = indDepTrackObserver->getExtendingIndividualDependenceTracking();
									CReferredIndividualTrackingVector* extendingRefIndiTrackVec = nullptr;
									if (extendingIndiDepTrack) {
										extendingRefIndiTrackVec = dynamic_cast<CReferredIndividualTrackingVector*>(extendingIndiDepTrack);
									}
									if (!extendingRefIndiTrackVec) {
										cint64 aboxIndiCount = calcAlgContext->getProcessingDataBox()->getOntology()->getABox()->getIndividualCount();
										cint64 trackIndiCount = aboxIndiCount;
										CConsistenceData* consData = calcAlgContext->getProcessingDataBox()->getOntology()->getConsistence()->getConsistenceModelData();
										if (consData) {
											CConsistenceTaskData* consTaskData = dynamic_cast<CConsistenceTaskData*>(consData);
											if (consTaskData) {
												CSatisfiableCalculationTask* cachedSatTask = consTaskData->getDeterministicSatisfiableTask();
												if (cachedSatTask) {
													trackIndiCount = qMax(trackIndiCount,cachedSatTask->getProcessingDataBox()->getIndividualProcessNodeVector()->getItemCount());
												}
											}
										}
										extendingRefIndiTrackVec = new CReferredIndividualTrackingVector();
										extendingRefIndiTrackVec->initReferredIndividualTrackingVector(trackIndiCount,aboxIndiCount);

										indiTrackVec = dynamic_cast<CReferredIndividualTrackingVector*>(indDepTrackObserver->installIndividualDependenceTracking(extendingRefIndiTrackVec));
									} else {
										indiTrackVec = extendingRefIndiTrackVec;
									}

									satCalcTask->getProcessingDataBox()->setReferredIndividualTrackingVector(indiTrackVec);
								}
							}
						}

						if (indiTrackVec) {

							//CIndividualProcessNode* indiNode = calcAlgContext->getUsedProcessingDataBox()->getIndividualProcessNodeVector()->getData(indiID);
							//if (indiNode->getNominalIndividual()) {
							//	if (!indiNode->getNominalIndividual()->getIndividualNominalConcept()) {
							//		bool bug = true;
							//	}
							//	if (CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker()) == "http://www.Department17.University0.edu/SystemsStaff12") {
							//		bool bug = true;
							//	}
							//}

							if (indiExtended) {
								indiTrackVec->setIndividualReferredAndExtended(-indiID);
							} else if (indiReferred) {
								indiTrackVec->setIndividualReferred(-indiID);
							}
							return true;
						}
					}
					return false;
				}






















































































				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptFromPredecessorDependent(CIndividualProcessNode*& individualNode, CConceptDescriptor* conDes, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 ancDepth = individualNode->getIndividualAncestorDepth();
					bool dependencyToAncestor = false;
					CDependencyNode* depNode = depTrackPoint->getDependencyNode();
					if (depTrackPoint->isPointingToIndependentDependencyNode()) {
						dependencyToAncestor = true;
					} else if (depNode->hasAppropriateIndividualNode()) {
						CIndividualProcessNode* appIndiNode = depNode->getAppropriateIndividualNode();
						cint64 appIndiAncDepth = appIndiNode->getIndividualAncestorDepth();
						if (appIndiAncDepth < ancDepth) {
							dependencyToAncestor = true;
						}
					} 
					return dependencyToAncestor;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::testCompletionGraphCachingAndBlocking(CCalculationAlgorithmContextBase* calcAlgContext, CIndividualProcessNode* exceptIndividualNode) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();
					cint64 indiCount = indiNodeVec->getItemCount();
					cint64 indiStart = indiNodeVec->getItemMinIndex();
					for (cint64 indiIdx = indiStart; indiIdx < indiCount; ++indiIdx) {
						CIndividualProcessNode* indiNode = getLocalizedIndividual(indiIdx,calcAlgContext);
						if (indiNode && indiNode != exceptIndividualNode) {
							CConceptProcessingQueue* conProQue = indiNode->getConceptProcessingQueue(false);
							if (conProQue) {
								if (!conProQue->isEmpty()) {
									if (!indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFINDIRECTBLOCKED | CIndividualProcessNode::PRFPURGEDBLOCKED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFDIRECTBLOCKED) ) {
										if (!indiNode->isImmediatelyProcessingQueued() && !indiNode->isBlockedReactivationProcessingQueued() && !indiNode->isDeterministicExpandingProcessingQueued() && !indiNode->isRegularDepthProcessingQueued() && !indiNode->isProcessingQueued()) {
											mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
											QFile file(QString("caching-error.txt"));
											if (file.open(QIODevice::WriteOnly)) {
												file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
												file.close();
											}
											bool bug = true;
										}
									}  
										
									if (indiNode->getIndividualNodeID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID() && indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED)) {
										if (!indiNode->isImmediatelyProcessingQueued() && !indiNode->isBlockedReactivationProcessingQueued() && !indiNode->isDeterministicExpandingProcessingQueued() && !indiNode->isRegularDepthProcessingQueued() && !indiNode->isProcessingQueued() && !calcAlgContext->getProcessingDataBox()->getEarlyIndividualReactivationProcessingQueue(false)->hasQueuedIndividual(indiNode) && !calcAlgContext->getProcessingDataBox()->getLateIndividualReactivationProcessingQueue(false)->hasQueuedIndividual(indiNode)) {
											mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
											QFile file(QString("caching-error.txt"));
											if (file.open(QIODevice::WriteOnly)) {
												file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
												file.close();
											}
											bool bug = true;
										}
									}
								}
							}
							if (indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
								CIndividualProcessNode* ancNode = getAncestorIndividual(indiNode,calcAlgContext);
								if (!ancNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED | CIndividualProcessNode::PRFSATISFIABLECACHED)) {
									mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
									bool bug = true;
								}
							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::analyzeABoxCompressionPossibilities(CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* dataBox = calcAlgContext->getProcessingDataBox();
					CIndividualProcessNodeVector* indiProVec = dataBox->getIndividualProcessNodeVector();

					QHash<cint64,cint64> signatureCountHash;
					QHash<cint64,cint64> signatureLabelSizeHash;
					QHash<cint64,bool> signatureNonDetHash;
					QHash<cint64,cint64> signatureFirstIndiNodeHash;

					cint64 indiCount = indiProVec->getItemCount();
					cint64 indiStart = indiProVec->getItemMinIndex();
					cint64 nonDetCount = 0;
					for (cint64 indiID = indiStart; indiID < indiCount; ++indiID) {
						CIndividualProcessNode* indiNode = indiProVec->getData(indiID);
						if (indiNode->isNominalIndividualNode()) {
							CIndividual* indiNominal = indiNode->getNominalIndividual();
							CConcept* nominalConcept = indiNominal->getIndividualNominalConcept();
							CConceptSetSignature conSetSignature;
							bool nonDet = false;
							CReapplyConceptLabelSet* labelSet = indiNode->getReapplyConceptLabelSet(false);
							if (labelSet) {
								for (CConceptDescriptor* conDesIt = labelSet->getAddingSortedConceptDescriptionLinker(); conDesIt; conDesIt = conDesIt->getNextConceptDesciptor()) {
									CConcept* concept = conDesIt->getConcept();
									bool conNegation = conDesIt->isNegated();
									if (conDesIt->getDependencyTrackPoint()->getBranchingTag() > 0) {
										nonDet = true;
									}
									if (concept != nominalConcept) {
										conSetSignature.addConceptSignature(concept,conNegation);
									}
								}
								cint64 signature = conSetSignature.getSignatureValue();
								cint64& sigCount = signatureCountHash[signature];
								++sigCount;								
								if (sigCount <= 1) {
									signatureLabelSizeHash[signature] = labelSet->getConceptCount();
									signatureNonDetHash[signature] = nonDet;
									if (nonDet) {
										++nonDetCount;
									}
									signatureFirstIndiNodeHash[signature] = indiNode->getIndividualNodeID();
								}
							}
						}
					}

					cout<<"\nNumber of signatures: "<<signatureCountHash.size()<<"\n";
					for (QHash<cint64,cint64>::const_iterator it = signatureCountHash.constBegin(), itEnd = signatureCountHash.constEnd(); it != itEnd; ++it) {
						cint64 signature = it.key();
						cint64 sigCount = it.value();
						bool nonDet = signatureNonDetHash[signature];
						cint64 labelSize = signatureLabelSizeHash[signature];
						cout<<"Count: "<<sigCount<<" \tSize: "<<labelSize<<" \tSignature: "<<signature;
						if (nonDet) {
							cout<<" (n)";
						} else {
							cout<<" (d)";
						} 
						cout<<"\t IndiID: "<<signatureFirstIndiNodeHash[signature]<<"\n";
						cout<<"\n";
					}
					signatureCountHash.clear();
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::analyzeBranchingMemoryWasting(CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* dataBox = calcAlgContext->getProcessingDataBox();
					CIndividualProcessNodeVector* indiProVec = dataBox->getIndividualProcessNodeVector();

					cint64 allocatedMemory = 0;
					cint64 usedMemory = 0;
					cint64 wastedMemory = 0;
					CSatisfiableCalculationTask* satTask = calcAlgContext->getSatisfiableCalculationTask();
					while (satTask) {
						CMemoryPool* memoryPool = satTask->getMemoryPools();
						while (memoryPool) {
							allocatedMemory += memoryPool->getMemoryBlockSize();

							char* memBlockEnd = memoryPool->getMemoryBlockEnd();
							char* memBlockPointer = memoryPool->getMemoryBlockPointer();
							char* memBlockBegin = memoryPool->getMemoryBlockData();

							usedMemory += (memBlockPointer - memBlockBegin);
							wastedMemory += (memBlockEnd - memBlockPointer);
							
							memoryPool = memoryPool->getNext();
						}
						satTask = (CSatisfiableCalculationTask*)satTask->getParentTask();
					}

					cout << "\nTasks memory consumption : " << allocatedMemory << " Bytes, used " << usedMemory << " Bytes, wasted " << wastedMemory << " Bytes\r\n";

				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeValidBlocker(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (individualNode->isNominalIndividualNode()) {
						return false;
					}
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION)) {
						return false;
					}

					if (calcAlgContext->hasCompletionGraphCachedIndividualNodes() && !individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) && 
							individualNode->getIndividualNodeID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
						return false;
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeCompletionGraphCached(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					detectIndividualNodeCompletionGraphCached(individualNode,calcAlgContext);
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeBackendCacheSynchronizationProcessingBlocked(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool wasNeigbourExpansionBlocked = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED);
					detectIndividualNodeBackendCacheSynchronized(individualNode,calcAlgContext);
					if (wasNeigbourExpansionBlocked) {
						if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {
							if (individualNode->getReverseAssertionRoleLinker() || individualNode->getAssertionRoleLinker() || individualNode->getAdditionalRoleAssertionsLinker()) {
								calcAlgContext->getProcessingDataBox()->getRoleAssertionExpansionProcessingQueue(true)->insertIndiviudalProcessNode(individualNode);
							}
						}
					}
					return individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeBackendCacheSynchronized(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool synchronized = false;
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {

						if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED)) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED);

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND)) {
								if (!testIndividualNodeBackendCacheConceptsSynchronization(individualNode,calcAlgContext)) {
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND);
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
								}
							}

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {
								if (testIndividualNodeBackendCacheSameMergedBlockingCritical(individualNode, calcAlgContext)) {
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED);
								}
							}

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {
								if (testIndividualNodeBackendCacheNeighbourExpansionBlockingCritical(individualNode, calcAlgContext)) {
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED);
								}
							}

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
								if (testIndividualNodeBackendCacheExpansionBlockingCriticalCardinality(individualNode, calcAlgContext)) {
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED);
								}
							}

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
								if (testIndividualNodeBackendCacheNominalIndirectConnectionBlockingCritical(individualNode, calcAlgContext)) {
									individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED);
								}
							}

							//TODO: use same condition as indirectly connected individual integration check
							if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
								if (individualNode->isCachingLossNodeReactivationInstalled()) {
									checkIndividualNodesReactivationDueToNominalCachingLoss(individualNode,calcAlgContext);
								}
							}

						}
					}
					synchronized = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND);
					return synchronized;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::clearCompletionGraphCaching(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					trackIndividualExtendedDependence(individualNode->getIndividualNodeID(), calcAlgContext);

					if (mConfCollectCachingUpdatedBlockableIndiNodes && individualNode->isBlockableIndividual()) {
						CXLinker<CIndividualProcessNode*>* updatedCachedIndiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						updatedCachedIndiNodeLinker->initLinker(individualNode);
						calcAlgContext->getUsedProcessingDataBox()->addBlockableIndividualNodeUpdatedLinker(updatedCachedIndiNodeLinker);
					}

					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
						individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED);
						reapplySatisfiableCachedAbsorbedDisjunctionConcepts(individualNode, calcAlgContext);
						reapplySatisfiableCachedAbsorbedGeneratingConcepts(individualNode, calcAlgContext);
					}
					individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED);

					if (individualNode->isCachingLossNodeReactivationInstalled()) {
						checkIndividualNodesReactivationDueToNominalCachingLoss(individualNode, calcAlgContext);
					}


					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CIndividualReactivationProcessingQueue* reactProcQueue = nullptr;
					if (mConfDelayCompletionGraphCachingReactivation) {
						reactProcQueue = processingDataBox->getLateIndividualReactivationProcessingQueue(true);
					} else {
						reactProcQueue = processingDataBox->getEarlyIndividualReactivationProcessingQueue(true);
					}
					bool reactivatedIndis = mCompGraphCacheHandler->getReactivationIndividuals(individualNode, reactProcQueue, calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeCompletionGraphCached(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool indiNodeCompGraphCached = false;
					if (mCompGraphCacheHandler && mConfCompletionGraphCaching) {
						if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) && individualNode->getIndividualNodeID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
							individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHEDNODELOCATED);

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED)) {
								individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED);
							}

							if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID | CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
								bool conceptSetExtended = false;
								indiNodeCompGraphCached = mCompGraphCacheHandler->isIndividualNodeCompletionGraphConsistenceBlocked(individualNode,conceptSetExtended,calcAlgContext);
								if (conceptSetExtended) {
									individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHEDNODEEXTENDED);
								}
							}
							if (!indiNodeCompGraphCached) {

								clearCompletionGraphCaching(individualNode, calcAlgContext);

							} else {
								individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED);
							}
						}
					}
					return indiNodeCompGraphCached;
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::commitCacheMessages(CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableExpanderCacheHandler* satExpHandler = calcAlgContext->getUsedSatisfiableExpanderCacheHandler();
					if (satExpHandler) {
						satExpHandler->commitCacheMessages(calcAlgContext);
					}
					CSaturationNodeExpansionCacheHandler* satNodeExpHandler = calcAlgContext->getUsedSaturationNodeExpansionCacheHandler();
					if (satNodeExpHandler) {
						satNodeExpHandler->commitCacheMessages(calcAlgContext);
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeUnsatisfiableCached(CIndividualProcessNode* individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mConfTestOccurUnsatCached) {
						cint64 conSetSize = 0;
						if (mLastUnsatCacheTestedIndiNode != individualNode && (conSetSize = individualNode->getReapplyConceptLabelSet(false)->getConceptCount()) != mLastUnsatCacheTestedIndiNodeConceptSetSize) {
							CUnsatisfiableCacheHandler* unsatCacheHandler = calcAlgContext->getUsedUnsatisfiableCacheHandler();
							CClashedDependencyDescriptor* clashDescriptors = nullptr;

							if (unsatCacheHandler) {
								KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(mUnsatCacheRetrieval.start());
								bool unsatCached = unsatCacheHandler->isIndividualNodeUnsatisfiableCached(individualNode,clashDescriptors,calcAlgContext);
								KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(
									cint64 timeElapsed = mUnsatCacheRetrieval.elapsed();
									STATINCM(TIMEUNSATCACHERETRIVAL,timeElapsed,calcAlgContext);
								);

								if (unsatCached) {
									if (!mConfUnsatCachingUseNodeSignatureSet || mUnsatCachingSignatureSet.contains(individualNode->getReapplyConceptLabelSet(false)->getConceptSignatureValue())) {
										if (mConfUnsatCachingUseFullNodeDependency) {
											clashDescriptors = createClashedIndividualNodeDescriptor(nullptr,individualNode,calcAlgContext);
										}
										STATINC(UNSATCACHEUSEDCOUNT,calcAlgContext);
										throw CCalculationClashProcessingException(clashDescriptors);
									}
								}
							}
							mLastUnsatCacheTestedIndiNode = individualNode;
							mLastUnsatCacheTestedIndiNodeConceptSetSize = conSetSize;
						}
					}
				}


				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createClashedIndividualNodeDescriptor(CClashedDependencyDescriptor* prevClashes, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = prevClashes;
					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* conDesIt = conSet->getAddingSortedConceptDescriptionLinker();
					while (conDesIt) {
						CConceptDescriptor* conDes = conDesIt;
						clashDes = createClashedConceptDescriptor(clashDes,processIndi,conDes,conDes->getDependencyTrackPoint(),calcAlgContext);
						conDesIt = conDesIt->getNext();
					}
					return clashDes;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::testProblematicConceptSet(CCalculationAlgorithmContextBase* calcAlgContext) {
					if (true) {
						CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();
						cint64 indiCount = indiNodeVec->getItemCount();
						cint64 indiIdx = 0;
						for (; indiIdx < indiCount; ++indiIdx) {
							CIndividualProcessNode* indiNode = getUpToDateIndividual(indiIdx,calcAlgContext);
							if (indiNode) {
								if (!indiNode->isNominalIndividualNode()) {
									if (!indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
										if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
											indiNode = getLocalizedIndividual(indiNode,false,calcAlgContext);


											if (true) {
												bool base1Con = false;
												bool base2Con = false;
												CConceptDescriptor* conDes = indiNode->getReapplyConceptLabelSet(false)->getAddingSortedConceptDescriptionLinker();
												for (CConceptDescriptor* conDesIt = conDes; conDesIt; conDesIt = conDesIt->getNext()) {
													if (!conDesIt->isNegated() && CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://www.w3.org/TR/2003/CR-owl-guide-20030818/food#SweetFruitCourse") {
														base1Con = true;
													}
													if (!conDesIt->isNegated() && CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://www.w3.org/TR/2003/CR-owl-guide-20030818/food#FruitCourse") {
														base2Con = true;
													}
												}
												if (!base2Con && base1Con) {
													mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
													QFile file(QString("caching-error.txt"));
													if (file.open(QIODevice::WriteOnly)) {
														file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
														file.close();
													}
													bool bug = true;
												}
											}


											//QStringList conSetList = generateExtendedDebugConceptSetStringList(indiNode->getReapplyConceptLabelSet(false),nullptr,nullptr,calcAlgContext);
											//debugTestCriticalConceptSet(conSetList,calcAlgContext);

										}
									}
								}
							}
						}
					}
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::analyseBranchingStatistics(CCalculationAlgorithmContextBase* calcAlgContext) {
					CBranchTreeNode* branchTreeNode = calcAlgContext->getBranchTreeNode();
					while (mConfBranchingStatisticsAnalysing && branchTreeNode) {

						CNonDeterministicDependencyTrackPoint* nonDetDepTrackPoint = branchTreeNode->getDependencyTrackPoint();
						if (nonDetDepTrackPoint) {
							CDependencyNode* dependencyNode = nonDetDepTrackPoint->getDependencyNode();
							if (dependencyNode) {
								if (dependencyNode->getDependencyType() == CDependencyNode::DNTORDEPENDENCY) {
									CORDependencyNode* orDependencyNode = (CORDependencyNode*)dependencyNode;
									CConceptDescriptor* conDes = orDependencyNode->getConceptDescriptor();
									CConcept* orConcept = conDes->getConcept();
									CConceptProcessData* conProData = (CConceptProcessData*)orConcept->getConceptData();
									if (conProData) {
										CDisjunctionBranchingStatistics* disjunctionBranchingStatistics = (CDisjunctionBranchingStatistics*)conProData->getBranchingStatistics();
										if (disjunctionBranchingStatistics) {
											disjunctionBranchingStatistics->incExpandedCount();
											disjunctionBranchingStatistics->incSatisfiableOccurrenceCount();
										}
									}
									CORDisjunctDependencyTrackPoint* orDepTrackPoint = (CORDisjunctDependencyTrackPoint*)nonDetDepTrackPoint;
									CDisjunctBranchingStatistics* disjunctBranchStats = orDepTrackPoint->getDisjunctBranchingStatistics();
									if (disjunctBranchStats) {
										disjunctBranchStats->incExpandedCount();
										disjunctBranchStats->incSatisfiableOccurrenceCount();
									}
								}
							}
						}

						if (branchTreeNode != branchTreeNode->getRootNode()) {
							branchTreeNode = branchTreeNode->getParentNode();
						} else {
							branchTreeNode = nullptr;
						}
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::cacheSatisfiableIndividualNodes(CCalculationAlgorithmContextBase* calcAlgContext) {
					bool nodeCached = false;
					CSatisfiableExpanderCacheHandler* satisfiableExpHandler = calcAlgContext->getUsedSatisfiableExpanderCacheHandler();
					CSaturationNodeExpansionCacheHandler* saturationExpHandler = calcAlgContext->getUsedSaturationNodeExpansionCacheHandler();
					if (mConfSatExpCacheWriting && satisfiableExpHandler || mConfSaturationSatisfiabilitiyExpansionCacheWriting && saturationExpHandler) {
						CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();
						cint64 indiMax = indiNodeVec->getItemMaxIndex() + 1;
						cint64 indiIdx = 1;
						indiIdx = qMax(processingDataBox->getMaxIncrementalPreviousCompletionGraphNodeID(),indiIdx);

						if (mConfCollectCachingUpdatedBlockableIndiNodes) {
							
							for (CXLinker<CIndividualProcessNode*>* updatedCachedIndiNodeLinker = processingDataBox->getBlockableIndividualNodeUpdatedLinker(); updatedCachedIndiNodeLinker; updatedCachedIndiNodeLinker = updatedCachedIndiNodeLinker->getNext()) {
								CIndividualProcessNode* indiNode = updatedCachedIndiNodeLinker->getData();
								if (indiNode && indiNode->getIndividualNodeID() >= 0) {
									indiNode = getUpToDateIndividual(indiIdx,calcAlgContext);
									if (indiNode && !indiNode->isNominalIndividualNode()) {
										if (mConfSatExpCacheWriting && satisfiableExpHandler && !indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
											if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
												indiNode = getLocalizedIndividual(indiNode,false,calcAlgContext);
												nodeCached |= satisfiableExpHandler->cacheIndividualNodeSatisfiable(indiNode,calcAlgContext);
											}
										}



										if (mConfSaturationSatisfiabilitiyExpansionCacheWriting && saturationExpHandler && !indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNEWNOMINALCONNECTION | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
											if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
												nodeCached |= saturationExpHandler->tryNodeSatisfiableCaching(indiNode,calcAlgContext);
											}
										}
									}
								}

							}
							indiIdx = qMax(calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()+1,indiIdx);
						}

						for (; indiIdx < indiMax; ++indiIdx) {
							CIndividualProcessNode* indiNode = getUpToDateIndividual(indiIdx,calcAlgContext);
							if (indiNode) {
								if (!indiNode->isNominalIndividualNode()) {
									if (mConfSatExpCacheWriting && satisfiableExpHandler && !indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
										if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
											indiNode = getLocalizedIndividual(indiNode,false,calcAlgContext);


											//CConceptProcessingQueue* conProQue = indiNode->getConceptProcessingQueue(false);
											//if (conProQue) {
											//	if (!conProQue->isEmpty()) {
											//		mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
											//		QFile file(QString("caching-error.txt"));
											//		if (file.open(QIODevice::WriteOnly)) {
											//			file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
											//			file.close();
											//		}
											//		bool bug = true;
											//	}
											//}
											 

											//CConceptDescriptor* conDes = indiNode->getReapplyConceptLabelSet(false)->getAddingSortedConceptDescriptionLinker();
											//bool amountSubstanceFound = false;
											//for (CConceptDescriptor* conDesIt = conDes; conDesIt; conDesIt = conDesIt->getNext()) {
											//	CConcept* concept = conDesIt->getConcept();
											//	if (concept->getOperatorCode() == CCIMPLALL) {
											//		if (CIRIName::getRecentIRIName(concept->getRole()->getPropertyNameLinker()) == "http://purl.org/biotop/biotop.owl#granularPartOf") {
											//			CConcept* orCocnept = concept->getOperandList()->getData();
											//			if (orCocnept->getOperatorCode() == CCOR) {
											//				for (CSortedNegLinker<CConcept*>* opLinker = orCocnept->getOperandList(); opLinker; opLinker = opLinker->getNext()) {
											//					if (opLinker->getData()->getOperatorCode() == CCSUB && CIRIName::getRecentIRIName(opLinker->getData()->getClassNameLinker()) == "http://purl.org/imbi/dco/dco#AmountOfSubstance") {
											//						amountSubstanceFound = true;
											//					}
											//				}
											//			}
											//		}
											//	}
											//}
											//if (amountSubstanceFound) {
											//	bool base1Con = false;
											//	bool base2Con = false;
											//	CConceptDescriptor* conDes = indiNode->getReapplyConceptLabelSet(false)->getAddingSortedConceptDescriptionLinker();
											//	for (CConceptDescriptor* conDesIt = conDes; conDesIt; conDesIt = conDesIt->getNext()) {
											//		if (!conDesIt->isNegated() && CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://purl.org/biotop/biotop.owl#AmountOfPureSubstance") {
											//			base1Con = true;
											//		}
											//		if (!conDesIt->isNegated() && CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://purl.org/imbi/dco/dco#AmountOfSubstance") {
											//			base2Con = true;
											//		}
											//	}
											//	if (!base2Con && base1Con) {
											//		mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
											//		QFile file(QString("caching-error.txt"));
											//		if (file.open(QIODevice::WriteOnly)) {
											//			file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
											//			file.close();
											//		}
											//		bool bug = true;
											//	}
											//}


											//QStringList conSetList = generateExtendedDebugConceptSetStringList(indiNode->getReapplyConceptLabelSet(false),nullptr,nullptr,calcAlgContext);
											//debugTestCriticalConceptSet(conSetList,calcAlgContext);

											nodeCached |= satisfiableExpHandler->cacheIndividualNodeSatisfiable(indiNode,calcAlgContext);
										}
									}



									if (mConfSaturationSatisfiabilitiyExpansionCacheWriting && saturationExpHandler && !indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNEWNOMINALCONNECTION | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
										if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
											nodeCached |= saturationExpHandler->tryNodeSatisfiableCaching(indiNode,calcAlgContext);
										}
									}
								}
							}
						}
					}
					return nodeCached;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::debugTestCriticalConceptSet(QStringList& conSetList, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (conSetList.count() == 67) {
						bool containAll = true;
						QSet<QString> testConceptSetStringSet;
						for (QStringList::const_iterator it = conSetList.constBegin(), itEnd = conSetList.constEnd(); containAll && it != itEnd; ++it) {
							const QString& conString = *it;
							QString testString = conString;
							testString = testString.remove("^");
							testString = testString.remove("0");
							testString = testString.remove("1");
							testString = testString.remove("2");
							testString = testString.remove("3");
							testString = testString.remove("4");
							testString = testString.remove("5");
							testString = testString.remove("6");
							testString = testString.remove("7");
							testString = testString.remove("8");
							testString = testString.remove("9");
							testString = testString.trimmed();
							testConceptSetStringSet.insert(testString);
						}

						if (testConceptSetStringSet.count() >= mCriticalConceptSetStringSet.count()) {
							foreach (const QString& testString, mCriticalConceptSetStringSet) {
								if (!testConceptSetStringSet.contains(testString)) {
									containAll = false;
								}
							}
						} else {
							containAll = false;
						}

						if (containAll && !mFoundCriticalConceptSet) {
							mFoundCriticalConceptSet = true;
							mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
							mFoundCriticalConceptSet = false;
							bool debug = true;
						}
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::testAllSuccessorsProcessedAndWriteSatisfiableCache(CIndividualProcessNode* indiNode, CPROCESSINGSET<CIndividualProcessNode*>* processedNodeSet, CSatisfiableExpanderCacheHandler* satExpHandler, CCalculationAlgorithmContextBase* calcAlgContext) {

					if (!indiNode->isNominalIndividualNode() && !indiNode->hasBackwardDependencyToAncestorIndividualNode()) {
						if (!indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
							if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
								CConceptProcessingQueue* conProQue = indiNode->getConceptProcessingQueue(false);
								if (!conProQue || conProQue->isEmpty()) {

									if (!processedNodeSet->contains(indiNode)) {
										processedNodeSet->insert(indiNode);

										CIndividualProcessNode* ancIndi = getAncestorIndividual(indiNode,calcAlgContext);
										CSuccessorIterator succIt(indiNode->getSuccessorIterator());
										while (succIt.hasNext()) {
											CIndividualLinkEdge* succLink = succIt.nextLink();
											CIndividualProcessNode* succIndi = getSuccessorIndividual(indiNode,succLink,calcAlgContext);
											if (!ancIndi || succIndi->getIndividualNodeID() != ancIndi->getIndividualNodeID()) {
												if (!testAllSuccessorsProcessedAndWriteSatisfiableCache(succIndi,processedNodeSet,satExpHandler,calcAlgContext)) {
													return false;
												}
											}
										}

										indiNode = getLocalizedIndividual(indiNode,false,calcAlgContext);
										satExpHandler->cacheIndividualNodeSatisfiable(indiNode,calcAlgContext);

										return true;
									}
								}
							}
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::writeSatisfiableCachedIndividualNodesOfUnsatisfiableBranch(CCalculationAlgorithmContextBase* calcAlgContext) {
					bool nodeCached = false;
					CSatisfiableExpanderCacheHandler* satExpHandler = calcAlgContext->getUsedSatisfiableExpanderCacheHandler();
					if (mConfUnsatBranchSatisfiableCaching && mConfSatExpCacheWriting && satExpHandler) {
						CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualProcessNodeVector* indiNodeVec = processingDataBox->getIndividualProcessNodeVector();

						CPROCESSINGSET<CIndividualProcessNode*>* processedNodeSet = CObjectParameterizingAllocator< CPROCESSINGSET<CIndividualProcessNode*>,CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(),calcAlgContext->getUsedTaskProcessorContext());
						cint64 indiCount = indiNodeVec->getItemCount();
						cint64 indiStart = indiNodeVec->getItemMinIndex();
						for (cint64 indiIdx = indiStart; indiIdx < indiCount; ++indiIdx) {
							CIndividualProcessNode* indiNode = getUpToDateIndividual(indiIdx,calcAlgContext);
							if (indiNode) {
								if (!indiNode->isNominalIndividualNode()) {
									if (!indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
										if (!calcAlgContext->hasCompletionGraphCachedIndividualNodes() || indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) || indiNode->getIndividualNodeID() > calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
											CConceptProcessingQueue* conProQue = indiNode->getConceptProcessingQueue(false);
											if (!conProQue || conProQue->isEmpty()) {
												// test whether all successor nodes are already processed
												nodeCached |= testAllSuccessorsProcessedAndWriteSatisfiableCache(indiNode,processedNodeSet,satExpHandler,calcAlgContext);
											}
										}
									}
								}
							}
						}
					}
					return nodeCached;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::isSaturationCachedProcessingBlocked(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool processingBlocked = false;
					bool saturationCached = detectIndividualNodeSaturationCached(individualNode,calcAlgContext);
					if (saturationCached) {
						// block processing only for successors of saturation cached nodes
						processingBlocked = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
					}
					return processingBlocked;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeSaturationCached(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED) && !individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATURATIONBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						return true;
					}

					bool prevSatCached = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
					bool prevSatSuccCreationBlocked = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED);


					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
						if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHEDABOLISHED)) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHEDABOLISHED);
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
						} else {
							return true;
						}
					}
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATURATIONBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATURATIONBLOCKINGCACHEDDUEDIRECTMODIFIED);
					}
					bool stillSaturationCached = false;
					if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDINVALIDATED)) {

						CSaturationNodeExpansionCacheHandler* satNodeExpCacheHandler = calcAlgContext->getSaturationNodeExpansionCacheHandler();
						if (!stillSaturationCached && satNodeExpCacheHandler && mConfSaturationExpansionCacheReading) {
							CSaturationNodeAssociatedConceptExpansion* expansion = nullptr;

							if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDRETESTDUETOMODIFICATION)) {
								individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDRETESTDUETOMODIFICATION);
								if (satNodeExpCacheHandler->isNodeSatisfiableCached(individualNode,expansion,calcAlgContext)) {
									stillSaturationCached = true;
									if (expansion && expansion->getDependentNominalSet(false) && !mConfSaturationCachingWithNominals) {
										stillSaturationCached = false;
									} else if (expansion) {
										installSaturationCachingReactivation(individualNode,expansion->getDependentNominalSet(false),calcAlgContext);

										if (prevSatSuccCreationBlocked && expansion->getHasTightAtMostRestriction()) {
											individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED);
											reapplySatisfiableCachedAbsorbedGeneratingConcepts(individualNode,calcAlgContext);
										}
										if (!prevSatSuccCreationBlocked && !expansion->getHasTightAtMostRestriction()) {
											individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED);
										}
									}
								}
							}
						}
					}
					if (!stillSaturationCached) {
						if (prevSatCached) {
							STATINC(SATURATIONCACHELOSECOUNT,calcAlgContext);
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED);
							reactivateIndirectSaturationCachedSuccessors(individualNode,false,calcAlgContext);
						}
						if (prevSatSuccCreationBlocked) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED);
							reapplySatisfiableCachedAbsorbedGeneratingConcepts(individualNode,calcAlgContext);
						}
					} else {
						if (!prevSatCached) {
							STATINC(SATURATIONCACHEESTABLISHCOUNT,calcAlgContext);
							individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED);
							propagateIndirectSuccessorSaturationBlocked(individualNode,calcAlgContext);
						}
					}
					return stillSaturationCached;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::isSatisfiableCachedProcessingBlocked(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool processingBlocked = false;
					bool satisfiableCached = detectIndividualNodeSatisfiableExpandedCached(individualNode,calcAlgContext);
					if (satisfiableCached) {
						// block processing only for successors of satisfiable cached nodes
						processingBlocked = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
					}
					return processingBlocked;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeSatisfiableExpandedCached(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool prevSatCached = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
					
					
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
						if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHEDABOLISHED)) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHEDABOLISHED);
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
						} else {
							return true;
						}
					}
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATISFIABLECACHEDDUEDIRECTMODIFIED)) {
						individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATISFIABLECACHEDDUEDIRECTMODIFIED);
					}


					//QStringList conSetList = generateExtendedDebugConceptSetStringList(individualNode->getReapplyConceptLabelSet(false),nullptr,nullptr,calcAlgContext);
					//debugTestCriticalConceptSet(conSetList,calcAlgContext);


					bool newSatCached = false;

					CSatisfiableExpanderCacheHandler* satExpHandler = calcAlgContext->getUsedSatisfiableExpanderCacheHandler();
					if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION | CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
						// can only satisfiable cached if there is no nominal
						if (mConfSatExpCacheRetrieval && satExpHandler) {
							bool satisfiableCached = false;
							CSignatureSatisfiableExpanderCacheEntry* entry = nullptr;
							STATINC(SATEXPCACHERETRIEVALCOUNT,calcAlgContext);
							if (satExpHandler->isIndividualNodeExpandCached(individualNode,&satisfiableCached,&entry,calcAlgContext)) {
								STATINC(SATEXPCACHERETRIEVALSUCCESSCOUNT,calcAlgContext);
								if (mConfSatExpCacheConceptExpansion) {
									expandCachedConcepts(individualNode,entry,calcAlgContext);
									if (mConfSatExpCacheSatisfiableBlocking && satisfiableCached && !individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
										STATINC(SATEXPCACHERETRIEVALFOUNDSATISFIABLECOUNT,calcAlgContext);
										bool satCompatible = false;
										CExpanderBranchedLinker* satBranchCompatibleLinker = nullptr;
										if (entry->isSatisfiableWithoutBranchedConcepts()) {
											satCompatible = true;
										} else {
											CExpanderBranchedLinker* satBranchLinker = entry->getExpanderBranchedLinker();
											if (!satBranchLinker) {
												satCompatible = true;
											} else {
												CIndividualProcessNode* ancestorIndiNode = getAncestorIndividual(individualNode,calcAlgContext);
												CExpanderBranchedLinker* satBranchLinkerIt = satBranchLinker;
												while (satBranchLinkerIt && !satCompatible) {
													bool allSatCompatible = true;
													STATINC(SATEXPCACHERETRIEVALCOMPATIBILITYTESTCOUNT,calcAlgContext);
													allSatCompatible = isSatisfiableCachedCompatible(individualNode,satBranchLinkerIt,ancestorIndiNode,calcAlgContext);		
													if (allSatCompatible) {
														satBranchCompatibleLinker = satBranchLinkerIt;
														satCompatible = true;
													}
													satBranchLinkerIt = satBranchLinkerIt->getNext();
												}									
											}
										}

										if (satCompatible) {

											//QStringList conSetList = generateExtendedDebugConceptSetStringList(individualNode->getReapplyConceptLabelSet(false),nullptr,nullptr,calcAlgContext);
											//debugTestCriticalConceptSet(conSetList,calcAlgContext);

											STATINC(SATEXPCACHERETRIEVALCOMPATIBLESATCOUNT,calcAlgContext);
											newSatCached = true;
											if (!prevSatCached) {
												individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED);
												propagateIndirectSuccessorSatisfiableCached(individualNode,calcAlgContext);
											}
										} else {
											STATINC(SATEXPCACHERETRIEVALINCOMPATIBLESATCOUNT,calcAlgContext);
										}
									}
								}
							}
						}
						if (mConfSatExpCacheWriting && !newSatCached) {
							if (!individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
								//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
								//QFile file(QString("caching-error.txt"));
								//if (file.open(QIODevice::WriteOnly)) {
								//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
								//	file.close();
								//}
								satExpHandler->cacheIndividualNodeExpansion(individualNode,calcAlgContext);
							}
						}
					}
					if (!newSatCached) {
						if (prevSatCached) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED);
							reactivateIndirectSatisfiableCachedSuccessors(individualNode,false,calcAlgContext);

							reapplySatisfiableCachedAbsorbedDisjunctionConcepts(individualNode,calcAlgContext);
							reapplySatisfiableCachedAbsorbedGeneratingConcepts(individualNode,calcAlgContext);
						}
					}


					//if (satExpHandler) {
					//	bool satisfiableCached = false;
					//	CSignatureSatisfiableExpanderCacheEntry* entry = nullptr;
					//	satExpHandler->isIndividualNodeExpandCached(individualNode,&satisfiableCached,&entry,calcAlgContext);
					//	if (entry && !individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
					//		CReapplyConceptLabelSet* conSet = individualNode->getReapplyConceptLabelSet(false);
					//		cint64 conSetCount = conSet->getConceptCount();
					//		cint64 expandCount = entry->getExpanderCacheValueCount();
					//		if (conSetCount != expandCount) {
					//			bool bug = true;
					//		}
					//	}
					//}
					return newSatCached;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasCompatibleConceptSetReuse(CIndividualProcessNode* indiNode, CReapplyConceptLabelSet* subConceptSet, CIndividualProcessNode* reuseNodeCand, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* superConceptSet = reuseNodeCand->getReapplyConceptLabelSet(false);
					bool isSubset = isLabelConceptSubSet(subConceptSet,superConceptSet,nullptr,nullptr,calcAlgContext);
					if (!isSubset) {
						return false;
					}

					CReapplyConceptLabelSetIterator superConSetIt = superConceptSet->getConceptLabelSetIterator(false,false,false);
					while (superConSetIt.hasNext()) {
						CConceptDescriptor* conDes = superConSetIt.next();
						if (isConceptSignatureBlockingCritical(reuseNodeCand,conDes,conDes->getDependencyTrackPoint(),calcAlgContext)) {
							indiNode->setInvalidSignatureBlocking(true);
							return false;
						}
					}

					return true;
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::searchSignatureReusingIndividualNode(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CSignatureBlockingCandidateHash* sigBlockCandHash = processingDataBox->getSignatureBlockingCandidateHash(false);
					CReapplyConceptLabelSet* conSet = individualNode->getReapplyConceptLabelSet(false);
					if (sigBlockCandHash && conSet) {
						cint64 conCount = conSet->getConceptCount();
						if (!individualNode->isInvalidSignatureBlocking() && individualNode->getLastConceptCountSearchBlockingCandidate() != conCount) {
							individualNode->setLastConceptCountSearchBlockingCandidate(conCount);

							cint64 conSig = conSet->getConceptSignatureValue();
							cint64 newCandCount = sigBlockCandHash->getBlockingCandidatesCount(conSig);
							cint64 lastCandCount = individualNode->getLastSearchBlockerCandidateCount();
							cint64 lastCandSignature = individualNode->getLastSearchBlockerCandidateSignature();
							if (lastCandSignature != conSig) {
								lastCandCount = 0;
							}
							individualNode->setLastSearchBlockerCandidateSignature(conSig);
							if (newCandCount != lastCandCount) {

								cint64 candDiffCount = newCandCount - lastCandCount;

								CSignatureBlockingCandidateIterator candIt(sigBlockCandHash->getBlockingCandidatesIterator(conSig));
								while (candIt.hasNext() && candDiffCount-- > 0 && !individualNode->isInvalidSignatureBlocking()) {
									cint64 candIndiID = candIt.next(true);
									if (candIndiID != individualNode->getIndividualNodeID()) {
										CIndividualProcessNode* candIndiNode = getUpToDateIndividual(candIndiID,calcAlgContext);
										if (isIndividualNodeValidBlocker(candIndiNode,calcAlgContext)) {
											bool compatible = hasCompatibleConceptSetReuse(individualNode,conSet,candIndiNode,calcAlgContext);
											if (compatible) {
												individualNode->setLastSearchBlockerCandidateCount(newCandCount-candDiffCount);
												return candIndiNode;
											}
										}
									}
								}
								individualNode->setLastSearchBlockerCandidateCount(newCandCount);

							}
						}
					}
					return nullptr;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::removeIndividualReusing(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL);
					removeReusingBlockerFollowing(individualNode,calcAlgContext);
					reactivateIndirectReuseSuccessors(individualNode,true,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::updateIndividualReusing(CIndividualProcessNode* processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL)) {
						// 1. update non-deterministic expansions, 2. update deterministic expansions
						CReusingIndividualNodeConceptExpansionData* reusingData = processIndi->getReusingIndividualNodeConceptExpansionData(false);
						CIndividualProcessNode* reuseIndi = reusingData->getBlockerIndividualNode();
						reuseIndi = getUpToDateIndividual(reuseIndi,calcAlgContext);

						// test whether reused individual is now invalid or blocked
						if (isIndividualNodeValidBlocker(reuseIndi,calcAlgContext)) {
							// search other reuseable individual
							removeReusingBlockerFollowing(processIndi,calcAlgContext);

							reuseIndi = searchSignatureReusingIndividualNode(processIndi,calcAlgContext);
							if (reuseIndi) {

								CReusingIndividualNodeConceptExpansionData* locReusingData = processIndi->getReusingIndividualNodeConceptExpansionData(true);
								if (!locReusingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locReusingData = CObjectAllocator<CReusingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locReusingData->initBlockingExpansionData(reusingData);
									reusingData = locReusingData;
									processIndi->setReusingIndividualNodeConceptExpansionData(locReusingData);
								}
								locReusingData->setBlockerIndividualNode(reuseIndi);
								locReusingData->setBlockingConceptCount(0);
								locReusingData->setBlockingConceptSignature(0);
								locReusingData->setLastSubsetTestedConceptDescriptor(nullptr);
								locReusingData->setContinuousExpandedContainedConceptCount(0);
								locReusingData->setLastUpdatedConceptCount(0);
								locReusingData->setLastUpdatedConceptExpansionCount(0);
								locReusingData->setLastNonDeterministicExpansionLinker(nullptr);

								addReusingBlockerFollowing(processIndi,calcAlgContext);
							} else {

								reactivateIndirectReuseSuccessors(processIndi,true,calcAlgContext);
								processIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL);
								if (reusingData->isBlockingReviewMarked()) {
									CReusingReviewData* reusingReviewData = calcAlgContext->getProcessingDataBox()->getReusingReviewData(true);
									reusingReviewData->remove(processIndi->getIndividualNodeID());
								}

							}
						}

						bool reusingIndiCompatible = true;

						if (reuseIndi) {
							anlyzeIndiviudalNodesConceptExpansion(reuseIndi,calcAlgContext);


							CIndividualNodeAnalizedConceptExpansionData* blockerAnalizedConExpData = reuseIndi->getAnalizedConceptExpansionData(false);
							CXLinker<CConceptDescriptor*>* nonDetExpLinker = blockerAnalizedConExpData->getAnalysedNonDeterministicConceptExpansionLinker();
							reusingIndiCompatible &= !blockerAnalizedConExpData->isInvalidBlocker();

							CXLinker<CConceptDescriptor*>* lastNonDetExpLinker = reusingData->getLastNonDeterministicExpansionLinker();
							CReapplyConceptLabelSet* processIndiLabelSet = processIndi->getReapplyConceptLabelSet(false);

							if (nonDetExpLinker != lastNonDetExpLinker) {
								processIndiLabelSet = processIndi->getReapplyConceptLabelSet(true);

								CReusingIndividualNodeConceptExpansionData* locReusingData = processIndi->getReusingIndividualNodeConceptExpansionData(true);
								if (!locReusingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locReusingData = CObjectAllocator<CReusingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locReusingData->initBlockingExpansionData(reusingData);
									reusingData = locReusingData;
									processIndi->setReusingIndividualNodeConceptExpansionData(locReusingData);
								}

								CNonDeterministicDependencyTrackPoint* lastReuseConceptsDepTrackPoint = locReusingData->getReuseConceptsDependencyTrackPoint();


								CREUSECONCEPTSDependencyNode* reuseConceptsDepNode = createREUSECONCEPTSDependency(processIndi,nullptr,lastReuseConceptsDepTrackPoint,calcAlgContext);
								CNonDeterministicDependencyTrackPoint* reuseConceptsDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseConceptsDepNode,true,calcAlgContext);

								for (CXLinker<CConceptDescriptor*>* nonDetExpLinkerIt = nonDetExpLinker; nonDetExpLinkerIt; nonDetExpLinkerIt = nonDetExpLinkerIt->getNext()) {
									CConceptDescriptor* reusingConDes = nonDetExpLinkerIt->getData();

									if (!processIndiLabelSet->containsConceptDescriptor(reusingConDes)) {
										// add non-deterministically the missing concept
										addConceptToIndividual(reusingConDes->getConcept(),reusingConDes->isNegated(),processIndi,reuseConceptsDependencyTrackPoint,false,true,calcAlgContext);
									}
								}

								locReusingData->setReuseConceptsDependencyTrackPoint(reuseConceptsDependencyTrackPoint);
								locReusingData->setLastNonDeterministicExpansionLinker(nonDetExpLinker);

							}

							CConceptDescriptor* addingSortedConDes = processIndiLabelSet->getAddingSortedConceptDescriptionLinker();
							CConceptDescriptor* lastSubSetTestConDes = reusingData->getLastSubsetTestedConceptDescriptor();

							if (addingSortedConDes != lastSubSetTestConDes || blockerAnalizedConExpData->getExpansionConceptCount() != reusingData->getLastUpdatedConceptExpansionCount()) {
								CReusingIndividualNodeConceptExpansionData* locReusingData = processIndi->getReusingIndividualNodeConceptExpansionData(true);
								if (!locReusingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locReusingData = CObjectAllocator<CReusingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locReusingData->initBlockingExpansionData(reusingData);
									reusingData = locReusingData;
									processIndi->setReusingIndividualNodeConceptExpansionData(locReusingData);
								}
								updateSignatureBlockingConceptExpansion(processIndi,locReusingData,reuseIndi,blockerAnalizedConExpData,calcAlgContext);

								CReapplyConceptLabelSet* reuseIndiLabelSet = reuseIndi->getReapplyConceptLabelSet(false);

								// validate still subset
								bool stillSubset = locReusingData->isConceptSetStillSubset();
								if (stillSubset) {
									CConceptDescriptor* addingSortedConDesIt = addingSortedConDes;
									while (addingSortedConDesIt != lastSubSetTestConDes && stillSubset) {
										CConcept* concept = addingSortedConDesIt->getConcept();
										bool conNegation = addingSortedConDesIt->isNegated();
										if (!processIndiLabelSet->containsConcept(concept,conNegation)) {
											stillSubset = false;
										}
										addingSortedConDesIt = addingSortedConDesIt->getNext();
									}
									locReusingData->setConceptSetStillSubset(stillSubset);
								}
								locReusingData->setLastSubsetTestedConceptDescriptor(addingSortedConDes);

								if (!stillSubset) {
									reusingIndiCompatible = false;
								}
							}
						}

						if (reuseIndi) {
							if (!reusingIndiCompatible) {
								CReusingIndividualNodeConceptExpansionData* locReusingData = processIndi->getReusingIndividualNodeConceptExpansionData(true);
								if (!locReusingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locReusingData = CObjectAllocator<CReusingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locReusingData->initBlockingExpansionData(reusingData);
									reusingData = locReusingData;
									processIndi->setReusingIndividualNodeConceptExpansionData(locReusingData);
								}


								if (!locReusingData->isBlockingReviewMarked()) {
									locReusingData->setBlockingReviewMarked(true);
									CReusingReviewData* reusingReviewData = calcAlgContext->getProcessingDataBox()->getReusingReviewData(true);
									reusingReviewData->insert(processIndi->getIndividualAncestorDepth(),processIndi->getIndividualNodeID());
								}
							}
						}

						
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::upgradeSignatureBlockingToIndividualReusing(CIndividualProcessNode* processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockData = processIndi->getSignatureBlockingIndividualNodeConceptExpansionData(false);
					CIndividualProcessNode* reuseIndi = sigBlockData->getBlockerIndividualNode();

					processIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED);
					reactivateIndirectSignatureBlockedSuccessors(processIndi,false,calcAlgContext);
					reapplySatisfiableCachedAbsorbedGeneratingConcepts(processIndi,calcAlgContext);

					establishIndividualReusing(processIndi,reuseIndi,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::establishIndividualReusing(CIndividualProcessNode* processIndi, CIndividualProcessNode* reuseIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEINDIVIDUALDependencyNode* reuseDepNode = createREUSEINDIVIDUALDependency(processIndi,nullptr,nullptr,calcAlgContext);

					CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(2,calcAlgContext);
					CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

					anlyzeIndiviudalNodesConceptExpansion(reuseIndi,calcAlgContext);
					CIndividualNodeAnalizedConceptExpansionData* blockerAnalizedConExpData = reuseIndi->getAnalizedConceptExpansionData(false);
					if (blockerAnalizedConExpData) {

						CXLinker<CConceptDescriptor*>* nonDetExpLinker = blockerAnalizedConExpData->getAnalysedNonDeterministicConceptExpansionLinker();

						CSatisfiableCalculationTask* newTaskIt = newTaskList;
						for (cint64 i = 0; i < 2; ++i) {

							bool reusingAlternative = i == 0;

							CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;
							CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);

							CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
							CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

							CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
							newProcessTagger->incBranchingTag();
							newProcessTagger->incLocalizationTag();

							CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(processIndi,false,newCalcAlgContext);
							CConceptProcessingQueue* newConProcQueue = newLocIndiNode->getConceptProcessingQueue(true);


							CReusingIndividualNodeConceptExpansionData* locReusingData = newLocIndiNode->getReusingIndividualNodeConceptExpansionData(true);
							if (!locReusingData) {
								CMemoryAllocationManager* taskMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();
								CReusingIndividualNodeConceptExpansionData* reusingData = newLocIndiNode->getReusingIndividualNodeConceptExpansionData(false);
								locReusingData = CObjectAllocator<CReusingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
								locReusingData->initBlockingExpansionData(reusingData);
								newLocIndiNode->setReusingIndividualNodeConceptExpansionData(locReusingData);
							}
							locReusingData->incReusingTriedCount();

							locReusingData->setBlockingConceptCount(0);
							locReusingData->setBlockingConceptSignature(0);
							locReusingData->setLastSubsetTestedConceptDescriptor(nullptr);
							locReusingData->setContinuousExpandedContainedConceptCount(0);
							locReusingData->setBlockerIndividualNode(nullptr);
							locReusingData->setLastUpdatedConceptCount(0);
							locReusingData->setLastUpdatedConceptExpansionCount(0);
							locReusingData->setBlockingReviewMarked(false);



							if (reusingAlternative) {

								CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode,false,newCalcAlgContext);

								CREUSECONCEPTSDependencyNode* reuseConceptsDepNode = createREUSECONCEPTSDependency(processIndi,nullptr,newDependencyTrackPoint,newCalcAlgContext);
								CNonDeterministicDependencyTrackPoint* reuseConceptsDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseConceptsDepNode,true,newCalcAlgContext);

								locReusingData->setReuseConceptsDependencyTrackPoint(reuseConceptsDependencyTrackPoint);

								CReapplyConceptLabelSet* indiLabelSet = newLocIndiNode->getReapplyConceptLabelSet(true);


								locReusingData->setBlockingConceptCount(indiLabelSet->getConceptCount());
								locReusingData->setBlockingConceptSignature(indiLabelSet->getConceptSignatureValue());
								locReusingData->setLastSubsetTestedConceptDescriptor(indiLabelSet->getAddingSortedConceptDescriptionLinker());
								locReusingData->setContinuousExpandedContainedConceptCount(0);
								locReusingData->setBlockerIndividualNode(reuseIndi);
								locReusingData->setLastUpdatedConceptCount(0);
								locReusingData->setLastUpdatedConceptExpansionCount(0);


								for (CXLinker<CConceptDescriptor*>* nonDetExpLinkerIt = nonDetExpLinker; nonDetExpLinkerIt; nonDetExpLinkerIt = nonDetExpLinkerIt->getNext()) {
									CConceptDescriptor* reusingConDes = nonDetExpLinkerIt->getData();

									if (!indiLabelSet->containsConceptDescriptor(reusingConDes)) {
										// add non-deterministically the missing concept
										addConceptToIndividual(reusingConDes->getConcept(),reusingConDes->isNegated(),newLocIndiNode,reuseConceptsDependencyTrackPoint,false,true,newCalcAlgContext);
									}
								}

								newLocIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL);

								addReusingBlockerFollowing(newLocIndiNode,newCalcAlgContext);
								propagateIndirectSuccessorReuseBlocked(newLocIndiNode,newCalcAlgContext);
							} else {
								CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode,false,newCalcAlgContext);
								locReusingData->incReusingFailedCount();
								locReusingData->addReusingFailedSignatureAndIndividual(reuseIndi->getReapplyConceptLabelSet(false)->getConceptSignatureValue(),reuseIndi->getIndividualNodeID());
							}

							prepareBranchedTaskProcessing(newLocIndiNode,newTaskIt,newCalcAlgContext);

							// set new task priority
							double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskReusing(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask(),reusingAlternative);
							newSatCalcTask->setTaskPriority(newTaskPriority);

							newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();
						}

						processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

						throw CCalculationStopProcessingException(true);
					}
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::addReusingBlockerFollowing(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReusingIndividualNodeConceptExpansionData* reusingData = individualNode->getReusingIndividualNodeConceptExpansionData(false);
					if (reusingData) {
						CIndividualProcessNode* blockerIndividualNode = reusingData->getBlockerIndividualNode();
						CIndividualProcessNode* locBlockerIndividualNode = getLocalizedIndividual(blockerIndividualNode,true,calcAlgContext);
						CBlockingFollowSet* followSet = locBlockerIndividualNode->getBlockingFollowSet(true);
						followSet->insert(individualNode->getIndividualNodeID());
						individualNode->setFollowingIndividualNode(locBlockerIndividualNode);
						return true;
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::removeReusingBlockerFollowing(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					individualNode->setFollowingIndividualNode(nullptr);
					CReusingIndividualNodeConceptExpansionData* reusingData = individualNode->getReusingIndividualNodeConceptExpansionData(false);
					if (reusingData) {
						CIndividualProcessNode* blockerIndividualNode = reusingData->getBlockerIndividualNode();
						CIndividualProcessNode* locBlockerIndividualNode = getLocalizedIndividual(blockerIndividualNode,true,calcAlgContext);
						CBlockingFollowSet* followSet = locBlockerIndividualNode->getBlockingFollowSet(true);
						followSet->remove(individualNode->getIndividualNodeID());
						return true;
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isSignatureBlockedProcessingBlocked(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool processingBlocked = false;
					bool sigBlocked = detectIndividualNodeSignatureBlockingStatus(individualNode,calcAlgContext);
					if (sigBlocked) {
						// block processing only for successors of satisfiable cached nodes
						processingBlocked = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);
					}
					return processingBlocked;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::testAlternativeBlocked(CIndividualProcessNode*& individualNode, CBlockingAlternativeData* blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool blocked = false;

					if (blockAltData->getBlockingAlternativeDataType() == CBlockingAlternativeData::BADSIGNATUREBLOCKINGCANDIDATE) {
						if (mConfSignatureMirroringBlocking) {
							CBlockingAlternativeSignatureBlockingCandidateData* sigBlockCandData = (CBlockingAlternativeSignatureBlockingCandidateData*)blockAltData;
							CIndividualProcessNode* blockerNode = sigBlockCandData->getSignatureBlockingCandidateNode();


							STATINC(SIGNATUREMIRRORINGBLOCKINGESTABLISHCOUNT,calcAlgContext);
							cint64 prevBlockerConSetCount = blockerNode->getReapplyConceptLabelSet(false)->getConceptCount();
							if (establishIndividualNodeSignatureBlocking(individualNode,blockerNode,calcAlgContext)) {

								//if (blockerNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
								//	propagateIndividualNodeNominalConnectionToAncestors(individualNode,calcAlgContext);
								//}
								if (blockerNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
									propagateIndividualNodeNominalConnectionStatusToAncestors(individualNode,blockerNode,calcAlgContext);
								}

								if (prevBlockerConSetCount != blockerNode->getReapplyConceptLabelSet(false)->getConceptCount()) {
									addIndividualToBlockingUpdateReviewProcessingQueue(individualNode,calcAlgContext);
								}
								addSignatureBlockingBlockerFollowing(individualNode,calcAlgContext);
								STATINC(SIGNATUREMIRRORINGBLOCKINGADDFOLLOWINGCOUNT,calcAlgContext);
								calcAlgContext->getProcessTagger()->incCurrentBlockingFollowTag();

								individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED);
								propagateIndirectSuccessorSignatureBlocked(individualNode,calcAlgContext);

								updateBlockingReviewMarking(individualNode,true,calcAlgContext);
								blocked = true;
							}
						}
					}

					return blocked;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeSignatureBlockingStatus(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					// TODO: 1. search nodes with identical signatures, 2. check signature compatibility, 3. expand concepts and establish blocking status, 4. block successor generation, 
					// 5. hold blocking status as long subset, 6. validate or remove blocking status at the end of completion graph construction


					bool wasBlockingCached = individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);

					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
						if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHEDABOLISHED)) {
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHEDABOLISHED);
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);
						} else {
							return true;
						}
					}
					if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSIGNATUREBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSIGNATUREBLOCKINGCACHEDDUEDIRECTMODIFIED);
					}

					bool newBlockingCached = wasBlockingCached;

					if (mConfSignatureMirroringBlocking) {
						bool continueBlockerSearch = true;
						if (individualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING | CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
							continueBlockerSearch = false;
						}
						if (wasBlockingCached) {
							STATINC(SIGNATUREMIRRORINGBLOCKINGREFRESHCOUNT,calcAlgContext);
							if (continueBlockerSearch) {
								newBlockingCached = refreshIndividualNodeSignatureBlocking(individualNode,calcAlgContext);
							}
							if (!newBlockingCached) {
								// remove connection from blocker node
								STATINC(SIGNATUREMIRRORINGBLOCKINGREFRESHLOSEDCOUNT,calcAlgContext);
								STATINC(SIGNATUREMIRRORINGBLOCKINGREMOVEFOLLOWINGCOUNT,calcAlgContext);
								removeSignatureBlockingBlockerFollowing(individualNode,calcAlgContext);
							} else {
								calcAlgContext->getProcessTagger()->incCurrentBlockingFollowTag();
							}
						}

						while (continueBlockerSearch && !newBlockingCached) {
							STATINC(SIGNATUREMIRRORINGBLOCKINGSEARCHCOUNT,calcAlgContext);
							CIndividualProcessNode* blockerNode = searchSignatureIndividualNodeBlocker(individualNode,calcAlgContext);
							if (blockerNode) {
								STATINC(SIGNATUREMIRRORINGBLOCKINGESTABLISHCOUNT,calcAlgContext);
								cint64 prevBlockerConSetCount = blockerNode->getReapplyConceptLabelSet(false)->getConceptCount();
								if (establishIndividualNodeSignatureBlocking(individualNode,blockerNode,calcAlgContext)) {

									//if (blockerNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
									//	propagateIndividualNodeNominalConnectionToAncestors(individualNode,calcAlgContext);
									//}
									if (blockerNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
										propagateIndividualNodeNominalConnectionStatusToAncestors(individualNode,blockerNode,calcAlgContext);
									}

									newBlockingCached = true;
									if (prevBlockerConSetCount != blockerNode->getReapplyConceptLabelSet(false)->getConceptCount()) {
										addIndividualToBlockingUpdateReviewProcessingQueue(individualNode,calcAlgContext);
									}
									addSignatureBlockingBlockerFollowing(individualNode,calcAlgContext);
									STATINC(SIGNATUREMIRRORINGBLOCKINGADDFOLLOWINGCOUNT,calcAlgContext);
									calcAlgContext->getProcessTagger()->incCurrentBlockingFollowTag();
								}
							} else {
								continueBlockerSearch = false;
							}
						}

						updateBlockingReviewMarking(individualNode,newBlockingCached,calcAlgContext);

						if (newBlockingCached && !wasBlockingCached) {
							// activate caching status
							individualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED);
							propagateIndirectSuccessorSignatureBlocked(individualNode,calcAlgContext);
						} else if (wasBlockingCached && !newBlockingCached) {
							// deactivate caching status
							individualNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED);
							reactivateIndirectSignatureBlockedSuccessors(individualNode,false,calcAlgContext);
							reapplySatisfiableCachedAbsorbedGeneratingConcepts(individualNode,calcAlgContext);
						}
					}
					return newBlockingCached;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::addSignatureBlockingBlockerFollowing(CIndividualProcessNode*& blockingIndividualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
					if (sigBlockingData) {
						CIndividualProcessNode* blockerIndividualNode = sigBlockingData->getBlockerIndividualNode();
						CIndividualProcessNode* locBlockerIndividualNode = getLocalizedIndividual(blockerIndividualNode,true,calcAlgContext);
						CBlockingFollowSet* sigFollowSet = locBlockerIndividualNode->getBlockingFollowSet(true);
						sigFollowSet->insert(blockingIndividualNode->getIndividualNodeID());
						blockingIndividualNode->setFollowingIndividualNode(locBlockerIndividualNode);
						return true;
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::removeSignatureBlockingBlockerFollowing(CIndividualProcessNode*& blockingIndividualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					blockingIndividualNode->setFollowingIndividualNode(nullptr);
					CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
					if (sigBlockingData) {
						CIndividualProcessNode* blockerIndividualNode = sigBlockingData->getBlockerIndividualNode();
						CIndividualProcessNode* locBlockerIndividualNode = getLocalizedIndividual(blockerIndividualNode,true,calcAlgContext);
						CBlockingFollowSet* sigFollowSet = locBlockerIndividualNode->getBlockingFollowSet(true);
						sigFollowSet->remove(blockingIndividualNode->getIndividualNodeID());
						return true;
					}
					return false;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::rebuildSignatureBlockingCandidateHash(CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();


					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CSignatureBlockingCandidateHash* sigBlockCandHash = processingDataBox->getSignatureBlockingCandidateHash(false);

					if (sigBlockCandHash) {

						CSignatureBlockingCandidateHash* newSigBlockCandHash = CObjectParameterizingAllocator< CSignatureBlockingCandidateHash,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);

						CSignatureIterator sigIt(sigBlockCandHash->getSignatureIterator());
						while (sigIt.hasNext()) {
							cint64 signature = sigIt.getSignature();
							CXLinker<cint64>* newCandidateLinker = nullptr;
							CXLinker<cint64>* candidateLinker = sigIt.getCandidateLinker();
							for (CXLinker<cint64>* candidateLinkerIt = candidateLinker; candidateLinkerIt; candidateLinkerIt = candidateLinkerIt->getNext()) {
								cint64 candIndiID = candidateLinkerIt->getData();
								CIndividualProcessNode* candIndiNode = getUpToDateIndividual(candIndiID,calcAlgContext);
								if (isIndividualNodeValidBlocker(candIndiNode,calcAlgContext)) {
									CXLinker<cint64>* tmpNewCandLinker = CObjectAllocator< CXLinker<cint64> >::allocateAndConstruct(taskMemMan);
									newCandidateLinker = tmpNewCandLinker->initLinker(candIndiNode->getIndividualNodeID(),newCandidateLinker);
								}
							}
							if (newCandidateLinker) {
								newSigBlockCandHash->insertSignatureBlockingCandidates(signature,newCandidateLinker);
							}
							sigIt.moveNext();
						}
						processingDataBox->setSignatureBlockingCandidateHash(newSigBlockCandHash);
					}
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::searchSignatureIndividualNodeBlocker(CIndividualProcessNode*& blockingNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CSignatureBlockingCandidateHash* sigBlockCandHash = processingDataBox->getSignatureBlockingCandidateHash(false);
					CReapplyConceptLabelSet* conSet = blockingNode->getReapplyConceptLabelSet(false);
					if (sigBlockCandHash && conSet) {
						cint64 conCount = conSet->getConceptCount();
						if (!blockingNode->isInvalidSignatureBlocking() && blockingNode->getLastConceptCountSearchBlockingCandidate() != conCount) {
							blockingNode->setLastConceptCountSearchBlockingCandidate(conCount);

							cint64 conSig = conSet->getConceptSignatureValue();
							cint64 newCandCount = sigBlockCandHash->getBlockingCandidatesCount(conSig);
							cint64 lastCandCount = blockingNode->getLastSearchBlockerCandidateCount();
							cint64 lastCandSignature = blockingNode->getLastSearchBlockerCandidateSignature();
							if (lastCandSignature != conSig) {
								lastCandCount = 0;
							}
							blockingNode->setLastSearchBlockerCandidateSignature(conSig);
							if (newCandCount != lastCandCount) {

								cint64 candDiffCount = newCandCount - lastCandCount;

								CSignatureBlockingCandidateIterator candIt(sigBlockCandHash->getBlockingCandidatesIterator(conSig));
								while (candIt.hasNext() && candDiffCount-- > 0 && !blockingNode->isInvalidSignatureBlocking()) {
									cint64 candIndiID = candIt.next(true);
									if (candIndiID != blockingNode->getIndividualNodeID()) {
										CIndividualProcessNode* candIndiNode = getUpToDateIndividual(candIndiID,calcAlgContext);
										STATINC(SIGNATUREMIRRORINGBLOCKINGCANDIDATEREGARDEDCOUNT,calcAlgContext);
										if (isIndividualNodeValidBlocker(candIndiNode,calcAlgContext)) {
											bool compatible = hasCompatibleConceptSetSignature(blockingNode,conSet,candIndiNode,calcAlgContext);
											if (compatible) {
												blockingNode->setLastSearchBlockerCandidateCount(newCandCount-candDiffCount);
												return candIndiNode;
											} else {
												STATINC(SIGNATUREMIRRORINGBLOCKINGCANDIDATEREGARDEDINCOMPATIBLECOUNT,calcAlgContext);
											}
										} else {
											STATINC(SIGNATUREMIRRORINGBLOCKINGCANDIDATEREGARDEDINVALIDCOUNT,calcAlgContext);
										}
									}
								}
								blockingNode->setLastSearchBlockerCandidateCount(newCandCount);

							}
						}
					}
					return nullptr;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::addSignatureIndividualNodeBlockerCandidate(CIndividualProcessNode*& indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (indiNode->getBlockingCachingSavedCandidateCount() <= mMaxBlockingCachingSavedCandidateCount) {
						indiNode->incBlockingCachingSavedCandidateCount();
						if (isIndividualNodeValidBlocker(indiNode,calcAlgContext)) {
							CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
							if (conSet) {
								cint64 conCount = conSet->getConceptCount();
								if (indiNode->getLastConceptCountCachedBlockingCandidate() != conCount) { 
									STATINC(SIGNATURESAVINGCOUNT,calcAlgContext);
									cint64 conSig = conSet->getConceptSignatureValue();
									CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
									CSignatureBlockingCandidateHash* sigBlockCandHash = processingDataBox->getSignatureBlockingCandidateHash(true);
									sigBlockCandHash->insertSignatureBlockingCandidate(conSig,indiNode);
									indiNode->setLastConceptCountCachedBlockingCandidate(conCount);
									return true;
								}
							}
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::establishIndividualNodeSignatureBlocking(CIndividualProcessNode*& blockingIndividualNode, CIndividualProcessNode*& blockerIndividualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool blockingEstablished = false;
					anlyzeIndiviudalNodesConceptExpansion(blockerIndividualNode,calcAlgContext);
					CIndividualNodeAnalizedConceptExpansionData* blockerAnalizedConExpData = blockerIndividualNode->getAnalizedConceptExpansionData(false);
					if (blockerAnalizedConExpData) {
						if (!blockerAnalizedConExpData->isInvalidBlocker()) {
							CReapplyConceptLabelSet* blockingConSet = blockingIndividualNode->getReapplyConceptLabelSet(true);
							cint64 blockingConSetCount = blockingConSet->getConceptCount();
							cint64 blockingConSetSignature = blockingConSet->getConceptSignatureValue();
							CConceptDescriptor* blockingLastConDes = blockingConSet->getAddingSortedConceptDescriptionLinker();
							CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
							if (!locSigBlockingData) {
								CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
								CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
								locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
								locSigBlockingData->initBlockingExpansionData(sigBlockingData);
								blockingIndividualNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
							}
							locSigBlockingData->setBlockingConceptCount(blockingConSetCount);
							locSigBlockingData->setBlockingConceptSignature(blockingConSetSignature);
							locSigBlockingData->setLastSubsetTestedConceptDescriptor(blockingLastConDes);
							locSigBlockingData->setContinuousExpandedContainedConceptCount(0);
							locSigBlockingData->setBlockerIndividualNode(blockerIndividualNode);
							locSigBlockingData->setLastUpdatedConceptCount(0);
							locSigBlockingData->setLastUpdatedConceptExpansionCount(0);

							updateSignatureBlockingConceptExpansion(blockingIndividualNode,locSigBlockingData,blockerIndividualNode,blockerAnalizedConExpData,calcAlgContext);


							// set blocking status
							blockingEstablished = true;

							// is still subset after added expansions concepts
							CReapplyConceptLabelSet* blockerConSet = blockerIndividualNode->getReapplyConceptLabelSet(false);
							if (locSigBlockingData->isIdenticConceptSetRequired()) {
								if (blockingConSet->getConceptSignatureValue() != blockerConSet->getConceptSignatureValue()) {
									return false;
								}
								if (blockingConSet->getConceptCount() != blockerConSet->getConceptCount()) {
									return false;
								}
							}
							CConceptDescriptor* lastSubSetTestConDes = locSigBlockingData->getLastSubsetTestedConceptDescriptor();
							CConceptDescriptor* addingSortedConDes = blockingConSet->getAddingSortedConceptDescriptionLinker();
							if (addingSortedConDes != lastSubSetTestConDes) {
								bool stillSubset = true;
								CConceptDescriptor* addingSortedConDesIt = addingSortedConDes;
								while (blockingEstablished && addingSortedConDesIt != lastSubSetTestConDes && stillSubset) {
									CConcept* concept = addingSortedConDesIt->getConcept();
									if (!blockerConSet->containsConcept(concept)) {
										stillSubset = false;
									}
									addingSortedConDesIt = addingSortedConDesIt->getNext();
								}
								if (!stillSubset && mOptSignatureMirroringBlockingForceSubset) {
									blockingEstablished = false;
								}
								locSigBlockingData->setConceptSetStillSubset(stillSubset);
								if (stillSubset) {
									locSigBlockingData->setLastSubsetTestedConceptDescriptor(addingSortedConDes);
								}
							}			
						} else {
							blockingIndividualNode->setInvalidSignatureBlocking(true);
							blockingEstablished = false;
						}
					}
					return blockingEstablished;						 
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::refreshIndividualNodeSignatureBlocking(CIndividualProcessNode*& blockingIndividualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
					if (sigBlockingData) {
						CIndividualProcessNode* blockerIndividualNode = sigBlockingData->getBlockerIndividualNode();
						blockerIndividualNode = getUpToDateIndividual(blockerIndividualNode,calcAlgContext);
						if (!isIndividualNodeValidBlocker(blockerIndividualNode,calcAlgContext)) {
							return false;
						}
						if (blockingIndividualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
							return false;
						}
						anlyzeIndiviudalNodesConceptExpansion(blockerIndividualNode,calcAlgContext);
						// test is still subset?
						CReapplyConceptLabelSet* blockingConSet = blockingIndividualNode->getReapplyConceptLabelSet(false);
						CReapplyConceptLabelSet* blockerConSet = blockerIndividualNode->getReapplyConceptLabelSet(false);
						CConceptDescriptor* lastSubSetTestConDes = sigBlockingData->getLastSubsetTestedConceptDescriptor();
						CConceptDescriptor* addingSortedConDes = blockingConSet->getAddingSortedConceptDescriptionLinker();
						CIndividualNodeAnalizedConceptExpansionData* blockerAnalizedConExpData = blockerIndividualNode->getAnalizedConceptExpansionData(false);
						if (!blockerAnalizedConExpData->isInvalidBlocker()) {
							if (addingSortedConDes != lastSubSetTestConDes || blockerAnalizedConExpData->getExpansionConceptCount() != sigBlockingData->getLastUpdatedConceptExpansionCount() || sigBlockingData->isIdenticConceptSetRequired() && blockingConSet->getConceptCount() != blockerConSet->getConceptCount()) {
								bool stillSubset = true;
								CConceptDescriptor* addingSortedConDesIt = addingSortedConDes;
								while (addingSortedConDesIt != lastSubSetTestConDes && stillSubset) {
									CConcept* concept = addingSortedConDesIt->getConcept();
									bool conNegation = addingSortedConDesIt->isNegated();
									if (!blockerConSet->containsConcept(concept,conNegation)) {
										stillSubset = false;
									}
									addingSortedConDesIt = addingSortedConDesIt->getNext();
								}
								if (!stillSubset && mOptSignatureMirroringBlockingForceSubset) {
									return false;
								}
								CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
								if (!locSigBlockingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
									locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locSigBlockingData->initBlockingExpansionData(sigBlockingData);
									blockingIndividualNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
								}
								locSigBlockingData->setLastSubsetTestedConceptDescriptor(addingSortedConDes);

								// update expansions concepts
								updateSignatureBlockingConceptExpansion(blockingIndividualNode,locSigBlockingData,blockerIndividualNode,blockerAnalizedConExpData,calcAlgContext);

								if (mConfDirectRulePreprocessing || locSigBlockingData->isIdenticConceptSetRequired()) {
									blockingConSet = blockingIndividualNode->getReapplyConceptLabelSet(false);
									if (locSigBlockingData->isIdenticConceptSetRequired()) {
										if (blockingConSet->getConceptSignatureValue() != blockerConSet->getConceptSignatureValue()) {
											return false;
										}
										if (blockingConSet->getConceptCount() != blockerConSet->getConceptCount()) {
											return false;
										}
									}
									// validate still subset
									addingSortedConDes = blockingConSet->getAddingSortedConceptDescriptionLinker();
									lastSubSetTestConDes = locSigBlockingData->getLastSubsetTestedConceptDescriptor();
									if (addingSortedConDes != lastSubSetTestConDes) {
										CConceptDescriptor* addingSortedConDesIt = addingSortedConDes;
										while (addingSortedConDesIt != lastSubSetTestConDes && stillSubset) {
											CConcept* concept = addingSortedConDesIt->getConcept();
											bool conNegation = addingSortedConDesIt->isNegated();
											if (!blockerConSet->containsConcept(concept,conNegation)) {
												stillSubset = false;
											}
											addingSortedConDesIt = addingSortedConDesIt->getNext();
										}
										locSigBlockingData->setConceptSetStillSubset(stillSubset);
										if (stillSubset) {
											locSigBlockingData->setLastSubsetTestedConceptDescriptor(addingSortedConDes);
										} else {
											if (mOptSignatureMirroringBlockingForceSubset) {
												return false;
											}
										}
									}
								}
							}
							return true;
						} else {
							blockingIndividualNode->setInvalidSignatureBlocking(true);
							return false;
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::updateBlockingReviewMarking(CIndividualProcessNode*& blockingIndividualNode, bool isBlocked, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(false);
					cint64 indiID = blockingIndividualNode->getIndividualNodeID();
					if (sigBlockingData) {
						if (isBlocked && !sigBlockingData->isBlockingReviewMarked()) {
							CIndividualProcessNode* blockerNode = getUpToDateIndividual(sigBlockingData->getBlockerIndividualNode(),calcAlgContext);
							if (blockerNode->getReapplyConceptLabelSet(false)->getConceptCount() != blockingIndividualNode->getReapplyConceptLabelSet(false)->getConceptCount() || !sigBlockingData->isConceptSetStillSubset()) {
								CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
								CSignatureBlockingReviewSet* revSet = processingDataBox->getSignatureBlockingReviewSet(true);
								
								revSet->getReviewData(sigBlockingData->isConceptSetStillSubset())->insert(blockingIndividualNode->getIndividualAncestorDepth(),indiID);

								CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
								if (!locSigBlockingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locSigBlockingData->initBlockingExpansionData(sigBlockingData);
									blockingIndividualNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
								}
								locSigBlockingData->setBlockingReviewMarked(true);
								locSigBlockingData->setBlockingSubsetReviewMarked(sigBlockingData->isConceptSetStillSubset());
								return true;
							}
						} 
						if (sigBlockingData->isBlockingReviewMarked()) {
							CIndividualProcessNode* blockerNode = getUpToDateIndividual(sigBlockingData->getBlockerIndividualNode(),calcAlgContext);
							if (!isBlocked || blockerNode->getReapplyConceptLabelSet(false)->getConceptCount() == blockingIndividualNode->getReapplyConceptLabelSet(false)->getConceptCount() && sigBlockingData->isConceptSetStillSubset()) {
								CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
								CSignatureBlockingReviewSet* revSet = processingDataBox->getSignatureBlockingReviewSet(true);

								revSet->getReviewData(sigBlockingData->isBlockingSubsetReviewMarked())->remove(indiID);

								CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
								if (!locSigBlockingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locSigBlockingData->initBlockingExpansionData(sigBlockingData);
									blockingIndividualNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
								}
								locSigBlockingData->setBlockingReviewMarked(false);
								locSigBlockingData->setBlockingSubsetReviewMarked(sigBlockingData->isConceptSetStillSubset());

								return true;

							} else if (sigBlockingData->isBlockingSubsetReviewMarked() != sigBlockingData->isConceptSetStillSubset()) {
								CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
								CSignatureBlockingReviewSet* revSet = processingDataBox->getSignatureBlockingReviewSet(true);

								revSet->getReviewData(sigBlockingData->isBlockingSubsetReviewMarked())->remove(indiID);
								revSet->getReviewData(sigBlockingData->isConceptSetStillSubset())->insert(blockingIndividualNode->getIndividualAncestorDepth(),indiID);

								CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = blockingIndividualNode->getSignatureBlockingIndividualNodeConceptExpansionData(true);
								if (!locSigBlockingData) {
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									locSigBlockingData = CObjectAllocator<CSignatureBlockingIndividualNodeConceptExpansionData>::allocateAndConstruct(taskMemMan);
									locSigBlockingData->initBlockingExpansionData(sigBlockingData);
									blockingIndividualNode->setSignatureBlockingIndividualNodeConceptExpansionData(locSigBlockingData);
								}
								locSigBlockingData->setBlockingReviewMarked(false);
								locSigBlockingData->setBlockingSubsetReviewMarked(sigBlockingData->isConceptSetStillSubset());

								return true;
							}
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::updateSignatureBlockingConceptExpansion(CIndividualProcessNode*& blockingIndividualNode, CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockingData, CIndividualProcessNode*& blockerIndividualNode, CIndividualNodeAnalizedConceptExpansionData* blockerAnalizedConExpData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* blockingConSet = blockingIndividualNode->getReapplyConceptLabelSet(true);
					cint64 lastUpdatedConExpCount = sigBlockingData->getLastUpdatedConceptExpansionCount();

					bool updateDueChangedConcepts = blockingConSet->getConceptCount() != sigBlockingData->getLastUpdatedConceptCount();
					bool updateDueChangedExpansions = blockerAnalizedConExpData->getExpansionConceptCount() > lastUpdatedConExpCount;

					if (updateDueChangedConcepts || updateDueChangedExpansions) {
						bool retestAllExpansionsConcepts = true;
						if (lastUpdatedConExpCount > 0 && updateDueChangedExpansions && !updateDueChangedConcepts) {
							retestAllExpansionsConcepts = false;
						}
						cint64 continuousExpConConceptCount = sigBlockingData->getContinuousExpandedContainedConceptCount();
						CAnalizedConceptExpansionLinker* analizedConExpLinkerIt = blockerAnalizedConExpData->getReverseAnalizedConceptExpansionLinker();
						cint64 skipExpConCount = continuousExpConConceptCount;
						if (!retestAllExpansionsConcepts) {
							skipExpConCount = lastUpdatedConExpCount;
						}
						cint64 conExpSearchCount = blockerAnalizedConExpData->getExpansionConceptCount() - skipExpConCount;

						//for (cint64 i = 0; i < skipExpConCount; ++i) {
						//	analizedConExpLinkerIt = analizedConExpLinkerIt->getNext();
						//}
						cint64 updateContinuousExpandedContainedConceptCount = -1;
						if (!retestAllExpansionsConcepts && sigBlockingData->getContinuousExpandedContainedConceptCount() != sigBlockingData->getLastUpdatedConceptExpansionCount()) {
							updateContinuousExpandedContainedConceptCount = 0;
						}
						sigBlockingData->setLastUpdatedConceptExpansionCount(blockerAnalizedConExpData->getExpansionConceptCount());
						cint64 expandedContainedConceptCount = 0;

						if (sigBlockingData->isConceptSetStillSubset() && blockingConSet->getConceptCount() == blockerAnalizedConExpData->getLastConceptCount()) {
							// no expansion required
							sigBlockingData->setContinuousExpandedContainedConceptCount(blockerAnalizedConExpData->getExpansionConceptCount());
							sigBlockingData->setLastUpdatedConceptCount(blockingConSet->getConceptCount());
						} else {

							CPROCESSINGLIST<CAnalizedConceptExpansionLinker*> revAnalizedConExpList(calcAlgContext->getTaskProcessorContext());
							while (conExpSearchCount-- > 0 && analizedConExpLinkerIt) {
								revAnalizedConExpList.prepend(analizedConExpLinkerIt);
								analizedConExpLinkerIt = analizedConExpLinkerIt->getNext();
							}

							for (CPROCESSINGLIST<CAnalizedConceptExpansionLinker*>::const_iterator it = revAnalizedConExpList.constBegin(), itEnd = revAnalizedConExpList.constEnd(); it != itEnd; ++it) {
								CAnalizedConceptExpansionLinker* nextAnalizedConExpLinker = *it;
								CConceptDescriptor* expConDes = nextAnalizedConExpLinker->getConceptDescriptor();
								CConcept* expConcept = expConDes->getConcept();
								bool expConNegation = expConDes->getNegation();
								if (!blockingConSet->containsConcept(expConcept,expConNegation)) {

									bool allDependenciesExistings = true;
									CDependency* dependencies = nullptr;
									CDependencyTrackPoint* firstDepTrackPoint = nullptr;

									CXLinker<CConceptDescriptor*>* depLinker = nextAnalizedConExpLinker->getDependendConceptDescriptorLinker();
									CXLinker<CConceptDescriptor*>* depLinkerIt = depLinker;
									while (allDependenciesExistings && depLinkerIt) {
										CConceptDescriptor* depExpConDes = depLinkerIt->getData();
										cint64 depConTag = depExpConDes->getConceptTag();
										CConceptDescriptor* depConDes = nullptr;
										CDependencyTrackPoint* depDepTrackPoint = nullptr;
										if (blockingConSet->getConceptDescriptor(depConTag,depConDes,depDepTrackPoint)) {
											if (depConDes->isNegated() == depExpConDes->isNegated()) {
												KONCLUDE_ASSERT_X(depDepTrackPoint,"expandCachedConcepts","missing dependency");

												CCONNECTIONDependencyNode* connDepNode = createCONNECTIONDependency(blockingIndividualNode,depConDes,depDepTrackPoint,calcAlgContext);
												if (!firstDepTrackPoint) {
													firstDepTrackPoint = connDepNode;
												} else {
													dependencies = connDepNode->append(dependencies);
												}
											} else {
												allDependenciesExistings = false;
											}

										} else {
											allDependenciesExistings = false;
										}
										depLinkerIt = depLinkerIt->getNext();
									}

									if (allDependenciesExistings) {
										STATINC(SIGNATUREMIRRORINGBLOCKINGCONCEPTEXPANSIONCOUNT,calcAlgContext);
										KONCLUDE_ASSERT_X(firstDepTrackPoint,"expandCachedConcepts","missing dependency");

										CDependencyTrackPoint* expDepTrackPoint = nullptr;
										CEXPANDEDDependencyNode* expDepNode = createEXPANDEDDependency(expDepTrackPoint,blockingIndividualNode,firstDepTrackPoint,dependencies,calcAlgContext);

										addConceptToIndividualSkipANDProcessing(expConcept,expConNegation,blockingIndividualNode,expDepTrackPoint,true,false, true,calcAlgContext);
										++expandedContainedConceptCount;
									} else {
										if (updateContinuousExpandedContainedConceptCount < 0) {
											updateContinuousExpandedContainedConceptCount = expandedContainedConceptCount;
										}
									}
								} else {
									++expandedContainedConceptCount;
								}
							}
							if (updateContinuousExpandedContainedConceptCount < 0) {
								updateContinuousExpandedContainedConceptCount = expandedContainedConceptCount;
							}
							sigBlockingData->setContinuousExpandedContainedConceptCount(continuousExpConConceptCount+updateContinuousExpandedContainedConceptCount);
							sigBlockingData->setLastUpdatedConceptCount(blockingConSet->getConceptCount());
						}

						return true;

					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasCompatibleConceptSetSignature(CIndividualProcessNode*& blockingNode, CReapplyConceptLabelSet* conSet, CIndividualProcessNode* compatibleTestNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					// is conSet a compatible concept set to compatibleTestNode
					CReapplyConceptLabelSet* compTestConSet = compatibleTestNode->getReapplyConceptLabelSet(false);
					cint64 conCount = conSet->getConceptCount();
					cint64 compTestConCount = compTestConSet->getConceptCount();
					if (conCount <= 0 || compTestConCount < conCount) {
						return false;
					}
					cint64 diffCount = compTestConCount - conCount;
					CConceptDescriptor* compTestConDesIt = compTestConSet->getAddingSortedConceptDescriptionLinker();
					CConceptDescriptor* conDesIt = conSet->getAddingSortedConceptDescriptionLinker();
					while (diffCount-- > 0) {
						compTestConDesIt = compTestConDesIt->getNext();
					}
					bool orderingCompatible = true;
					while (orderingCompatible && conDesIt) {
						CConcept* concept = conDesIt->getConcept();
						bool conNeg = conDesIt->getNegation();
						if (compTestConDesIt->getData() == concept && compTestConDesIt->getNegation() == conNeg) {							
							if (isConceptSignatureBlockingCritical(blockingNode,conDesIt,conDesIt->getDependencyTrackPoint(),calcAlgContext)) {
								blockingNode->setInvalidSignatureBlocking(true);
								return false;
							}
							conDesIt = conDesIt->getNext();
							compTestConDesIt = compTestConDesIt->getNext();
						} else {
							orderingCompatible = false;
						}
					}
					if (!orderingCompatible) {
						while (conDesIt) {
							CConcept* concept = conDesIt->getConcept();
							bool conNeg = conDesIt->getNegation();
							if (isConceptSignatureBlockingCritical(blockingNode,conDesIt,conDesIt->getDependencyTrackPoint(),calcAlgContext)) {
								blockingNode->setInvalidSignatureBlocking(true);
								return false;
							}
							if (!conSet->containsConcept(concept,conNeg)) {
								return false;
							}
							conDesIt = conDesIt->getNext();
						}
					}
					return true;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::anlyzeIndiviudalNodesConceptExpansion(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CReapplyConceptLabelSet* conSet = individualNode->getReapplyConceptLabelSet(false);
					if (conSet) {
						CConceptDescriptor* lastAddedConDes = conSet->getAddingSortedConceptDescriptionLinker();
						CIndividualNodeAnalizedConceptExpansionData* anlConExpData = individualNode->getAnalizedConceptExpansionData(false);
						bool update = false;
						if (anlConExpData) {
							if (!anlConExpData->isInvalidBlocker()) {
								CConceptDescriptor* lastAnalyzedConDes = anlConExpData->getLastConceptDescriptor();
								if (lastAddedConDes != lastAnalyzedConDes) {
									update = true;
								}
							}
						} else {
							if (lastAddedConDes) {
								update = true;
							}
						}
						if (update) {
							cint64 conSignature = conSet->getConceptSignatureValue();
							cint64 conceptCount = conSet->getConceptCount();
							individualNode = getLocalizedIndividual(individualNode,false,calcAlgContext);
							CIndividualNodeAnalizedConceptExpansionData* locAnlConExpData = individualNode->getAnalizedConceptExpansionData(true);
							cint64 minValidConCount = locAnlConExpData->getMinimalValidConceptCountLimit();
							CConceptDescriptor* lastAnalizedConDes = locAnlConExpData->getLastConceptDescriptor();


							CAnalizedConceptExpansionLinker* lastAnaConExpLinker = nullptr;
							CAnalizedConceptExpansionLinker* firstAnaConExpLinker = nullptr;

							CConceptDescriptor* conDesIt = lastAddedConDes;
							cint64 currAnalizingCount = conceptCount;
							bool invalidBlocking = locAnlConExpData->isInvalidBlocker();
							CXLinker<CConceptDescriptor*>* nonDetConLinker = nullptr;
							while (conDesIt && conDesIt != lastAnalizedConDes && !invalidBlocking) {
								CConceptDescriptor* conDes = conDesIt;
								CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
								if (isConceptSignatureBlockingCritical(individualNode,conDes,depTrackPoint,calcAlgContext)) {
									invalidBlocking = true;
								} else {
									bool directDependentFlag = false;
									if (isConceptFromDirectOrPredecessorOrNondeterminismusDependent(individualNode,conDes,depTrackPoint,&directDependentFlag,calcAlgContext)) {
										if (!directDependentFlag) {
											// do not add to expansions concepts
											CXLinker<CConceptDescriptor*>* newNonDetConLinker = CObjectAllocator< CXLinker<CConceptDescriptor*> >::allocateAndConstruct(taskMemMan);
											newNonDetConLinker->initLinker(conDes);
											nonDetConLinker = newNonDetConLinker->append(nonDetConLinker);
										}
									} else {
										// try to find dependencies
										CXLinker<CConceptDescriptor*>* depLinker = nullptr;
										if (getConceptDependenciesToSameIndividualNode(individualNode,conDes,depTrackPoint,depLinker,calcAlgContext)) {
											CAnalizedConceptExpansionLinker* analizedConExpLinker = CObjectAllocator<CAnalizedConceptExpansionLinker>::allocateAndConstruct(taskMemMan);
											analizedConExpLinker->initAnalizedConceptExpansion(depLinker,conDes);		
											if (lastAnaConExpLinker) {
												lastAnaConExpLinker->setNext(analizedConExpLinker);
												lastAnaConExpLinker = analizedConExpLinker;
											} else {
												lastAnaConExpLinker = analizedConExpLinker;
												firstAnaConExpLinker = analizedConExpLinker;
											}
										} else {
											CXLinker<CConceptDescriptor*>* newNonDetConLinker = CObjectAllocator< CXLinker<CConceptDescriptor*> >::allocateAndConstruct(taskMemMan);
											newNonDetConLinker->initLinker(conDes);
											nonDetConLinker = newNonDetConLinker->append(nonDetConLinker);
										}
									}
								}
								conDesIt = conDesIt->getNextConceptDesciptor();
								--currAnalizingCount;
							}

							if (firstAnaConExpLinker) {
								locAnlConExpData->addAnalizedConceptExpansionLinker(firstAnaConExpLinker);
							}
							locAnlConExpData->addAnalysedNonDeterministicConceptExpansionLinker(nonDetConLinker);
							locAnlConExpData->setInvalidBlocker(invalidBlocking);

							locAnlConExpData->setLastConceptDescriptor(lastAddedConDes);
							locAnlConExpData->setLastConceptSignature(conSignature);
							locAnlConExpData->setLastConceptCount(conceptCount);
							return true;
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptSignatureBlockingCritical(CIndividualProcessNode*& individualNode, CConceptDescriptor* conDes, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConcept* concept = conDes->getConcept();
					bool conNeg = conDes->getNegation();
					cint64 opCode = concept->getOperatorCode();
					cint64 param = concept->getParameter();
					cint64 cardinality = concept->getParameter() + 1*conNeg;
					if (cardinality > 1 && (!conNeg && opCode == CCATMOST || conNeg && opCode == CCATLEAST)) {
						return true;
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptFromDirectOrPredecessorOrNondeterminismusDependent(CIndividualProcessNode*& individualNode, CConceptDescriptor* conDes, CDependencyTrackPoint* depTrackPoint, bool* directDependentFlag, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 ancDepth = individualNode->getIndividualAncestorDepth();
					bool dependencyToAncestor = false;
					CDependencyNode* depNode = depTrackPoint->getDependencyNode();
					if (!depTrackPoint->isPointingToDeterministicDependencyNode()) {
						dependencyToAncestor = true;
					} else {
						if (depTrackPoint->isPointingToIndependentDependencyNode()) {
							dependencyToAncestor = true;
						} else if (depNode->hasAppropriateIndividualNode()) {
							CIndividualProcessNode* appIndiNode = depNode->getAppropriateIndividualNode();
							cint64 appIndiAncDepth = appIndiNode->getIndividualAncestorDepth();
							if (appIndiAncDepth < ancDepth) {
								dependencyToAncestor = true;
							} else if (/*mConfDirectRulePreprocessing && */appIndiAncDepth == ancDepth) {
								dependencyToAncestor = !depNode->hasAdditionalDependencies();
								if (*directDependentFlag) {
									*directDependentFlag = true;
								}
							}
						} else {
							CDependencyNode::DEPENDENCNODEYTYPE depType = depNode->getDependencyType();
							if (depType == CDependencyNode::DNTMERGEDCONCEPT) {
								dependencyToAncestor = true;
							}
						}
					}
					return dependencyToAncestor;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::getConceptDependenciesToSameIndividualNode(CIndividualProcessNode*& individualNode, CConceptDescriptor* conDes, CDependencyTrackPoint* depTrackPoint, CXLinker<CConceptDescriptor*>*& depLinker, CCalculationAlgorithmContextBase* calcAlgContext) {					
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CDependencyNode* depNode = depTrackPoint->getDependencyNode();
					CConceptDescriptor* dependendConDes = depNode->getConceptDescriptor();

					bool simpleSameNodeDeps = false;
					if (depNode->hasAppropriateIndividualNode()) {
						CIndividualProcessNode* appIndiNode = depNode->getAppropriateIndividualNode();
						cint64 appIndiDepth = appIndiNode->getIndividualAncestorDepth();
						cint64 baseDepth = individualNode->getIndividualAncestorDepth();
						if (appIndiDepth == baseDepth) {
							simpleSameNodeDeps = true;
						}
					} else {
						simpleSameNodeDeps = true;
					}
					if (simpleSameNodeDeps) {
						if (!depTrackPoint->isPointingToIndependentDependencyNode()) {
							if (!dependendConDes || depNode->hasAdditionalDependencies()) {
								simpleSameNodeDeps = false;
							}
						}
					}

					if (simpleSameNodeDeps) {
						if (/*!mConfDirectRulePreprocessing*/true) {
							CXLinker<CConceptDescriptor*>* depedendConDesLinker = CObjectAllocator< CXLinker<CConceptDescriptor*> >::allocateAndConstruct(taskMemMan);
							depedendConDesLinker->initLinker(dependendConDes,depLinker);
							depLinker = depedendConDesLinker;
							return true;
						} else {
							return false;
						}
					} else {
						cint64 baseAncDepth = individualNode->getIndividualAncestorDepth();
						typedef QPair<cint64,CDependencyTrackPoint*> CDepthDependencyPair;
						CPROCESSINGSET<CDepthDependencyPair> depSet(calcAlgContext->getTaskProcessorContext());
						CPROCESSINGLIST<CDepthDependencyPair> depList(calcAlgContext->getTaskProcessorContext());
						depSet.insert(CDepthDependencyPair(baseAncDepth,depTrackPoint));
						depList.append(CDepthDependencyPair(baseAncDepth,depTrackPoint));


						while (!depList.isEmpty()) {
							CDepthDependencyPair depthDepPair(depList.takeFirst());
							cint64 ancDepth = depthDepPair.first;
							CDependencyTrackPoint* depTrackPoint = depthDepPair.second;

							if (!depTrackPoint->isPointingToDeterministicDependencyNode()) {
								return false;
							}

							CDependencyNode* depNode = depTrackPoint->getDependencyNode();
							CIndividualProcessNode* appIndiNode = depNode->getAppropriateIndividualNode();
							cint64 newAncDepth = ancDepth;
							bool continueDepLoading = true;
							if (appIndiNode) {
								newAncDepth = appIndiNode->getIndividualAncestorDepth();
							}
							if (newAncDepth == baseAncDepth) {
								CConceptDescriptor* nextConDes = depNode->getConceptDescriptor();
								if (nextConDes) {
									continueDepLoading = false;

									CXLinker<CConceptDescriptor*>* depedendConDesLinker = CObjectAllocator< CXLinker<CConceptDescriptor*> >::allocateAndConstruct(taskMemMan);
									depedendConDesLinker->initLinker(nextConDes,depLinker);
									depLinker = depedendConDesLinker;
								}
							}
							if (newAncDepth < baseAncDepth || depTrackPoint->isPointingToIndependentDependencyNode()) {
								return false;
							}
							if (continueDepLoading) {
								CDependencyTrackPoint* prevDepTrackPoint = depNode->getPreviousDependencyTrackPoint();
								cint64 nextAncDepth = newAncDepth;
								CDependencyNode* nextDepNode = prevDepTrackPoint->getDependencyNode();
								if (nextDepNode && nextDepNode->hasAppropriateIndividualNode()) {
									nextAncDepth = nextDepNode->getAppropriateIndividualNode()->getIndividualAncestorDepth();
								}
								if (!depSet.contains(CDepthDependencyPair(nextAncDepth,prevDepTrackPoint))) {
									depSet.insert(CDepthDependencyPair(nextAncDepth,prevDepTrackPoint));
									depList.append(CDepthDependencyPair(nextAncDepth,prevDepTrackPoint));
								}
							}

							CDependencyIterator depIt = depNode->getAdditionalDependencyIterator();
							while (depIt.hasNext()) {
								CDependency* dependency = depIt.nextDependency();
								// load additional dependencies
								CDependencyTrackPoint* prevDepTrackPoint = dependency->getPreviousDependencyTrackPoint();
								cint64 nextAncDepth = ancDepth;
								CDependencyNode* nextDepNode = prevDepTrackPoint->getDependencyNode();
								if (nextDepNode && nextDepNode->hasAppropriateIndividualNode()) {
									nextAncDepth = nextDepNode->getAppropriateIndividualNode()->getIndividualAncestorDepth();
								}
								if (!depSet.contains(CDepthDependencyPair(ancDepth,prevDepTrackPoint))) {
									depSet.insert(CDepthDependencyPair(ancDepth,prevDepTrackPoint));
									depList.append(CDepthDependencyPair(ancDepth,prevDepTrackPoint));
								}
							}
						}
						return true;
					}
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::reapplySatisfiableCachedAbsorbedDisjunctionConcepts(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool conceptsReapplyed = false;

					CConceptProcessingQueue* conProQueue = individualNode->getConceptProcessingQueue(true);
					CReapplyConceptDescriptor* absorbedReapplyConDesLinker = individualNode->getSatisfiableCachedAbsorbedDisjunctionsLinker();
					while (absorbedReapplyConDesLinker) {

						conceptsReapplyed = true;

						CConceptDescriptor* conDes = absorbedReapplyConDesLinker->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = absorbedReapplyConDesLinker->getDependencyTrackPoint();
						CProcessingRestrictionSpecification* procRest = absorbedReapplyConDesLinker->getReapplyProcessingRestriction();

						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,individualNode,absorbedReapplyConDesLinker->isStaticDescriptor(),procRest,calcAlgContext);

						absorbedReapplyConDesLinker = absorbedReapplyConDesLinker->getNext();
					}
					individualNode->clearSatisfiableCachedAbsorbedDisjunctionsLinker();

					return conceptsReapplyed;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::reapplySatisfiableCachedAbsorbedGeneratingConcepts(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool conceptsReapplyed = false;

					CConceptProcessingQueue* conProQueue = individualNode->getConceptProcessingQueue(true);
					CReapplyConceptDescriptor* absorbedReapplyConDesLinker = individualNode->getSatisfiableCachedAbsorbedGeneratingLinker();
					while (absorbedReapplyConDesLinker) {

						conceptsReapplyed = true;

						CConceptDescriptor* conDes = absorbedReapplyConDesLinker->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = absorbedReapplyConDesLinker->getDependencyTrackPoint();

						addConceptToProcessingQueue(conDes,depTrackPoint,conProQueue,individualNode,false,calcAlgContext);

						absorbedReapplyConDesLinker = absorbedReapplyConDesLinker->getNext();
					}
					individualNode->clearSatisfiableCachedAbsorbedGeneratingLinker();

					return conceptsReapplyed;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addSatisfiableCachedAbsorbedDisjunctionConcept(CConceptDescriptor *conceptDescriptor, CIndividualProcessNode*& processIndi, CProcessingRestrictionSpecification* procRest, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint,procRest);
					processIndi->addSatisfiableCachedAbsorbedDisjunctionsLinker(reapplyConDes);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addSatisfiableCachedAbsorbedGeneratingConcept(CConceptDescriptor *conceptDescriptor, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint);
					processIndi->addSatisfiableCachedAbsorbedGeneratingLinker(reapplyConDes);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndirectSuccessorSignatureBlocked(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingBlockedProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED,true,CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndirectSuccessorSatisfiableCached(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingBlockedProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED,true,CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndirectSuccessorReuseBlocked(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingBlockedProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFREUSINGINDIVIDUAL,true,CIndividualProcessNode::PRFANCESTORREUSINGINDIVIDUALBLOCKED,calcAlgContext);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isSatisfiableCachedAutomatConceptCompatible(CIndividualProcessNode*& individualNode, CConcept* concept, bool negated, CIndividualProcessNode* ancestorIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 opCode = concept->getOperatorCode();
					CConceptOperator* conOperator = concept->getConceptOperator();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();
					if (!negated && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQALL_TYPE))) {
						CRole* role = concept->getRole();
						CReapplyConceptLabelSet* ancConSet = ancestorIndiNode->getReapplyConceptLabelSet(false);
						if (individualNode->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
							if (!containsIndividualNodeConcepts(ancConSet,opConLinker,false,calcAlgContext)) {
								return false;
							}
						}
					} else if (!negated && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQAND_TYPE))) {
						CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker;
						while (opConLinkerIt) {
							CConcept* opCon = opConLinkerIt->getData();
							bool opNeg = opConLinkerIt->isNegated();
							if (!isSatisfiableCachedAutomatConceptCompatible(individualNode,opCon,opNeg,ancestorIndiNode,calcAlgContext)) {
								return false;
							}
							opConLinkerIt = opConLinkerIt->getNext();
						}
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isSatisfiableCachedCompatible(CIndividualProcessNode*& individualNode, CExpanderBranchedLinker* satBranchLinker, CIndividualProcessNode* ancestorIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (ancestorIndiNode) {
						CSuccessorRoleIterator ancRoleIt = individualNode->getSuccessorRoleIterator(ancestorIndiNode);
						if (!ancRoleIt.hasNext()) {
							return true;
						}
						CReapplyConceptLabelSet* ancConSet = ancestorIndiNode->getReapplyConceptLabelSet(false);
						CCACHINGLIST<CCacheValue>* cacheValueList = satBranchLinker->getCacheValueList();
						for (CCACHINGLIST<CCacheValue>::const_iterator it = cacheValueList->constBegin(), itEnd = cacheValueList->constEnd(); it != itEnd; ++it) {
							CCacheValue cacheValue(*it);
							CConcept* concept = (CConcept*)cacheValue.getIdentification();
							bool conceptNeg = cacheValue.getCacheValueIdentifier() == CCacheValue::CACHEVALTAGANDNEGATEDCONCEPT;

							CRole* role = concept->getRole();
							cint64 opCode = concept->getOperatorCode();
							CConceptOperator* conOperator = concept->getConceptOperator();
							CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();
							if (!conceptNeg && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_TYPE)) || conceptNeg && opCode == CCSOME) {
								bool operandNeg = opCode == CCSOME;
								if (individualNode->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
									if (!containsIndividualNodeConcepts(ancConSet,opConLinker,operandNeg,calcAlgContext)) {
										return false;
									}
								}
							} else if (!conceptNeg && opCode == CCATMOST || conceptNeg && opCode == CCATLEAST) {
								if (!opConLinker) {
									if (individualNode->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
										return false;
									}
								} else {
									if (individualNode->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
										if (!containsIndividualNodeConcepts(ancConSet,opConLinker,true,calcAlgContext)) {
											return false;
										}
									}
								}
							} else if (!conceptNeg && (opCode == CCSOME || opCode == CCATLEAST || opCode == CCAQSOME) || conceptNeg && (opCode == CCALL || opCode == CCATMOST)) {
								CRole* minSuperRole = nullptr;
								cint64 minSuperRoleCount = 0;
								CSortedNegLinker<CRole*>* superRoleIt = role->getIndirectSuperRoleList();
								while (superRoleIt) {
									CRole* superRole = superRoleIt->getData();
									cint64 superRoleCount = superRole->getIndirectSuperRoleList()->getCount();
									if (!minSuperRole || superRoleCount < minSuperRoleCount) {
										minSuperRoleCount = superRoleCount;
										minSuperRole = superRole;
									}
									superRoleIt = superRoleIt->getNext();
								}
								if (individualNode->hasRoleSuccessorToIndividual(minSuperRole,ancestorIndiNode,true)) {
									return false;
								}
							} else if (!conceptNeg && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQAND_AQALL_TYPE))) {
								if (!isSatisfiableCachedAutomatConceptCompatible(individualNode,concept,conceptNeg,ancestorIndiNode,calcAlgContext)) {
									return false;
								}
							}

						}
					}
					return true;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::expandCachedConcepts(CIndividualProcessNode*& individualNode, CSignatureSatisfiableExpanderCacheEntry* entry, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (entry) {
						CReapplyConceptLabelSet* conSet = individualNode->getReapplyConceptLabelSet(true);
						CMemoryAllocationManager* memMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
						CDependencyFactory* depFactory = calcAlgContext->getDependencyFactory();
						cint64 conSetCount = conSet->getConceptCount();
						cint64 expandCount = entry->getExpanderCacheValueCount();
						CExpanderCacheValueLinker* expLinker = entry->getExpanderCacheValueLinker();
						CCACHINGHASH<cint64,CExpanderCacheValueLinker*>* expTagHash = entry->getTagExpanderCacheValueHash();
						for (cint64 i = 0; i < conSetCount; ++i) {
							expLinker = expLinker->getNext();
						}
						CExpanderCacheValueLinker* expLinkerIt = expLinker;
						bool expanded = false;
						while (expLinkerIt) {

							CCacheValue* cacheValue = expLinkerIt->getCacheValue();
							CConcept* concept = (CConcept*)cacheValue->getIdentification();
							bool conceptNeg = cacheValue->getCacheValueIdentifier() == CCacheValue::CACHEVALTAGANDNEGATEDCONCEPT;

							if (!conSet->hasConcept(concept)) {

								STATINC(SATEXPCACHERETRIEVALEXPANDEDCONCEPTSCOUNT,calcAlgContext);
								if (!expanded) {
									STATINC(SATEXPCACHERETRIEVALFOUNDEXPANSIONCOUNT,calcAlgContext);
									expanded = true;
								}
								CDependency* dependencies = nullptr;
								CDependencyTrackPoint* firstDepTrackPoint = nullptr;
								CCACHINGLIST<CExpanderCacheValueLinker*>* depList = expLinkerIt->getExpanderDependencyList();
								for (CCACHINGLIST<CExpanderCacheValueLinker*>::const_iterator depIt = depList->constBegin(), depEndIt = depList->constEnd(); depIt != depEndIt; ++depIt) {
									CExpanderCacheValueLinker* depLinker(*depIt);
									cint64 depTag = depLinker->getCacheValue()->getTag();

									CDependencyTrackPoint* depTrackPoint = nullptr;
									CConceptDescriptor* depConDes = nullptr;
									conSet->getConceptDescriptor(depTag,depConDes,depTrackPoint);

									KONCLUDE_ASSERT_X(depTrackPoint,"expandCachedConcepts","missing dependency");

									CCONNECTIONDependencyNode* connDepNode = createCONNECTIONDependency(individualNode,depConDes,depTrackPoint,calcAlgContext);
									if (!firstDepTrackPoint) {
										firstDepTrackPoint = connDepNode;
									} else {
										dependencies = connDepNode->append(dependencies);
									}
								}

								KONCLUDE_ASSERT_X(firstDepTrackPoint,"expandCachedConcepts","missing dependency");

								CDependencyTrackPoint* expDepTrackPoint = nullptr;
								CEXPANDEDDependencyNode* expDepNode = createEXPANDEDDependency(expDepTrackPoint,individualNode,firstDepTrackPoint,dependencies,calcAlgContext);

								addConceptToIndividualSkipANDProcessing(concept,conceptNeg,individualNode,expDepTrackPoint,true,false, true,calcAlgContext);
							}

							expLinkerIt = expLinkerIt->getNext();
						}
					}				
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndirectReuseSuccessors(CIndividualProcessNode*& indi, bool recursive, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORREUSINGINDIVIDUALBLOCKED)) {

								if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORREUSINGINDIVIDUALBLOCKEDABOLISHED)) {
									CIndividualProcessNode* locIndiNode = getLocalizedIndividual(succIndi,false,calcAlgContext);
									locIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORREUSINGINDIVIDUALBLOCKEDABOLISHED);
								}
							}
						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndirectSignatureBlockedSuccessors(CIndividualProcessNode*& indi, bool recursive, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {

								if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHEDABOLISHED)) {
									CIndividualProcessNode* locIndiNode = getLocalizedIndividual(succIndi,false,calcAlgContext);
									locIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHEDABOLISHED);
									addIndividualToProcessingQueue(locIndiNode,calcAlgContext);
								}

							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndirectSatisfiableCachedSuccessors(CIndividualProcessNode*& indi, bool recursive, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {

								if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHEDABOLISHED)) {
									CIndividualProcessNode* locIndiNode = getLocalizedIndividual(succIndi,false,calcAlgContext);
									locIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHEDABOLISHED);
									addIndividualToProcessingQueue(locIndiNode,calcAlgContext);
								}

							}
						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndirectSaturationCachedSuccessors(CIndividualProcessNode*& indi, bool recursive, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {

								if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHEDABOLISHED)) {
									CIndividualProcessNode* locIndiNode = getLocalizedIndividual(succIndi,false,calcAlgContext);
									locIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHEDABOLISHED);
									addIndividualToProcessingQueue(locIndiNode,calcAlgContext);
								}

							}
						}
					}
				}

				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugTrackedClashedDescriptorSummaryString(CTrackedClashedDescriptor* trackedClashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString clashString;
					CTrackedClashedDescriptor* trackedClashDescriptorIt = trackedClashDescriptors;
					while (trackedClashDescriptorIt) {
						CConceptDescriptor* conDes = trackedClashDescriptorIt->getConceptDescriptor();
						QString conceptString("null");
						if (conDes) {
							conceptString = CConceptTextFormater::getConceptString(conDes->getConcept(),conDes->isNegated());
						}
						if (!clashString.isEmpty()) {
							clashString += QString(", ");
						}
						clashString += conceptString;
						trackedClashDescriptorIt = trackedClashDescriptorIt->getNextDescriptor();
					}
					return clashString;
				}


				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugTrackedClashedDescriptorString(CTrackedClashedDescriptor* trackedClashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString clashListString;
					CTrackedClashedDescriptor* trackedClashDescriptorIt = trackedClashDescriptors;
					while (trackedClashDescriptorIt) {
						CConceptDescriptor* conDes = trackedClashDescriptorIt->getConceptDescriptor();
						QString conceptString("null");
						if (conDes) {
							conceptString = CConceptTextFormater::getConceptString(conDes->getConcept(),conDes->isNegated());
						}

						CDependencyTrackPoint* depTrackPoint = trackedClashDescriptorIt->getDependencyTrackPoint();

						QString dependencyString = QString("null");
						if (depTrackPoint) {
							QString depTypeString;
							CDependencyNode* depNode = depTrackPoint->getDependencyNode();
							switch (depNode->getDependencyType()) {
								case CDependencyNode::DNTINDEPENDENTBASE: {
									depTypeString = QString("INDEPENDENT");
									break;
								}
								case CDependencyNode::DNTALLDEPENDENCY: {
									depTypeString = QString("ALL");
									break;
								}
								case CDependencyNode::DNTSOMEDEPENDENCY: {
									depTypeString = QString("SOME");
									break;
								}
								case CDependencyNode::DNTANDDEPENDENCY: {
									depTypeString = QString("AND");
									break;
								}
								case CDependencyNode::DNTORDEPENDENCY: {
									depTypeString = QString("OR");
									break;
								}
								case CDependencyNode::DNTATLEASTDEPENDENCY: {
									depTypeString = QString("ATLEAST");
									break;
								}
								case CDependencyNode::DNTAUTOMATCHOOSEDEPENDENCY: {
									depTypeString = QString("AUTOMATCHOOSE");
									break;
								}
								case CDependencyNode::DNTAUTOMATTRANSACTIONDEPENDENCY: {
									depTypeString = QString("AUTOMATTRANSACTION");
									break;
								}
								case CDependencyNode::DNTSELFDEPENDENCY: {
									depTypeString = QString("SELF");
									break;
								}
								case CDependencyNode::DNTVALUEDEPENDENCY: {
									depTypeString = QString("VALUE");
									break;
								}
								case CDependencyNode::DNTNEGVALUEDEPENDENCY: {
									depTypeString = QString("NEGVALUE");
									break;
								}
								case CDependencyNode::DNTDISTINCTDEPENDENCY: {
									depTypeString = QString("DISTINCT");
									break;
								}
								case CDependencyNode::DNTMERGEDCONCEPT: {
									depTypeString = QString("MERGEDCONCEPT");
									break;
								}
								case CDependencyNode::DNTMERGEDLINK: {
									depTypeString = QString("MERGEDLINK");
									break;
								}
								case CDependencyNode::DNTMERGEDEPENDENCY: {
									depTypeString = QString("MERGE");
									break;
								}
								case CDependencyNode::DNTATMOSTDEPENDENCY: {
									depTypeString = QString("ATMOST");
									break;
								}
								case CDependencyNode::DNTQUALIFYDEPENDENCY: {
									depTypeString = QString("QUALIFY");
									break;
								}
								case CDependencyNode::DNTFUNCTIONALDEPENDENCY: {
									depTypeString = QString("FUNCTIONAL");
									break;
								}
								case CDependencyNode::DNTNOMINALDEPENDENCY: {
									depTypeString = QString("NOMINAL");
									break;
								}
								case CDependencyNode::DNTIMPLICATIONDEPENDENCY: {
									depTypeString = QString("IMPLICATION");
									break;
								}
								case CDependencyNode::DNTEXPANDEDDEPENDENCY: {
									depTypeString = QString("EXPANDED");
									break;
								}
								case CDependencyNode::DNTDATATYPETRIGGERDEPENDENCY: {
									depTypeString = QString("DATATYPETRIGGER");
									break;
								}

							}

							CConceptDescriptor* depNodeConDes = depNode->getConceptDescriptor();
							QString conceptDepNodeString("null"); 
							if (depNodeConDes) {
								conceptDepNodeString = CConceptTextFormater::getConceptString(depNodeConDes->getConcept(),depNodeConDes->isNegated());
							}
							QString depInfoString;
							if (depNode->isNonDeterministiDependencyNode()) {
								CNonDeterministicDependencyNode* nonDetDepNode = (CNonDeterministicDependencyNode*)depNode;
								depInfoString += QString(" NonDetDep, <%1/%2>").arg(nonDetDepNode->getOpenedDependencyTrackingPointsCount()).arg(nonDetDepNode->getBranchTrackPoints()->getCount());
							}
							depInfoString += QString(" + ...(%1)").arg(depNode->getAdditionalDependencyCount());
							dependencyString = QString("%1-Dependency: {%2}%3").arg(depTypeString).arg(conceptDepNodeString).arg(depInfoString);
						}

						QString clashString = QString("\t[ID:%1 / L:%2 | B:%3]: {%4}  -->  %5\r\n").arg(trackedClashDescriptorIt->getAppropriatedIndividualID()).arg(trackedClashDescriptorIt->getAppropriatedIndividualLevel()).arg(trackedClashDescriptorIt->getBranchingLevelTag()).arg(conceptString).arg(dependencyString);

						clashListString += clashString;

						trackedClashDescriptorIt = trackedClashDescriptorIt->getNextDescriptor();
					}
					clashListString.replace("\r\n","<br>");
					return clashListString;
				}




				QString CCalculationTableauCompletionTaskHandleAlgorithm::writeDebugTrackingLineStringToFile(const QString& debugDataString, const QString& fileNameString, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString tmpDebugDataString = debugDataString;
					QFile file(QString("./Debugging/CompletionTasks/backtrack-task-%1-%2-%3.txt").arg(calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskDepth()).arg(calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskID()).arg(fileNameString));
					if (file.open(QIODevice::WriteOnly)) {
						file.write(tmpDebugDataString.replace("<br>","\r\n").toLocal8Bit());
						file.close();
					}

					QFile conFile(QString("./Debugging/CompletionTasks/backtrack-task-%1-%2-continued.txt").arg(calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskDepth()).arg(calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskID()));
					if (conFile.open(QIODevice::Append)) {
						conFile.write((QString("\r\nBacktracking %1:\r\n*******************************************************\r\n").arg(fileNameString)).toLocal8Bit());
						conFile.write(tmpDebugDataString.replace("<br>", "\r\n").toLocal8Bit());
						conFile.write("\r\n\r\n");
						conFile.close();
					}
					return debugDataString;
				}




				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugTrackingLineString(CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString trackLineString = QString("branching level: %1, individual node level: %2\r\n").arg(trackingLine->getBranchingLevel()).arg(trackingLine->getIndividualNodeLevel());

					CTrackedClashedDescriptor* trackedClashDescriptors = nullptr;
					
					trackedClashDescriptors = trackingLine->getIndependentTrackedClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, independent\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext));
					
					trackedClashDescriptors = trackingLine->getLevelTrackedBranchingClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, current branching level %2, current individual node level %3\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext)).arg(trackingLine->getBranchingLevel()).arg(trackingLine->getIndividualNodeLevel());
					
					trackedClashDescriptors = trackingLine->getLevelTrackedClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, current individual node level %3\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext)).arg(trackingLine->getIndividualNodeLevel());
					
					trackedClashDescriptors = trackingLine->getPerviousLevelTrackedClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, previous individual node levels, not non-deterministic\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext));
					
					trackedClashDescriptors = trackingLine->getPerviousLevelTrackedNonDeterministicBranchingClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, previous individual node levels, non-deterministic current branching level %2\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext)).arg(trackingLine->getBranchingLevel());
					
					trackedClashDescriptors = trackingLine->getPerviousLevelTrackedNonDeterministicClashedDescriptors();
					trackLineString += QString("\r\n$ tracked clashes, previous individual node levels, non-deterministic, not current branching level\r\n%1").arg(generateDebugTrackedClashedDescriptorString(trackedClashDescriptors,calcAlgContext));

					trackLineString.replace("\r\n","<br>");

					return trackLineString;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::clashedBacktracking(CClashedDependencyDescriptor* clashes, CCalculationAlgorithmContextBase* calcAlgContext) {

					calcAlgContext->getProcessingDataBox()->setClashedDescriptorLinker(clashes);

					//if (!mConfDependencyBackjumping) {
					//	if (!calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableCalculationTaskResult()->hasResult()) {
					//		calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableCalculationTaskResult()->installResult(false);
					//	}
					//	return;

					//}



					


					KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(mTimerBacktracing.start());

					//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList("./Debugging/CompletionTasks/backtracking.txt", calcAlgContext);

					STATINC(CLASHEDBACKTRACKINGSTARTCOUNT,calcAlgContext);
					CMemoryAllocationManager* tmpMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
					CTrackedClashedDescriptor* trackedClashDescriptors = createTrackedClashesDescriptors(clashes,calcAlgContext);

					
					KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
						if (mBacktrackDebug) {
							mBeginBacktrackingClashString = generateDebugTrackedClashedDescriptorSummaryString(trackedClashDescriptors,calcAlgContext);
						}
					)

					for (CTrackedClashedDescriptor* trackedClashDesIt = trackedClashDescriptors; trackedClashDesIt; trackedClashDesIt = trackedClashDesIt->getNextDescriptor()) {
						if (trackedClashDesIt->getAppropriatedIndividualID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
							trackIndividualExtendedDependence(trackedClashDesIt->getAppropriatedIndividualID(),calcAlgContext);
						}
					}


					CPROCESSINGSET<CTrackedClashedDescriptorHasher> clashedSet(calcAlgContext->getUsedTaskProcessorContext());
					CTrackedClashedDependencyLine trackingLine(&clashedSet);


					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getProcessingDataBox()->getBackendNeighbourExpansionControllingData(false);
					if (expContData && expContData->isFixedReuseExpansionMode()) {
						CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
						CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
						CPROCESSINGSET<cint64>* involvedIndividualSet = CObjectParameterizingAllocator<CPROCESSINGSET<cint64>, CProcessContext*>::allocateAndConstructAndParameterize(taskMemMan, processContext);
						trackingLine.setInvolvedIndividualTrackingSet(involvedIndividualSet);


						//LOG(INFO, "::Konclude::Reasoner::Kernel::Algorithm::TableauCompletionAlgorihm", logTr("Fixed reuse branch backtracked."), this);

					}

					if (initializeTrackingLine(&trackingLine,trackedClashDescriptors,calcAlgContext)) {

						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mBeginBacktrackingTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(&trackingLine,calcAlgContext),"begin",&trackingLine,calcAlgContext);
							}
						)

						if (trackingLine.getBranchingLevel() == 0) {
							// jump back to root task / cancellation
							cancellationRootTask(calcAlgContext);
						}

						if (trackingLine.hasOnlyCurrentIndividualNodeLevelClashesDescriptors()) {
							writeClashDescriptorsToCache(&trackingLine,calcAlgContext);
						}

						backtrackFromTrackingLine(&trackingLine,calcAlgContext);

						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mEndBacktrackingTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(&trackingLine,calcAlgContext),"end",&trackingLine,calcAlgContext);
							}
						)
					}

					KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(
						cint64 timeElapsed = mTimerBacktracing.elapsed();
						STATINCM(TIMEBACKTRACING,timeElapsed,calcAlgContext);
					);

				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::rootUnsatisfiabilityWriteCaches(CSatisfiableCalculationTask* task, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableTaskClassificationMessageAdapter* adapter = task->getClassificationMessageAdapter();
					if (adapter) {
						CConcept* concept = adapter->getTestingConcept();
						if (concept && adapter->hasExtractionFlags(CSatisfiableTaskClassificationMessageAdapter::EFEXTRACTSUBSUMERSROOTNODE)) {
							CUnsatisfiableCacheHandler* unsatCacheHandler = calcAlgContext->getUsedUnsatisfiableCacheHandler();
							if (unsatCacheHandler && mConfTestedConceptWriteUnsatCaching) {
								unsatCacheHandler->writeUnsatisfiableClashedConcept(concept,calcAlgContext);
							}

							CSaturationNodeExpansionCacheHandler* satNodeExpanderCacheHandler = calcAlgContext->getUsedSaturationNodeExpansionCacheHandler();
							if (satNodeExpanderCacheHandler && mConfSaturationConceptUnsatisfiabilitySaturatedCacheWriting) {
								satNodeExpanderCacheHandler->cacheUnsatisfiableConcept(concept,calcAlgContext);
							}

						}
					}
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CIndividualProcessNode* constIndiNode = processingDataBox->getConstructedIndividualNode();
					if (!processingDataBox->hasMultipleConstructionIndividualNodes() && constIndiNode && constIndiNode->isNominalIndividualNode()) {
						CXSortedNegLinker<CConcept*>* initConLinker = constIndiNode->getInitializingConceptLinker();
						CIndividual* individual = constIndiNode->getNominalIndividual();
						if (initConLinker && !initConLinker->hasNext()) {
							CConcept* initConcept = initConLinker->getData();
							bool conNegation = initConLinker->isNegated();

							if (mConfCacheComputedConsequences && mCompConsCacheHandler && initConcept->getTerminology()) {
								mCompConsCacheHandler->tryCacheTypeConcept(individual,initConcept,!conNegation,calcAlgContext);
							}
						}
					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::cancellationRootTask(CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableCalculationTask* rootTask = (CSatisfiableCalculationTask*)calcAlgContext->getSatisfiableCalculationTask()->getRootTask();
					STATINC(TASKROOTBACKJUMPINGCOUNT,calcAlgContext);
					STATINC(ROOTTASKUNSATISFIABLECOUNT,calcAlgContext);


					rootUnsatisfiabilityWriteCaches(rootTask,calcAlgContext);

					//bool xDebug = false;
					//if (xDebug) {
					//	mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//	QFile file(QString("./Debugging/CompletionTasks/task-root-clashed.txt"));
					//	if (file.open(QIODevice::WriteOnly)) {
					//		file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
					//		file.close();
					//	}
					//}

					//mBranchLevelClosedCountString.clear();
					//cint64 maxBraLevel = mClosedBranchLevelCountHash.size();
					//cint64 foundLevel = 0;
					//for (cint64 i = 0; foundLevel < maxBraLevel; ++i) {
					//	cint64 levelCount = mClosedBranchLevelCountHash.value(i,0);
					//	if (levelCount > 0) {
					//		++foundLevel;
					//	}
					//	mBranchLevelClosedCountString += QString("%1: %2\n").arg(i).arg(levelCount);
					//}

					return cancellationTask(rootTask,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::cancellationTask(CSatisfiableCalculationTask* task, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!task->getSatisfiableCalculationTaskResult()->hasResult()) {
						task->getSatisfiableCalculationTaskResult()->installResult(false);
						if (mConfDependencyBackjumping) {
							STATINC(TASKBACKJUMPINGCOUNT,calcAlgContext);
							if (calcAlgContext->getUsedSatisfiableCalculationTask() != task) {
								STATINC(TASKAWAYBACKJUMPINGCOUNT,calcAlgContext);
							}
							CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
							processorContext->getTaskProcessorCommunicator()->communicateTaskStatusUpdate(task);
							return true;
						}
					}
					return false;
				}


				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::getFreeTrackedClashedDescriptor(CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					CTrackedClashedDescriptor* des = trackingLine->takeNextFreeTrackedClashedDescriptor();
					if (!des) {
						CMemoryAllocationManager* tmpMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
						des = CObjectAllocator< CTrackedClashedDescriptor >::allocateAndConstruct(tmpMemMan);
					}
					return des;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackFromTrackingLine(CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 backtrackStep = 0;
					while (backtrackFromTrackingLineStep(trackingLine,calcAlgContext)) {
						// until backtracking failed
						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mFileBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine,calcAlgContext),QString("step-%1").arg(backtrackStep++),trackingLine,calcAlgContext);
							}
						)
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackFromTrackingLineStep(CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool trackingSuccess = true;
					bool prevLevelBacktracked = false;
					STATINC(CLASHEDBACKTRACKINGSTEPSCOUNT,calcAlgContext);

					KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
						if (mBacktrackDebug) {
							mBeginBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-begin", trackingLine, calcAlgContext);
						}
					)

					// step 1: backtrack all deterministic dependencies in previous individual node levels
					while (trackingLine->hasPerviousLevelTrackedClashedDescriptors() && trackingSuccess) {
						CTrackedClashedDescriptor* trackedClashedDes = trackingLine->takeNextPerviousLevelTrackedClashedDescriptor();
						STATINC(CLASHEDBACKTRACKINGPREVNODELEVELCOUNT,calcAlgContext);

						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mBeginDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-det-prev-indi-levels-begin", trackingLine, calcAlgContext);
							}
						)
						trackingSuccess &= backtrackDeterministicClashedDescriptorFromPreviousIndividualNodeLevels(trackedClashedDes,trackingLine,calcAlgContext);
						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mEndDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-det-prev-indi-levels-end", trackingLine, calcAlgContext);
							}
						)
					
						prevLevelBacktracked = true;
					}
					if (prevLevelBacktracked) {
						if (trackingLine->hasOnlyCurrentIndividualNodeLevelClashesDescriptors()) {
							// write clashes to cache
							writeClashDescriptorsToCache(trackingLine,calcAlgContext);
						}
					}
					// step 2: backtrack non-deterministic dependencies in previous individual node levels with current branching level
					if (trackingLine->hasPerviousLevelTrackedNonDeterministicBranchingClashedDescriptors()) {
						CTrackedClashedDescriptor* trackedClashedDes = trackingLine->takeNextPerviousLevelTrackedNonDeterministicBranchingClashedDescriptor();
						STATINC(CLASHEDBACKTRACKINGPREVNODELEVELBRANCHCOUNT,calcAlgContext);

						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mBeginNonDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-prev-levels-non-det-begin", trackingLine, calcAlgContext);
							}
						)
						trackingSuccess &= backtrackNonDeterministicBranchingClashedDescriptorFromPreviousIndividualNodeLevel(trackedClashedDes,trackingLine,calcAlgContext);
						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mEndNonDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-prev-levels-non-det-end", trackingLine, calcAlgContext);
							}
						)
					
					} else
					// step 3: backtrack to next individual node level
					if (trackingLine->hasLevelTrackedBranchingClashedDescriptors()) {
						CTrackedClashedDescriptor* trackedClashedDes = trackingLine->takeNextLevelTrackedBranchingClashedDescriptor();
						STATINC(CLASHEDBACKTRACKINGCURRNODELEVELBRANCHCOUNT,calcAlgContext);
						if (trackedClashedDes->isPointingToNonDeterministicDependencyNode()) {

							KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
								if (mBacktrackDebug) {
									mBeginNonDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-next-indi-level-begin", trackingLine, calcAlgContext);
								}
							)
							trackingSuccess &= backtrackNonDeterministicBranchingClashedDescriptorFromCurrentIndividualNodeLevel(trackedClashedDes,trackingLine,calcAlgContext);
							KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
								if (mBacktrackDebug) {
									mEndNonDetPrevBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-next-indi-level-end", trackingLine, calcAlgContext);
								}
							)
						
						} else {
							trackingSuccess &= backtrackDeterministicBranchingClashedDescriptorFromCurrentIndividualNodeLevel(trackedClashedDes,trackingLine,calcAlgContext);
						}
					} else {
						// check all dependencies independent
						if (trackingLine->hasOnlyIndependentTrackedClashedDescriptorsRemaining()) {
							STATINC(CLASHEDBACKTRACKINGINDEPENDENTCOUNT,calcAlgContext);
							// caching
							writeClashDescriptorsToCache(trackingLine,calcAlgContext);
							// no more tracking
							trackingSuccess = false;
						} else {

							// something failed, should never happen
							trackingSuccess = false;
						}
					}

					KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
						if (mBacktrackDebug) {
							mEndBacktrackingStepTracklineString = writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(trackingLine, calcAlgContext), "line-step-end", trackingLine, calcAlgContext);
						}
					)

					return trackingSuccess;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackNonDeterministicBranchingClashedDescriptorFromCurrentIndividualNodeLevel(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					return backtrackNonDeterministicBranchingClashedDescriptor(trackedClashedDes,trackingLine,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackNonDeterministicBranchingClashedDescriptorFromPreviousIndividualNodeLevel(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					return backtrackNonDeterministicBranchingClashedDescriptor(trackedClashedDes,trackingLine,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackNonDeterministicBranchingClashedDescriptor(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(CLASHEDBACKTRACKGNONDETERMINISTICCOUNT,calcAlgContext);
					CDependencyTrackPoint* depTrackPoint = trackedClashedDes->getDependencyTrackPoint();
					CNonDeterministicDependencyTrackPoint* nonDetDepTrackPoint = (CNonDeterministicDependencyTrackPoint*)depTrackPoint;
					CNonDeterministicDependencyNode* nonDetDependencyNode = (CNonDeterministicDependencyNode*)nonDetDepTrackPoint->getDependencyNode();

					CSatisfiableCalculationTask* nonDetAccTask = nonDetDependencyNode->getBranchNode()->getSatisfiableCalculationTask();
					CSatisfiableCalculationTask* branchAccTask = nonDetDepTrackPoint->getBranchNode()->getSatisfiableCalculationTask();



					cancellationTask(branchAccTask,calcAlgContext);

					//cint64 branchDiff = calcAlgContext->getSatisfiableCalculationTask()->getProcessingDataBox()->getProcessContext()->getProcessTagger()->getCurrentBranchingTag() - branchAccTask->getProcessingDataBox()->getProcessContext()->getProcessTagger()->getCurrentBranchingTag();
					//if (branchDiff > 0) {
					//	mOverJumpedNonDeterministicDecisionCount += branchDiff;
					//}

					if (nonDetDepTrackPoint->isClashedOrIrelevantBranch()) {
						// perhaps clash set by another thread
						STATINC(CLASHEDBACKTRACKGNONDETALREADYCLASHFAILEDCOUNT,calcAlgContext);
						return false;
					}

					CMemoryTemporaryAllocationManager* tmpMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
					CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();



					KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
						if (mBacktrackDebug) {
							mNonDetDependencyTrackPointReasonString = generateDebugTrackedClashedDescriptorString(trackedClashedDes,calcAlgContext);
						}
					)


					cint64 procTag = nonDetDependencyNode->getProcessingTag();
					// backtrack all clashes before the processing tag of the non-deterministic dependency for current branch
					CTrackedClashedDescriptor* trackedClashedDescriptorBeforeProcTagList = nullptr;
					while (trackingLine->hasMoreTrackedClashedList()) {
						CTrackedClashedDescriptor* trackedClashedDesList = trackingLine->takeNextTrackedClashedList();
						CTrackedClashedDescriptor* trackedClashedDescriptorsBeforeProcTag = getBacktrackedDeterministicClashedDescriptorsBeforeProcessingTag(trackedClashedDesList,procTag,trackingLine,calcAlgContext);
						if (trackedClashedDescriptorsBeforeProcTag) {
							trackedClashedDescriptorBeforeProcTagList = trackedClashedDescriptorsBeforeProcTag->append(trackedClashedDescriptorBeforeProcTagList);
						}
					}

					KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
						if (mBacktrackDebug) {
							mNonDetDependencyBeforeProcessedTrackedString = generateDebugTrackedClashedDescriptorString(trackedClashedDescriptorBeforeProcTagList,calcAlgContext);
						}
					)


					writeClashDescriptorsToCache(trackedClashedDescriptorBeforeProcTagList,trackedClashedDes,trackingLine,calcAlgContext);




					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(false);
					if (expContData && expContData->isFixedReuseExpansionMode()) {
						CREUSEBACKENDEXPANSIONMODESDependencyNode* modesDepNode = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true)->getReuseModesDependencyNode();

						if (nonDetDependencyNode->getDependencyType() == Process::Dependency::CDependencyNode::DNTREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDEPENDENCY) {
							CREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependencyNode* reuseFixedIndiExpDepNode = (CREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependencyNode*)nonDetDependencyNode;
							CIndividualProcessNode* reuseIndiNode = reuseFixedIndiExpDepNode->getAppropriateIndividualNode();
							trackingLine->addInvolvedIndividual(reuseIndiNode);
						}


						CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
						CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
						CPROCESSINGSET<cint64>* existingInvolvedIndiSet = CObjectParameterizingAllocator<CPROCESSINGSET<cint64>, CProcessContext*>::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(), processContext);
						CXLinker<cint64>* existingIndiLinker = modesDepNode->getAffectedIndividualIdLinker();
						for (CXLinker<cint64>* existingIndiLinkerIt = existingIndiLinker; existingIndiLinkerIt; existingIndiLinkerIt = existingIndiLinkerIt->getNext()) {
							cint64 indiId = existingIndiLinkerIt->getData();
							existingInvolvedIndiSet->insert(indiId);
						}

						CMemoryPoolContainer memoryContainer;
						CTaskMemoryPoolAllocationManager invIndiBranchMemMan(&memoryContainer, calcAlgContext->getTemporaryMemoryAllocationManager());
						CXLinker<cint64>* newInvolvedIndiLinker = existingIndiLinker;
						bool foundNewInvolvedIndis = false;
						CPROCESSINGSET<cint64>* involvedIndiSet = trackingLine->getInvolvedIndividualTrackingSet();
						if (involvedIndiSet) {
							for (CPROCESSINGSET<cint64>::const_iterator it = involvedIndiSet->constBegin(), itEnd = involvedIndiSet->constEnd(); it != itEnd; ++it) {
								cint64 indiId = *it;
								if (!existingInvolvedIndiSet->contains(indiId)) {
									CXLinker<cint64>* tmpInvolvedIndiLinker = CObjectAllocator<CXLinker<cint64>>::allocateAndConstruct(&invIndiBranchMemMan);
									tmpInvolvedIndiLinker->initLinker(indiId, newInvolvedIndiLinker);
									newInvolvedIndiLinker = tmpInvolvedIndiLinker;
									foundNewInvolvedIndis = true;
								}
							}
						}

						if (foundNewInvolvedIndis) {
							if (modesDepNode->addAffectedIndividualIdLinker(existingIndiLinker, newInvolvedIndiLinker)) {
								processorContext->getTaskProcessorCommunicator()->communicateTaskAdditionalAllocation(modesDepNode->getBranchNode()->getSatisfiableCalculationTask(), memoryContainer.takeMemoryPools());
							} else {
								calcAlgContext->getTemporaryMemoryAllocationManager()->releaseMemoryPoolContainer(&memoryContainer);
							}
						} else {
							calcAlgContext->getTemporaryMemoryAllocationManager()->releaseMemoryPoolContainer(&memoryContainer);
						}
					}






					// copy clashes to memory container
					CMemoryPoolContainer memoryContainer;
					CTaskMemoryPoolAllocationManager conBranchMemMan(&memoryContainer,calcAlgContext->getTemporaryMemoryAllocationManager());



					CXLinker<cint64>* newInvolvedIndiLinker = nullptr;
					CPROCESSINGSET<cint64>* involvedIndiSet = trackingLine->getInvolvedIndividualTrackingSet();
					if (involvedIndiSet) {
						for (CPROCESSINGSET<cint64>::const_iterator it = involvedIndiSet->constBegin(), itEnd = involvedIndiSet->constEnd(); it != itEnd; ++it) {
							cint64 indiId = *it;
							CXLinker<cint64>* tmpInvolvedIndiLinker = CObjectAllocator<CXLinker<cint64>>::allocateAndConstruct(&conBranchMemMan);
							tmpInvolvedIndiLinker->initLinker(indiId, newInvolvedIndiLinker);
							newInvolvedIndiLinker = tmpInvolvedIndiLinker;
						}
					}



					if (expContData && expContData->isFixedReuseExpansionMode() && nonDetDependencyNode->getDependencyType() == Process::Dependency::CDependencyNode::DNTREUSEBACKENDEXPANSIONMODESDEPENDENCY) {
						// prepare reporting of problematic individuals to backend cache

						CREUSEBACKENDEXPANSIONMODESDependencyNode* modesDepNode = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true)->getReuseModesDependencyNode();
						modesDepNode->setInvolvedIndividualIdLinker(newInvolvedIndiLinker);

						processorContext->getTaskProcessorCommunicator()->communicateTaskAdditionalAllocation(nonDetAccTask, memoryContainer.takeMemoryPools());
						return false;
					}


					// create branch clash descriptors with memory pool which will sent to corresponding task, because other threads could be using the clash descriptors after installation
					CTrackedClashedDescriptor* branchMemConClashedDesList = createTrackedClashesDescriptors(trackedClashedDescriptorBeforeProcTagList, calcAlgContext, &conBranchMemMan, true);


					if (nonDetDepTrackPoint->isClashedOrIrelevantBranch()) {
						// perhaps clash set by another thread, release memory pools
						calcAlgContext->getTemporaryMemoryAllocationManager()->releaseMemoryPoolContainer(&memoryContainer);
						STATINC(CLASHEDBACKTRACKGNONDETALREADYCLASHFAILEDCOUNT,calcAlgContext);
						return false;
					}
					// otherwise install clash descriptors
					nonDetDepTrackPoint->setClashes(branchMemConClashedDesList,true);
					if (newInvolvedIndiLinker) {
						nonDetDepTrackPoint->setInvolvedIndividualIdsLinker(newInvolvedIndiLinker);
					}




					if (mConfBranchingStatisticsAnalysing) {
						if (nonDetDependencyNode->getDependencyType() == CDependencyNode::DNTORDEPENDENCY) {
							CORDisjunctDependencyTrackPoint* orDisjunctDepTrackPoint = (CORDisjunctDependencyTrackPoint*)nonDetDepTrackPoint;
							CDisjunctBranchingStatistics* disjunctBranchStats = orDisjunctDepTrackPoint->getDisjunctBranchingStatistics();
							if (disjunctBranchStats) {
								disjunctBranchStats->incExpandedCount();
								disjunctBranchStats->incClashInvolvedCount();
							}
						}
						if (!mLastAnalysingBranchNodeTree) {
							mLastAnalysingBranchNodeTree = calcAlgContext->getUsedBranchTreeNode();
						}
						while (mLastAnalysingBranchNodeTree && mLastAnalysingBranchNodeTree != nonDetDepTrackPoint->getBranchNode()) {
							CDependencyTrackPoint* analDepTrackPoint = mLastAnalysingBranchNodeTree->getDependencyTrackPoint();
							if (analDepTrackPoint) {
								CDependencyNode* analDepNode = analDepTrackPoint->getDependencyNode();
								if (analDepNode->getDependencyType() == CDependencyNode::DNTORDEPENDENCY) {
									CORDisjunctDependencyTrackPoint* orDisjunctAnalDepTrackPoint = (CORDisjunctDependencyTrackPoint*)analDepTrackPoint;
									CDisjunctBranchingStatistics* analDisjunctBranchStats = orDisjunctAnalDepTrackPoint->getDisjunctBranchingStatistics();
									if (analDisjunctBranchStats) {
										analDisjunctBranchStats->incExpandedCount();
									}
								}
								CConceptDescriptor* analOrConDes = analDepNode->getConceptDescriptor();
								if (analOrConDes) {
									CConcept* analOrConcept = analOrConDes->getConcept();
									CConceptProcessData* analConProData = (CConceptProcessData*)analOrConcept->getConceptData();
									if (analConProData) {
										CDisjunctionBranchingStatistics* analDisjunctionBranchStatistics = (CDisjunctionBranchingStatistics*)analConProData->getBranchingStatistics();
										if (analDisjunctionBranchStatistics) {
											analDisjunctionBranchStatistics->incExpandedCount();
										}
									}
								}

							}
							mLastAnalysingBranchNodeTree = mLastAnalysingBranchNodeTree->getParentNode();
						}
					}


					if (trackedClashedDescriptorBeforeProcTagList) {
						// and send memory pools to corresponding task
						processorContext->getTaskProcessorCommunicator()->communicateTaskAdditionalAllocation(nonDetAccTask,memoryContainer.takeMemoryPools());
					}


					// test whether all branches has clash descriptors
					bool otherOpenedTrackPoints = nonDetDependencyNode->hasOtherOpenedDependencyTrackingPoints(nonDetDepTrackPoint);
					if (!otherOpenedTrackPoints) {

						if (mConfBranchingStatisticsAnalysing && nonDetDependencyNode->getDependencyType() == CDependencyNode::DNTORDEPENDENCY) {
							CConceptDescriptor* orConDes = nonDetDependencyNode->getConceptDescriptor();
							if (orConDes) {
								CConcept* orConcept = orConDes->getConcept();
								CConceptProcessData* conProData = (CConceptProcessData*)orConcept->getConceptData();
								if (conProData) {
									CDisjunctionBranchingStatistics* branchingStatistics = (CDisjunctionBranchingStatistics*)conProData->getBranchingStatistics();
									if (branchingStatistics) {
										branchingStatistics->incExpandedCount();
										branchingStatistics->incClashFullyInvolvedCount();
									}
								}
							}
						}

						++mRelevantNonDeterministicDecisionCount;

						// collect clash descriptors of all branches and add dependency of closed dependency node
						STATINC(CLASHEDBACKTRACKGNONDETCLOSEDCOUNT,calcAlgContext);
						CTrackedClashedDescriptor* collectedTrackedClashedDes = getCollectedFilteredClashedDescriptorsFromBranch(trackedClashedDes,nonDetDependencyNode,trackingLine,calcAlgContext);
						
						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mNonDetDependencyCollectedTrackedString = generateDebugTrackedClashedDescriptorString(collectedTrackedClashedDes,calcAlgContext);
							}
						)

						
						if (initializeTrackingLine(trackingLine,collectedTrackedClashedDes,calcAlgContext)) {
							if (trackingLine->getBranchingLevel() == 0) {
								// jump back to root task / cancellation
								cancellationRootTask(calcAlgContext);
							}

							if (trackingLine->hasOnlyCurrentIndividualNodeLevelClashesDescriptors()) {
								writeClashDescriptorsToCache(trackingLine,calcAlgContext);
							}

							//// TODO: delete
							//cint64 depBraLevel = nonDetDependencyNode->getBranchNode()->getBranchingLevel();
							//cint64 depBraLevelCount = mClosedBranchLevelCountHash.value(depBraLevel,0)+1;
							//mClosedBranchLevelCountHash.insert(depBraLevel,depBraLevelCount);

							return true;
						}
					} else {
						// mark all dependencies and corresponding tasks as relevant

						trackedClashedDescriptorBeforeProcTagList;

					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::markRelevanceForTrackedClashedDescriptors(CTrackedClashedDescriptor* descriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					for (CTrackedClashedDescriptor* desIt = descriptors; desIt; desIt = desIt->getNextDescriptor()) {
						CDependencyTrackPoint* depTrackPoint = desIt->getDependencyTrackPoint();
						markDependencyRelevance(depTrackPoint,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::markDependencyRelevance(CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!depTrackPoint->isDependencyRelevant()) {
						depTrackPoint->setDependencyRelevance(true);

						CDependencyNode* depNode = depTrackPoint->getDependencyNode();
						if (depNode) {
							CDependencyIterator depIt(depNode->getAdditionalDependencyIterator(true,true));
							while (depIt.hasNext()) {
								CDependency* dep = depIt.nextDependency(true);
								CDependencyTrackPoint* prevDepTrackPoint = dep->getPreviousDependencyTrackPoint();
								markDependencyRelevance(prevDepTrackPoint,calcAlgContext);
							}
							CDependencyTrackPoint* prevDepTrackPoint = depNode->getPreviousDependencyTrackPoint();
							markDependencyRelevance(prevDepTrackPoint,calcAlgContext);
						}

						if (depNode->isNonDeterministiDependencyNode()) {
							CNonDeterministicDependencyNode* nonDetDepNode = (CNonDeterministicDependencyNode*)depNode;
							CBranchTreeNode* branchTreeNode = nonDetDepNode->getBranchNode();
							CSatisfiableCalculationTask* branchSatCalcTask = branchTreeNode->getSatisfiableCalculationTask();

							if (!branchSatCalcTask->isTaskRelevant()) {
								// TODO: add statistic for marked tasks as relevant
								CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
								processorContext->getTaskProcessorCommunicator()->communicateTaskRelevant(branchSatCalcTask);
							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualNodeForCacheUnsatisfiableRetrieval(CIndividualProcessNode*& indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CXLinker<CIndividualProcessNode*>* indiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(taskMemMan);
					indiNodeLinker->initLinker(indiNode);
					calcAlgContext->getUsedProcessingDataBox()->addIndividualNodeCacheTestingLinker(indiNodeLinker);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::writeClashDescriptorsToCache(CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					CTrackedClashedDescriptor* trackedClashedDesList = nullptr;
					while (trackingLine->hasMoreTrackedClashedList()) {
						trackedClashedDesList = trackingLine->takeNextTrackedClashedList()->append(trackedClashedDesList);
					}
					bool cacheWrite = writeClashDescriptorsToCache(trackedClashedDesList,trackingLine,calcAlgContext);
					trackingLine->sortInTrackedClashedDescriptors(trackedClashedDesList,true);
					return cacheWrite;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::writeClashDescriptorsToCache(CTrackedClashedDescriptor*& trackedClashedDes, CTrackedClashedDescriptor* additionalTrackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					CTrackedClashedDescriptor* separatTrackedClashedDes = additionalTrackedClashedDes;
					trackedClashedDes = additionalTrackedClashedDes->append(trackedClashedDes);
					bool cacheWrite = writeClashDescriptorsToCache(trackedClashedDes,trackingLine,calcAlgContext);
					if (!cacheWrite) {
						trackedClashedDes = trackedClashedDes->getNextDescriptor();
					} else {
						trackedClashedDes = (CTrackedClashedDescriptor*)trackedClashedDes->removeOne(additionalTrackedClashedDes);
					}
					additionalTrackedClashedDes->clearNext();
					return cacheWrite;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::writeClashDescriptorsToCache(CTrackedClashedDescriptor*& trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mConfWriteUnsatCaching && trackedClashedDes) {
						STATINC(UNSATCACHEWRITINGREQUSTCOUNT,calcAlgContext);
						KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
							if (mBacktrackDebug) {
								mCachingClashString  = generateDebugTrackedClashedDescriptorString(trackedClashedDes,calcAlgContext);
							}
						)
						CTrackedClashedDescriptor* trackedClashedDesIt = trackedClashedDes;
						bool nominalOccured = trackedClashedDesIt->isAppropriatedIndividualNominal();
						cint64 minIndiID = trackedClashedDesIt->getAppropriatedIndividualID();
						bool hasOtherIndiID = false;
						cint64 minIndiLevel = trackedClashedDesIt->getAppropriatedIndividualLevel();
						bool hasOtherIndiLevel = false;
						bool hasNoInvalidConDes = trackedClashedDesIt->getConceptDescriptor() != nullptr;

						trackedClashedDesIt = trackedClashedDesIt->getNextDescriptor();
						while (trackedClashedDesIt) {
							CConceptDescriptor* conDes = trackedClashedDesIt->getConceptDescriptor();
							hasNoInvalidConDes &= conDes != nullptr;
							if (conDes) {
								CConcept* concept = conDes->getConcept();
								cint64 opCode = concept->getOperatorCode();
								CConceptOperator* conOperator = concept->getConceptOperator();
								if (concept->getTerminology() == nullptr || conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_PROPAGATION_TYPE)) {
									hasNoInvalidConDes = false;
								}
							}
							nominalOccured |= trackedClashedDesIt->isAppropriatedIndividualNominal();
							if (trackedClashedDesIt->getAppropriatedIndividualID() != minIndiID) {
								hasOtherIndiID = true;
								if (nominalOccured) {
									STATINC(UNSATCACHEWRITINGREQUSTDIFFNOMINALFAILEDCOUNT,calcAlgContext);
									return false;
								}
							}
							if (trackedClashedDesIt->getAppropriatedIndividualLevel() != minIndiLevel) {
								STATINC(UNSATCACHEWRITINGREQUSTDIFFNODELEVELFAILEDCOUNT,calcAlgContext);
								hasOtherIndiLevel = true;
								return false;
							}
							trackedClashedDesIt = trackedClashedDesIt->getNextDescriptor();
						}
						// TODO: unsatisfiability caching with nominals, currently deactivateds
						if (hasNoInvalidConDes && !nominalOccured) {
							bool writeCacheLine = false;
							if (!nominalOccured) {
								writeCacheLine = !hasOtherIndiLevel;
							} else {
								writeCacheLine = !hasOtherIndiID;
							}
							bool atomicClash = false;
							if (writeCacheLine) {
								CTrackedClashedDescriptor* trackedClashedDesIt = trackedClashedDes;
								while (trackedClashedDesIt && !atomicClash) {
									CConceptDescriptor* conDes = trackedClashedDesIt->getConceptDescriptor();
									CConcept* concept = conDes->getConcept();
									bool conNeg = conDes->getNegation();
									CTrackedClashedDescriptor* atomClashedDesIt = trackedClashedDesIt->getNextDescriptor();
									while (atomClashedDesIt && !atomicClash) {
										CConceptDescriptor* othConDes = atomClashedDesIt->getConceptDescriptor();
										if (othConDes->getConcept() == concept && othConDes->getNegation() != conNeg) {
											STATINC(UNSATCACHEWRITINGREQUSTATOMICCLASHFAILEDCOUNT,calcAlgContext);
											atomicClash = true;
											return false;
										}
										atomClashedDesIt = atomClashedDesIt->getNextDescriptor();
									}
									trackedClashedDesIt = trackedClashedDesIt->getNextDescriptor();
								}
							}
							writeCacheLine &= !atomicClash;
							if (writeCacheLine) {


								//CConcept* orConcept = nullptr;
								//for (CTrackedClashedDescriptor* cIt = trackedClashedDes; cIt; cIt = cIt->getNextDescriptor()) {
								//	if (cIt->getConceptDescriptor()->getConcept()->getOperatorCode() == CCAND && cIt->getConceptDescriptor()->isNegated() && cIt->getConceptDescriptor()->getConcept()->getOperandCount() > 2) {
								//		orConcept = cIt->getConceptDescriptor()->getConcept();
								//	}
								//}
								//if (orConcept) {
								//	for (CSortedNegLinker<CConcept*>* opConIt = orConcept->getOperandList(); opConIt; opConIt = opConIt->getNext()) {
								//		bool found = false;
								//		for (CTrackedClashedDescriptor* cIt = trackedClashedDes; cIt; cIt = cIt->getNextDescriptor()) {
								//			if (cIt->getConceptDescriptor()->getConcept() == opConIt->getData()) {
								//				found = true;
								//			}
								//		}
								//		if (!found) {
								//			mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
								//			QFile file(QString("caching-error.txt"));
								//			if (file.open(QIODevice::WriteOnly)) {
								//				file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
								//				file.close();
								//			}
								//			bool bug = true;
								//		}
								//	}
								//}

								if (mConfUnsatCachingUseNodeSignatureSet) {
									addIndiNodeSignatureOfUnsatisfiableClashedDescriptors(trackedClashedDes,calcAlgContext);
								}
								trackedClashedDes = getSortedClashedDescriptors(trackedClashedDes,calcAlgContext);
								KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(
									if (mBacktrackDebug) {
										mSortedCachingClashString  = generateDebugTrackedClashedDescriptorString(trackedClashedDes,calcAlgContext);
									}
								)
								writeUnsatisfiableClashedDescriptors(trackedClashedDes,calcAlgContext);
								return true;
							}
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndiNodeSignatureOfUnsatisfiableClashedDescriptors(CTrackedClashedDescriptor* trackedClashedDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 indiID = trackedClashedDes->getAppropriatedIndividualID();
					CIndividualProcessNode* indi = getCorrectedNominalIndividualNode(indiID,calcAlgContext);
					CReapplyConceptLabelSet* conSet = indi->getReapplyConceptLabelSet(false);
					cint64 conSig = conSet->getConceptSignatureValue();
					mUnsatCachingSignatureSet.insert(conSig);
					return true;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::isClashedDescriptorSortedBefore(CTrackedClashedDescriptor* trackedClashedDesBefore, CTrackedClashedDescriptor* trackedClashedDesAfter, CCalculationAlgorithmContextBase* calcAlgContext) {
					return !trackedClashedDesAfter || trackedClashedDesBefore->getConceptDescriptor()->getConceptTag() <= trackedClashedDesAfter->getConceptDescriptor()->getConceptTag();
				}


				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::getSortedClashedDescriptors(CTrackedClashedDescriptor* trackedClashedDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CTrackedClashedDescriptor* sortedTrackedClashedDes = trackedClashedDes;
					trackedClashedDes = trackedClashedDes->getNextDescriptor();
					sortedTrackedClashedDes->clearNext();
					while (trackedClashedDes) {
						CTrackedClashedDescriptor* tmpTrackedClashedDes = trackedClashedDes;
						trackedClashedDes = trackedClashedDes->getNextDescriptor();
						tmpTrackedClashedDes->clearNext();

						if (isClashedDescriptorSortedBefore(tmpTrackedClashedDes,sortedTrackedClashedDes,calcAlgContext)) {
							sortedTrackedClashedDes = tmpTrackedClashedDes->append(sortedTrackedClashedDes);
						} else {
							CTrackedClashedDescriptor* sortedInsertPosIt = sortedTrackedClashedDes;
							while (sortedInsertPosIt) {
								CTrackedClashedDescriptor* nextSortedPosDes = sortedInsertPosIt->getNextDescriptor();
								if (isClashedDescriptorSortedBefore(tmpTrackedClashedDes,nextSortedPosDes,calcAlgContext)) {
									sortedInsertPosIt->insertNext(tmpTrackedClashedDes);
									break;
								}
								sortedInsertPosIt = nextSortedPosDes;
							}
						}
					}
					return sortedTrackedClashedDes;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::writeUnsatisfiableClashedDescriptors(CTrackedClashedDescriptor* trackedClashedDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CUnsatisfiableCacheHandler* unsatCacheHandler = calcAlgContext->getUsedUnsatisfiableCacheHandler();
					if (unsatCacheHandler) {
						return unsatCacheHandler->writeUnsatisfiableClashedDescriptors(trackedClashedDes,calcAlgContext);
					}
					return false;
				}


				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::getCollectedFilteredClashedDescriptorsFromBranch(CTrackedClashedDescriptor* nonDetClashedPointingDes, CNonDeterministicDependencyNode* nonDetBranchDepNode, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext, CMemoryAllocationManager* tmpMemMan) {
					CPROCESSINGSET<CTrackedClashedDescriptorHasher> testClashedSet(calcAlgContext->getUsedTaskProcessorContext());
					CNonDeterministicDependencyTrackPoint* trackPointIt = nonDetBranchDepNode->getBranchTrackPoints();
					CTrackedClashedDescriptor* newTrackedClashedDescriptorList = nullptr;

					CTrackedClashedDescriptor* nonDetPointingFirstTrackedClashedDescriptor = nonDetClashedPointingDes;

					while (trackPointIt) {
						CClashedDependencyDescriptor* clashedDepDescriptors = trackPointIt->getClashes();						

						CClashedDependencyDescriptor* clashedDepDescriptorsIt = clashedDepDescriptors;
						while (clashedDepDescriptorsIt) {
							CClashedDependencyDescriptor* clashedDepDescriptor = clashedDepDescriptorsIt;
							if (clashedDepDescriptor->getDependencyTrackPoint()->getDependencyNode() != nonDetBranchDepNode) {
								CTrackedClashedDescriptor* netTrackedClashDes = createTrackedClashesDescriptor(clashedDepDescriptor,calcAlgContext,tmpMemMan);
								CTrackedClashedDescriptorHasher hasher(netTrackedClashDes);
								if (!testClashedSet.contains(hasher)) {
									// each dependency only once
									testClashedSet.insert(hasher);
									newTrackedClashedDescriptorList = netTrackedClashDes->append(newTrackedClashedDescriptorList);
								}
							} else {
								if (!nonDetPointingFirstTrackedClashedDescriptor) {
									nonDetPointingFirstTrackedClashedDescriptor = createTrackedClashesDescriptor(clashedDepDescriptor,calcAlgContext,tmpMemMan);
								}
							}
							clashedDepDescriptorsIt = clashedDepDescriptorsIt->getNext();
						}

						for (CXLinker<cint64>* involvedIndiIdLinkerIt = trackPointIt->getInvolvedIndividualIdsLinker(); involvedIndiIdLinkerIt; involvedIndiIdLinkerIt = involvedIndiIdLinkerIt->getNext()) {
							cint64 indiId = involvedIndiIdLinkerIt->getData();
							trackingLine->addInvolvedIndividual(indiId);
						}


						trackPointIt = trackPointIt->getNext();
					}

					KONCLUDE_ASSERT_X(nonDetPointingFirstTrackedClashedDescriptor,"getCollectedFilteredClashedDescriptorsFromBranch","track point for non-deterministic dependency not found");

					CTrackedClashedDescriptor* nonDetBacktrackedClashedDes = getBacktrackedDeterministicClashedDescriptors(nonDetPointingFirstTrackedClashedDescriptor,trackingLine,nullptr,calcAlgContext);
					CTrackedClashedDescriptor* nonDetBacktrackedClashedDesIt = nonDetBacktrackedClashedDes;
					while (nonDetBacktrackedClashedDesIt) {
						nonDetBacktrackedClashedDes = nonDetBacktrackedClashedDesIt;
						nonDetBacktrackedClashedDesIt = nonDetBacktrackedClashedDesIt->getNextDescriptor();
						nonDetBacktrackedClashedDes->clearNext();

						CTrackedClashedDescriptorHasher hasher(nonDetBacktrackedClashedDes);
						if (!testClashedSet.contains(hasher)) {
							// each dependency only once
							testClashedSet.insert(hasher);
							newTrackedClashedDescriptorList = nonDetBacktrackedClashedDes->append(newTrackedClashedDescriptorList);
						}
					}


					return newTrackedClashedDescriptorList;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackDeterministicBranchingClashedDescriptorFromCurrentIndividualNodeLevel(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 minIndiLevel = CINT64_MAX;
					CTrackedClashedDescriptor* newTrackedClashedDesList = getBacktrackedDeterministicClashedDescriptors(trackedClashedDes,trackingLine,&minIndiLevel,calcAlgContext);
					trackingLine->addFreeTrackedClashedDescriptor(trackedClashedDes);
					if (minIndiLevel < trackingLine->getIndividualNodeLevel()) {
						// cache with old tracked clash descriptors
						trackingLine->moveToNextIndividualNodeLevel(minIndiLevel);
					}
					trackingLine->sortInTrackedClashedDescriptors(newTrackedClashedDesList);
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::backtrackDeterministicClashedDescriptorFromPreviousIndividualNodeLevels(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					CTrackedClashedDescriptor* newTrackedClashedDesList = getBacktrackedDeterministicClashedDescriptors(trackedClashedDes,trackingLine,nullptr,calcAlgContext);
					trackingLine->addFreeTrackedClashedDescriptor(trackedClashedDes);
					trackingLine->sortInTrackedClashedDescriptors(newTrackedClashedDesList);
					return true;
				}


				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::getBacktrackedDeterministicClashedDescriptorsBeforeProcessingTag(CTrackedClashedDescriptor* trackedClashedDescriptors, cint64 processingTag, CTrackedClashedDependencyLine* trackingLine, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROCESSINGSET<CTrackedClashedDescriptorHasher>* testClashedSet = trackingLine->getTrackedClashedDescriptorSet();
					CTrackedClashedDescriptor* newTrackedClashedDescriptorList = nullptr;
					CTrackedClashedDescriptor* trackedClashedDescriptorIt = trackedClashedDescriptors;
					while (trackedClashedDescriptorIt) {
						CTrackedClashedDescriptor* trackedClashedDescriptor = trackedClashedDescriptorIt;
						trackedClashedDescriptorIt = trackedClashedDescriptorIt->getNextDescriptor();
						trackedClashedDescriptor->clearNext();
						if (trackedClashedDescriptor->isPointingToNonDeterministicDependencyNode()) {
							KONCLUDE_ASSERT_X(!trackedClashedDescriptor->isProcessedAfter(processingTag),"getBacktrackedDeterministicClashedDescriptorsBeforeProcessingTag","non-deterministic dependency is processed after max branching leveled dependency");
							newTrackedClashedDescriptorList = trackedClashedDescriptor->append(newTrackedClashedDescriptorList);
						} else {
							if (trackedClashedDescriptor->isProcessedAfter(processingTag)) {
								CDependencyTrackPoint* depTrackPoint = trackedClashedDescriptor->getDependencyTrackPoint();
								//if (depTrackPoint->isPointingToIndependentDependencyNode()) {
								//	CTrackedClashedDescriptor* newTrackedClashedDescriptor = getFreeTrackedClashedDescriptor(trackingLine,calcAlgContext);
								//	newTrackedClashedDescriptor->initTrackedClashedDescriptor(trackedClashedDescriptor,nullptr,depTrackPoint);	

								//	CTrackedClashedDescriptorHasher hasher(newTrackedClashedDescriptor);
								//	if (!testClashedSet->contains(hasher)) {
								//		// each dependency only once
								//		testClashedSet->insert(hasher);

								//		trackedClashedDescriptorIt = newTrackedClashedDescriptor->append(trackedClashedDescriptorIt);
								//	} else {
								//		trackingLine->addFreeTrackedClashedDescriptor(newTrackedClashedDescriptor);
								//	}

								//} else {
									CTrackedClashedDescriptor* newTrackedClashedDescriptorIt = getBacktrackedDeterministicClashedDescriptors(trackedClashedDescriptor,trackingLine,nullptr,calcAlgContext);
									while (newTrackedClashedDescriptorIt) {
										CTrackedClashedDescriptor* newTrackedClashedDescriptor = newTrackedClashedDescriptorIt;
										newTrackedClashedDescriptorIt = newTrackedClashedDescriptorIt->getNextDescriptor();
										newTrackedClashedDescriptor->clearNext();

										CTrackedClashedDescriptorHasher hasher(newTrackedClashedDescriptor);
										if (!testClashedSet->contains(hasher)) {
											// each dependency only once
											testClashedSet->insert(hasher);

											trackedClashedDescriptorIt = newTrackedClashedDescriptor->append(trackedClashedDescriptorIt);
										} else {
											trackingLine->addFreeTrackedClashedDescriptor(newTrackedClashedDescriptor);
										}
									}
								//}
								trackingLine->addFreeTrackedClashedDescriptor(trackedClashedDescriptor);
							} else if (!trackedClashedDescriptor->getConceptDescriptor() && !trackedClashedDescriptor->isPointingToIndependentDependencyNode()) {
								// try backtrack 
								cint64 continuedIndiID = trackedClashedDescriptor->getAppropriatedIndividualID();
								bool allIndiIDContinued = true;
								CTrackedClashedDescriptor* newTrackedClashedDescriptors = getBacktrackedDeterministicClashedDescriptors(trackedClashedDescriptor,trackingLine,nullptr,calcAlgContext);
								CTrackedClashedDescriptor* newTrackedClashedDescriptorIt = newTrackedClashedDescriptors;
								while (newTrackedClashedDescriptorIt && allIndiIDContinued) {
									if (newTrackedClashedDescriptorIt->getAppropriatedIndividualID() != continuedIndiID) {
										allIndiIDContinued = false;
									}
									newTrackedClashedDescriptorIt = newTrackedClashedDescriptorIt->getNextDescriptor();
								}
								if (!allIndiIDContinued) {
									newTrackedClashedDescriptorList = trackedClashedDescriptor->append(newTrackedClashedDescriptorList);
									newTrackedClashedDescriptorIt = newTrackedClashedDescriptors;
									while (newTrackedClashedDescriptorIt) {
										CTrackedClashedDescriptor* newTrackedClashedDescriptor = newTrackedClashedDescriptorIt;
										newTrackedClashedDescriptorIt = newTrackedClashedDescriptorIt->getNextDescriptor();
										newTrackedClashedDescriptor->clearNext();
										trackingLine->addFreeTrackedClashedDescriptor(newTrackedClashedDescriptor);
									}
								} else {
									// 
									newTrackedClashedDescriptorIt = newTrackedClashedDescriptors;
									while (newTrackedClashedDescriptorIt) {
										CTrackedClashedDescriptor* newTrackedClashedDescriptor = newTrackedClashedDescriptorIt;
										newTrackedClashedDescriptorIt = newTrackedClashedDescriptorIt->getNextDescriptor();
										newTrackedClashedDescriptor->clearNext();

										CTrackedClashedDescriptorHasher hasher(newTrackedClashedDescriptor);
										if (!testClashedSet->contains(hasher)) {
											// each dependency only once
											testClashedSet->insert(hasher);

											trackedClashedDescriptorIt = newTrackedClashedDescriptor->append(trackedClashedDescriptorIt);
										} else {
											trackingLine->addFreeTrackedClashedDescriptor(newTrackedClashedDescriptor);
										}
									}
									trackingLine->addFreeTrackedClashedDescriptor(trackedClashedDescriptor);
								}

							} else {
								newTrackedClashedDescriptorList = trackedClashedDescriptor->append(newTrackedClashedDescriptorList);
							}
						}
					}
					return newTrackedClashedDescriptorList;
				}






				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::getBacktrackedDeterministicClashedDescriptors(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, cint64* minIndiLevel, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(CLASHEDBACKTRACKEDDESCRIPTORSCOUNT,calcAlgContext);
					CDependencyNode* depNode = trackedClashedDes->getDependencyTrackPoint()->getDependencyNode();
					CConceptDescriptor* conDes = depNode->getConceptDescriptor();
					CIndividualProcessNode* indiNode = nullptr;
					CIndividualProcessNode* newIndiNode = nullptr;
					CTrackedClashedDescriptor* newTrackedClashedDesList = nullptr;
					if (minIndiLevel) {
						*minIndiLevel = trackedClashedDes->getAppropriatedIndividualLevel();
					}
					if (depNode->hasAppropriateIndividualNode()) {
						trackingLine->addInvolvedIndividual(depNode->getAppropriateIndividualNode());
						newIndiNode = getCoresspondingIndividualNodeFromDependency(depNode, calcAlgContext);
						trackingLine->addInvolvedIndividual(newIndiNode);
						if (minIndiLevel) {
							*minIndiLevel = qMin(*minIndiLevel,newIndiNode->getIndividualNominalLevelOrAncestorDepth());
						}
					}
					CDependencyTrackPoint* depTrackPoint = depNode->getPreviousDependencyTrackPoint();


					CVariableBindingPath* varBindPath = trackedClashedDes->getVariableBindingPath();
					if (depNode->isRepresentativeSelectDependencyNode()) {			
						CRepresentativeSelectDependencyNode* repSelDepNode = dynamic_cast<CRepresentativeSelectDependencyNode*>(depNode);
						varBindPath = repSelDepNode->getSelectedVariableBindingPath();
					} else if (depNode->isRepresentativeResolveDependencyNode()) {
						CRepresentativeResolveDependencyNode* repResDepNode = dynamic_cast<CRepresentativeResolveDependencyNode*>(depNode);		

						CRepresentativeVariableBindingPathMap* repVarBindPathMap = repResDepNode->getResolveRepresentativeVariableBindingPathMap();
						CRepresentativePropagationMap* repPropMap = repResDepNode->getResolveRepresentativePropagationMap();


						//if (!repVarBindPathMap->contains(varBindPath->getPropagationID())) {
						//	QFile file(QString("varPropModel.txt"));
						//	if (file.open(QIODevice::WriteOnly)) {
						//		mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						//		file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
						//		file.close();
						//	}
						//}


						const CRepresentativeVariableBindingPathMapData& repVarBindPathMapData = repVarBindPathMap->value(varBindPath->getPropagationID());
						varBindPath = repVarBindPathMapData.getResolveVariableBindingPath();

						cint64 resolveRepID = repVarBindPathMapData.getResolveRepresentativeVariableBindingPathSetDataID();

						const CRepresentativePropagationMapData& repPropMapData = repPropMap->value(resolveRepID);
						CRepresentativePropagationDescriptor* repPropDes = repPropMapData.getRepresentativePropagationDescriptor();

						depTrackPoint = repPropDes->getDependencyTrackPoint();
					}


					CTrackedClashedDescriptor* newTrackedClashedDes = getFreeTrackedClashedDescriptor(trackingLine,calcAlgContext);
					if (newIndiNode) {
						newTrackedClashedDes->initTrackedClashedDescriptor(newIndiNode,conDes,varBindPath,depTrackPoint);
					} else {
						newTrackedClashedDes->initTrackedClashedDescriptor(trackedClashedDes,conDes,varBindPath,depTrackPoint);
					}
					newTrackedClashedDes = tryGetInvalidSameIndividualNodeLevelBacktrackedDeterministicClashedDescriptors(newTrackedClashedDes,trackingLine,nullptr,calcAlgContext);
					newTrackedClashedDesList = newTrackedClashedDes->append(newTrackedClashedDesList);


					CDependencyIterator depIt = depNode->getAdditionalDependencyIterator();
					while (depIt.hasNext()) {
						CDependency* dependency = depIt.nextDependency();
						// load additional dependencies
						CDependencyTrackPoint* depTrackPoint = dependency->getPreviousDependencyTrackPoint();
						CIndividualProcessNode* addDepNewIndiNode = getCoresspondingIndividualNodeFromDependency(depTrackPoint,calcAlgContext);
						trackingLine->addInvolvedIndividual(addDepNewIndiNode);
						CTrackedClashedDescriptor* newTrackedClashedDes = getFreeTrackedClashedDescriptor(trackingLine,calcAlgContext);
						if (!addDepNewIndiNode) {
							newTrackedClashedDes->initTrackedClashedDescriptor(trackedClashedDes,nullptr,varBindPath,depTrackPoint);
						} else {
							if (minIndiLevel) {
								*minIndiLevel = qMin(*minIndiLevel,addDepNewIndiNode->getIndividualNominalLevelOrAncestorDepth());
							}
							newTrackedClashedDes->initTrackedClashedDescriptor(addDepNewIndiNode,nullptr,varBindPath,depTrackPoint);
						}
						newTrackedClashedDes = tryGetInvalidSameIndividualNodeLevelBacktrackedDeterministicClashedDescriptors(newTrackedClashedDes,trackingLine,nullptr,calcAlgContext);
						newTrackedClashedDesList = newTrackedClashedDes->append(newTrackedClashedDesList);
					}
					return newTrackedClashedDesList;
				}


				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::tryGetInvalidSameIndividualNodeLevelBacktrackedDeterministicClashedDescriptors(CTrackedClashedDescriptor* trackedClashedDes, CTrackedClashedDependencyLine* trackingLine, cint64* minIndiLevel, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (trackedClashedDes->getConceptDescriptor() == nullptr && trackedClashedDes->isPointingToDeterministicDependencyNode() && !trackedClashedDes->isPointingToIndependentDependencyNode()) {
						CDependencyNode* depNode = trackedClashedDes->getDependencyTrackPoint()->getDependencyNode();
						cint64 currLevel = trackedClashedDes->getAppropriatedIndividualLevel();
						CIndividualProcessNode* indiNode = nullptr;
						CTrackedClashedDescriptor* newTrackedClashedDesList = nullptr;
						if (minIndiLevel) {
							*minIndiLevel = trackedClashedDes->getAppropriatedIndividualLevel();
						}
						if (depNode->hasAppropriateIndividualNode()) {
							indiNode = getCoresspondingIndividualNodeFromDependency(depNode,calcAlgContext);
							if (indiNode->getIndividualNominalLevelOrAncestorDepth() != currLevel) {
								return trackedClashedDes;
							}
						}

						CDependencyIterator depIt = depNode->getAdditionalDependencyIterator();
						while (depIt.hasNext()) {
							CDependency* dependency = depIt.nextDependency();
							// load additional dependencies
							CDependencyTrackPoint* depTrackPoint = dependency->getPreviousDependencyTrackPoint();
							CIndividualProcessNode* addDepNewIndiNode = getCoresspondingIndividualNodeFromDependency(depTrackPoint,calcAlgContext);
							trackingLine->addInvolvedIndividual(addDepNewIndiNode);
							if (addDepNewIndiNode && addDepNewIndiNode->getIndividualNominalLevelOrAncestorDepth() != currLevel) {
								return trackedClashedDes;
							}
						}
						return getBacktrackedDeterministicClashedDescriptors(trackedClashedDes,trackingLine,minIndiLevel,calcAlgContext);
					}
					return trackedClashedDes;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::initializeTrackingLine(CTrackedClashedDependencyLine* trackingLine, CTrackedClashedDescriptor* trackingClashes, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool trackingError = false;
					bool nominalOccured = false;
					cint64 maxBranchingLevel = CINT64_MIN;
					cint64 minIndividualLevel = CINT64_MAX;
					CTrackedClashedDescriptor* trackingClashesIt = trackingClashes;
					while (trackingClashesIt && !trackingError) {
						trackingClashesIt->candidateTracking(&trackingError,&nominalOccured,&maxBranchingLevel,&minIndividualLevel);
						trackingClashesIt = trackingClashesIt->getNextDescriptor();
					}
					if (trackingError) {
						return false;
					}
					trackingLine->initTrackedClashedDependencyLine(nominalOccured,minIndividualLevel,maxBranchingLevel);
					trackingLine->analyseInvolvedIndividuals(trackingClashes);
					trackingLine->sortInTrackedClashedDescriptors(trackingClashes, true);
					return true;
				}



				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createTrackedClashesDescriptors(CClashedDependencyDescriptor* clashes, CCalculationAlgorithmContextBase* calcAlgContext, CMemoryAllocationManager* tmpMemMan, bool copyIndependentConceptDescriptors) {
					if (!tmpMemMan) {
						tmpMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
					}

					CTrackedClashedDescriptor* trackingClashes = nullptr;
					CClashedDependencyDescriptor* nextClash = clashes;
					while (nextClash) {
						CTrackedClashedDescriptor* newTrackingClash = nullptr;
						newTrackingClash = createTrackedClashesDescriptor(nextClash,calcAlgContext,tmpMemMan, copyIndependentConceptDescriptors);
						trackingClashes = newTrackingClash->append(trackingClashes);
						nextClash = nextClash->getNext();
					}
					return trackingClashes;
				}



				CTrackedClashedDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createTrackedClashesDescriptor(CClashedDependencyDescriptor* clashDes, CCalculationAlgorithmContextBase* calcAlgContext, CMemoryAllocationManager* tmpMemMan, bool copyIndependentConceptDescriptors) {
					if (!tmpMemMan) {
						tmpMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
					}

					CTrackedClashedDescriptor* newTrackingClash = nullptr;
					CTrackedClashedDescriptor* clashedTrackDes = dynamic_cast<CTrackedClashedDescriptor*>(clashDes);
					if (clashedTrackDes) {	
						newTrackingClash = CObjectAllocator< CTrackedClashedDescriptor >::allocateAndConstruct(tmpMemMan);
						newTrackingClash->initTrackedClashedDescriptor(clashedTrackDes);
						if (newTrackingClash->isPointingToIndependentDependencyNode() && copyIndependentConceptDescriptors && newTrackingClash->getConceptDescriptor()) {
							CConceptDescriptor* conDes = newTrackingClash->getConceptDescriptor();
							CConceptDescriptor* conDesCopy = CObjectAllocator< CConceptDescriptor >::allocateAndConstruct(tmpMemMan);
							conDesCopy->initConceptDescriptor(conDes->getConcept(), conDes->isNegated(), conDes->getDependencyTrackPoint());
							newTrackingClash->setConceptDescriptor(conDesCopy);
						}
					} else {
						CClashedConceptDescriptor* clashedConDes = dynamic_cast<CClashedConceptDescriptor*>(clashDes);
						if (clashedConDes) {
							newTrackingClash = CObjectAllocator< CTrackedClashedDescriptor >::allocateAndConstruct(tmpMemMan);
							newTrackingClash->initTrackedClashedDescriptor(clashedConDes->getAppropriatedIndividual(),clashedConDes->getConceptDescriptor(),nullptr,clashedConDes->getDependencyTrackPoint());								
						} else {
							CClashedDatatypeValueSpaceExclusionDescriptor* clashedDataVSExDes = dynamic_cast<CClashedDatatypeValueSpaceExclusionDescriptor*>(clashDes);
							if (clashedDataVSExDes) {
								newTrackingClash = CObjectAllocator< CTrackedClashedDescriptor >::allocateAndConstruct(tmpMemMan);
								newTrackingClash->initTrackedClashedDescriptor(clashedDataVSExDes->getAppropriatedIndividual(),nullptr,nullptr,clashedDataVSExDes->getDependencyTrackPoint());								
							} else {							
								CIndividualProcessNode* indiNode = getCoresspondingIndividualNodeFromDependency(clashDes->getDependencyTrackPoint(),calcAlgContext);
								newTrackingClash = CObjectAllocator< CTrackedClashedDescriptor >::allocateAndConstruct(tmpMemMan);
								newTrackingClash->initTrackedClashedDescriptor(indiNode,nullptr,nullptr,clashDes->getDependencyTrackPoint());			
							}
						}
					}
					return newTrackingClash;
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getCoresspondingIndividualNodeFromDependency(CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CDependencyNode* depNode = depTrackPoint->getDependencyNode();
					return getCoresspondingIndividualNodeFromDependency(depNode,calcAlgContext);
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getCoresspondingIndividualNodeFromDependency(CDependencyNode* depNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* indi = nullptr;
					indi = depNode->getAppropriateIndividualNode();
					//KONCLUDE_ASSERT_X(indi,"getCoresspondingIndividualNodeFromDependency","individual node not available");
					if (indi) {
						CIndividualProcessNode* updIndi = getUpToDateIndividual(indi,calcAlgContext);
						if (updIndi) {
							if (updIndi->hasMergedIntoIndividualNodeID()) {
								updIndi = getCorrectedNominalIndividualNode(updIndi->getMergedIntoIndividualNodeID(),calcAlgContext);
							}
							indi = updIndi;
						}
					}
					return indi;
				}



				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugDependentNominalsString(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList nominalDependentStringList;
					CSuccessorConnectedNominalSet* connNomSet = indi->getSuccessorNominalConnectionSet(false);
					if (connNomSet) {
						for (CSuccessorConnectedNominalSet::const_iterator it = connNomSet->constBegin(), itEnd = connNomSet->constEnd(); it != itEnd; ++it) {
							cint64 nominalID = *it;
							QString nominalString = QString("%1").arg(nominalID);
							nominalDependentStringList.append(nominalString);
						}
					}
					return nominalDependentStringList.join(", ");
				}



				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIncrementalExpansionString(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString incExpString;
					CIndividualNodeIncrementalExpansionData* incExpData = indi->getIncrementalExpansionData(false);
					if (incExpData) {
						QStringList statusStringList;
						if (incExpData->isPreviousCompletionGraphCompatible()) {
							statusStringList += QString("compatible");
						}
						if (incExpData->hasDirectlyChangedNeighbourConnection()) {
							statusStringList += QString("directly-changed-connection");
						}
						if (incExpData->isDirectlyChanged()) {
							statusStringList += QString("directly-changed-node");
						}
						QString dirChangedNeighConnNodeID = "-";
						if (incExpData->getDirectlyChangedNeighbourConnectionNode()) {
							dirChangedNeighConnNodeID = QString("%1").arg(incExpData->getDirectlyChangedNeighbourConnectionNode()->getIndividualNodeID());
						}
						double expansionPriority = incExpData->getExpansionPriority();
						incExpString += QString("Incremental-Expansion-Status: %1\r\n Directly-Changed-Connection-Neighbour: %2\r\n Expansion-Priority: %3").arg(statusStringList.join(", ")).arg(dirChangedNeighConnNodeID).arg(expansionPriority);
					}
					return incExpString;
				}


				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIndiStatusString(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList statusStringList;
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION)) {
						statusStringList.append("invalid-blocker");
					} 
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
						statusStringList.append("pruned");
					} 
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED)) {
						statusStringList.append("processing blocked");
					} 
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED)) {
						statusStringList.append("satisfiable-cached");
					} 
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
						statusStringList.append("ancestor-satisfiable-cached");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED)) {
						cint64 blockerIndiID = indi->getBlockerIndividualNode()->getIndividualNodeID();
						cint64 lastConTag = indi->mDebugBlockerLastConceptDes->getConceptTag();
						statusStringList.append(QString("direct-blocked by %1 (%2)").arg(blockerIndiID).arg(lastConTag));
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINDIRECTBLOCKED)) {
						statusStringList.append("indirect-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
						statusStringList.append("indirect-blocking-loss");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED)) {
						statusStringList.append("blocking-retest-direct-modification");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED)) {
						statusStringList.append("blocking-retest-blocker-modification");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED)) {
						statusStringList.append("blocking-retest-ancestor-modification");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED)) {
						CSignatureBlockingIndividualNodeConceptExpansionData* locSigBlockingData = indi->getSignatureBlockingIndividualNodeConceptExpansionData(false);
						cint64 blockerIndiID = -1;
						if (locSigBlockingData->getBlockerIndividualNode()) {
							blockerIndiID = locSigBlockingData->getBlockerIndividualNode()->getIndividualNodeID();
						} 
						statusStringList.append(QString("signature-blocking-cached by %1").arg(blockerIndiID));
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
						statusStringList.append("ancestor-signature-blocking-cached");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL)) {
						statusStringList.append("reusing-individual-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORREUSINGINDIVIDUALBLOCKED)) {
						statusStringList.append("ancestor-reusing-individual-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED)) {
						statusStringList.append("saturation-cached-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
						statusStringList.append("ancestor-saturation-cached-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
						statusStringList.append("completion-graph-cached-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID)) {
						statusStringList.append("completion-graph-caching-invalid");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHEDNODELOCATED)) {
						statusStringList.append("completion-graph-caching-node-located");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHEDNODEEXTENDED)) {
						statusStringList.append("completion-graph-caching-node-extended");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED)) {
						statusStringList.append("completion-graph-caching-invalidated");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED)) {
						statusStringList.append("completion-graph-caching-retest-due-to-modification");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
						statusStringList.append("successor-nominal-connection");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNEWNOMINALCONNECTION)) {
						statusStringList.append("successor-new-nominal-connection");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE)) {
						statusStringList.append("data-node");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND)) {
						statusStringList.append("backend-synchronization");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED)) {
						statusStringList.append("backend-synchronized-nominal-indirect-connections-expansion-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {
						statusStringList.append("backend-synchronized-neighbour-expansion-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION)) {
						statusStringList.append("backend-synchronized-neighbour-partial-expansion");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION)) {
						statusStringList.append("backend-synchronized-neighbour-full-expansion");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
						statusStringList.append("backend-synchronized-successor-expansion-blocked");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANDING)) {
						statusStringList.append("incremental-expansion");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED)) {
						statusStringList.append("incremental-expansion-compatibility-checking-due-to-modification");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFREUSINGINDIVIDUAL)) {
						statusStringList.append("backend-expansion-reusing-individual");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSINGINDIVIDUAL)) {
						statusStringList.append("backend-expansion-reusing-individual");
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED)) {
						statusStringList.append("backend-expansion-reuse-discarded");
					}
					if (indi->isNominalIndividualNode()) {
						statusStringList.append("nominal");
					}

					CConceptProcessingQueue* conProQue = indi->getConceptProcessingQueue(false);
					if (conProQue) {
						if (!conProQue->isEmpty() && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION)) {
							statusStringList.append("processing");
						}
					}

					QString statusString;
					statusString = statusStringList.join(", ");
					return statusString;
				}

				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugDependencyString(CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString dependencyString = QString("null");
					if (depTrackPoint) {
						QString depTypeString;
						CDependencyNode* depNode = depTrackPoint->getDependencyNode();
						switch (depNode->getDependencyType()) {
								case CDependencyNode::DNTINDEPENDENTBASE: {
									depTypeString = QString("INDEPENDENT");
									break;
																		  }
								case CDependencyNode::DNTALLDEPENDENCY: {
									depTypeString = QString("ALL");
									break;
																		}
								case CDependencyNode::DNTSOMEDEPENDENCY: {
									depTypeString = QString("SOME");
									break;
																		 }
								case CDependencyNode::DNTANDDEPENDENCY: {
									depTypeString = QString("AND");
									break;
																		}
								case CDependencyNode::DNTORDEPENDENCY: {
									depTypeString = QString("OR");
									break;
																	   }
								case CDependencyNode::DNTATLEASTDEPENDENCY: {
									depTypeString = QString("ATLEAST");
									break;
																			}
								case CDependencyNode::DNTAUTOMATCHOOSEDEPENDENCY: {
									depTypeString = QString("AUTOMATCHOOSE");
									break;
																				  }
								case CDependencyNode::DNTAUTOMATTRANSACTIONDEPENDENCY: {
									depTypeString = QString("AUTOMATTRANSACTION");
									break;
																					   }
								case CDependencyNode::DNTSELFDEPENDENCY: {
									depTypeString = QString("SELF");
									break;
																		 }
								case CDependencyNode::DNTVALUEDEPENDENCY: {
									depTypeString = QString("VALUE");
									break;
																		  }
								case CDependencyNode::DNTNEGVALUEDEPENDENCY: {
									depTypeString = QString("NEGVALUE");
									break;
																			 }
								case CDependencyNode::DNTDISTINCTDEPENDENCY: {
									depTypeString = QString("DISTINCT");
									break;
																			 }
								case CDependencyNode::DNTMERGEDCONCEPT: {
									depTypeString = QString("MERGEDCONCEPT");
									break;
																		}
								case CDependencyNode::DNTMERGEDLINK: {
									depTypeString = QString("MERGEDLINK");
									break;
																	 }
								case CDependencyNode::DNTMERGEDEPENDENCY: {
									depTypeString = QString("MERGE");
									break;
																		  }
								case CDependencyNode::DNTATMOSTDEPENDENCY: {
									depTypeString = QString("ATMOST");
									break;
																		   }
								case CDependencyNode::DNTQUALIFYDEPENDENCY: {
									depTypeString = QString("QUALIFY");
									break;
																			}
								case CDependencyNode::DNTFUNCTIONALDEPENDENCY: {
									depTypeString = QString("FUNCTIONAL");
									break;
																			   }
								case CDependencyNode::DNTNOMINALDEPENDENCY: {
									depTypeString = QString("NOMINAL");
									break;
																			}
								case CDependencyNode::DNTIMPLICATIONDEPENDENCY: {
									depTypeString = QString("IMPLICATION");
									break;
																				}
								case CDependencyNode::DNTEXPANDEDDEPENDENCY: {
									depTypeString = QString("EXPANDED");
									break;
																			 }
								case CDependencyNode::DNTDATATYPETRIGGERDEPENDENCY: {
									depTypeString = QString("DATATYPETRIGGER");
									break;
																					}
								case CDependencyNode::DNTROLEASSERTIONDEPENDENCY: {
									depTypeString = QString("ROLEASSERTION");
									break;
																					}

						}

						CConceptDescriptor* depNodeConDes = depNode->getConceptDescriptor();
						QString conceptDepNodeString("null"); 
						if (depNodeConDes) {
							conceptDepNodeString = CConceptTextFormater::getConceptString(depNodeConDes->getConcept(),depNodeConDes->isNegated());
						}
						QString depIndiNodeString;
						CIndividualProcessNode* depIndiNode = depNode->getAppropriateIndividualNode();
						if (depIndiNode) {
							depIndiNodeString = QString("@%1 ").arg(depIndiNode->getIndividualNodeID());
						}
						QString depInfoString;
						if (depNode->isNonDeterministiDependencyNode()) {
							CNonDeterministicDependencyNode* nonDetDepNode = (CNonDeterministicDependencyNode*)depNode;
							depInfoString += QString(" NonDetDep, <%1/%2>").arg(nonDetDepNode->getOpenedDependencyTrackingPointsCount()).arg(nonDetDepNode->getBranchTrackPoints()->getCount());
						}
						depInfoString += QString(" + ...(%1)").arg(depNode->getAdditionalDependencyCount());
						dependencyString = QString("%1-Dependency: {%2}%3%4").arg(depTypeString).arg(conceptDepNodeString).arg(depIndiNodeString).arg(depInfoString);
					}

					cint64 branchTag = depTrackPoint->getBranchingTag();
					dependencyString = QString(" ^%1  --->  %2").arg(branchTag).arg(dependencyString);
					return dependencyString;
				}


				QStringList CCalculationTableauCompletionTaskHandleAlgorithm::generateExtendedDebugConceptSetStringList(CReapplyConceptLabelSet* conSet, CConceptPropagationBindingSetHash* propBindSetHash, CConceptVariableBindingPathSetHash* varBindPathSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList conSetStringList;
					CReapplyConceptLabelSetIterator conSetIt = conSet->getConceptLabelSetIterator(false,false,false);
					while (conSetIt.hasNext()) {
						CConceptDescriptor* conDes = conSetIt.next();
						CConcept* concept = conDes->getConcept();
						cint64 conTag = conDes->getConceptTag();
						if (conTag != 1) {
							QString conceptString("null");
							if (conDes) {
								conceptString = CConceptTextFormater::getConceptString(conDes->getConcept(),conDes->isNegated());
							}
							if (propBindSetHash) {
								CPropagationBindingSet* propBindSet = propBindSetHash->getPropagationBindingSet(concept,false);
								if (propBindSet) {
									QString bindingString;
									CPropagationBindingMap* map = propBindSet->getPropagationBindingMap();
									for (CPropagationBindingMap::const_iterator it = map->constBegin(), itEnd = map->constEnd(); it != itEnd; ++it) {
										cint64 propBindingID = it.key();
										if (!bindingString.isEmpty()) {
											bindingString += QString(", ");
										}
										bindingString += QString::number(propBindingID);
									}
									conceptString += QString(" ~{%1}").arg(bindingString);
								}
							}
							if (varBindPathSetHash) {
								CVariableBindingPathSet* varBindPathSet = varBindPathSetHash->getVariableBindingPathSet(concept,false);
								if (varBindPathSet) {
									QString bindingString;
									CVariableBindingPathMap* map = varBindPathSet->getVariableBindingPathMap();
									for (CVariableBindingPathMap::const_iterator it = map->constBegin(), itEnd = map->constEnd(); it != itEnd; ++it) {
										cint64 varBindingPathID = it.key();
										if (!bindingString.isEmpty()) {
											bindingString += QString(", ");
										}
										QString bindString;
										CVariableBindingPathDescriptor* varBindPathDes = it.value().getVariableBindingPathDescriptor();
										CVariableBindingPath* varBindPath = varBindPathDes->getVariableBindingPath();
										CVariableBindingDescriptor* varBindDes = varBindPath->getVariableBindingDescriptorLinker();
										for (CVariableBindingDescriptor* varBindDesIt = varBindDes; varBindDesIt; varBindDesIt = varBindDesIt->getNext()) {
											CVariableBinding* varBinding = varBindDesIt->getVariableBinding();
											if (!bindString.isEmpty()) {
												bindString += QString(",  ");
											}
											bindString += QString("v-%1/i-%2").arg(varBinding->getBindedVariable()->getPathVariableID()).arg(varBinding->getBindedIndividual()->getIndividualNodeID());
										}
										bindingString += QString("{%1:%2}").arg(varBindingPathID).arg(bindString);
									}
									conceptString += QString(" ~{%1}").arg(bindingString);
								}
							}
							CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
							if (depTrackPoint) {
								conceptString += generateDebugDependencyString(depTrackPoint,calcAlgContext);
							}
							conSetStringList.append(conceptString);
						}
					}
					return conSetStringList;
				}





				QString CCalculationTableauCompletionTaskHandleAlgorithm::writeGeneratedExtendedDebugIndiModelStringList(const QString& filename, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList indiStringList;
					QString remainingDebugString = generateExtendedDebugIndiModelStringList(calcAlgContext, &indiStringList);

					QFile file(filename);
					if (file.open(QIODevice::WriteOnly)) {

						for (const QString& tmpString : indiStringList) {
							QString tmpReplacedString = tmpString;
							tmpReplacedString = tmpReplacedString.replace("<br>", "\r\n");
							file.write(tmpReplacedString.toLocal8Bit());
							file.write(QString("\r\n\r\n\r\n").toLocal8Bit());
						}
						file.write(remainingDebugString.toLocal8Bit());
						file.close();
					}

					if (indiStringList.size() < 5000) {
						mDebugIndiModelStringList = indiStringList;
						mDebugIndiModelString = mDebugIndiModelStringList.join("<br><p><br>\r\n");

						mDebugIndiModelString += remainingDebugString;
					}

					return mDebugIndiModelString;
				}


				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateExtendedDebugIndiModelStringList(CCalculationAlgorithmContextBase* calcAlgContext, QStringList* list) {
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CIndividualProcessNodeVector* indiVec = procDataBox->getIndividualProcessNodeVector();
					cint64 indiStart = indiVec->getItemMinIndex();
					cint64 indiCount = indiVec->getItemCount();
					QStringList indiStringList;
					if (indiStart > 0) {
						indiStart = 0;
					}
					QSet<cint64> propCutIndiNodesIds;
					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(false);
					if (expContData && expContData->getCutBackendNeighbourExpansionIndividualLinker()) {
						for (CXLinker<CIndividualProcessNode*>* propCutIndiLinkerIt = expContData->getCutBackendNeighbourExpansionIndividualLinker(); propCutIndiLinkerIt; propCutIndiLinkerIt = propCutIndiLinkerIt->getNext()) {
							CIndividualProcessNode* propCutIndiNode = propCutIndiLinkerIt->getData();
							propCutIndiNodesIds.insert(propCutIndiNode->getIndividualNodeID());
						}
					}


					cint64 indiReplaceOffset = -indiStart;
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi) {
							CIndividualProcessNode* ancIndi = getAncestorIndividual(indi,calcAlgContext);
							CReapplyConceptLabelSet* conSet = indi->getReapplyConceptLabelSet(false);

							CConceptPropagationBindingSetHash* propBindSetHash = indi->getConceptPropagationBindingSetHash(false);
							CConceptVariableBindingPathSetHash* varBindPathSetHash = indi->getConceptVariableBindingPathSetHash(false);

							if (conSet) {
								QString nominalString = QString("");
								if (indi->getNominalIndividual()) {
									nominalString = QString(", ")+CIRIName::getRecentIRIName(indi->getNominalIndividual()->getNameLinker());
								}
								QString indiString = QString("[ %1%2%3 ] = <br>").arg(ancIndi?QString("%1->").arg(ancIndi->getIndividualNodeID()):"").arg(indi->getIndividualNodeID()).arg(nominalString);

								QString statusString = QString("%1").arg(generateDebugIndiStatusString(indi,calcAlgContext));
								if (propCutIndiNodesIds.contains(i)) {
									statusString += ", backend-expansion-propagation-cutted";
								}
								indiString += QString("{{%1}d%2}<br>").arg(statusString).arg(indi->getIndividualNominalLevelOrAncestorDepth());
								QStringList conSetStringList = generateExtendedDebugConceptSetStringList(conSet,propBindSetHash,varBindPathSetHash,calcAlgContext);
								//debugTestCriticalConceptSet(conSetStringList,calcAlgContext);

								QString depNomString = generateDebugDependentNominalsString(indi,calcAlgContext);
								if (!depNomString.isEmpty()) {
									indiString += QString("SuccessorDependentNominals: %1<br>\r\n").arg(depNomString);
								}

								QString incExpString = generateDebugIncrementalExpansionString(indi,calcAlgContext);
								if (!incExpString.isEmpty()) {
									indiString += QString("%1<br>\r\n").arg(incExpString);
								}


								QString conSetString(conSetStringList.join("<br>"));
								indiString += QString("$%1$<br>{%2} ").arg(conSet->getConceptSignatureValue()).arg(conSetString);


								QString assDataLitString;
								for (CProcessAssertedDataLiteralLinker* dataLitLinkerIt = indi->getAssertedDataLiteralLinker(); dataLitLinkerIt; dataLitLinkerIt = dataLitLinkerIt->getNext()) {
									CDataLiteral* dataLiteral = dataLitLinkerIt->getDataLiteral();
									if (assDataLitString.isEmpty()) {
										assDataLitString = "Asserted Data Literals:<br>\n";
									}
									if (dataLiteral->getDatatype()) {
										assDataLitString += QString("\t\t%1^^%2<br>\n").arg(dataLiteral->getLexicalDataLiteralValueString()).arg(dataLiteral->getDatatype()->getDatatypeIRI());
									} else {
										assDataLitString += QString("\t\t%1<br>\n").arg(dataLiteral->getLexicalDataLiteralValueString());
									}
								}
								if (!assDataLitString.isEmpty()) {
									indiString += QString("<br>\n%1<br>\n").arg(assDataLitString);
								}

								if (indi->getIndividualBackendCacheSynchronisationData(false)) {
									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indi->getIndividualBackendCacheSynchronisationData(false);
									if (backendSyncData->getAssocitaionData()) {
										CBackendNeighbourExpansionQueue* neighExpQue = backendSyncData->getBackendNeighbourExpansionQueue(false);
										QString neighExpQueuedString;
										if (neighExpQue && neighExpQue->hasQueuedNeighbourExpansions()) {
											neighExpQueuedString += ", neighbour-expansion-queued";
										}
										QStringList mergingHandlingStringList;
										if (backendSyncData->hasNonDeterministicallyMergedIndividuals()) {
											mergingHandlingStringList += QString("non-deterministically-merged-individuals:true");
										} else {
											mergingHandlingStringList += QString("non-deterministically-merged-individuals:false");
										}
										if (backendSyncData->hasNewlyMergedIndividuals()) {
											mergingHandlingStringList += QString("newly-merged-individuals:true");
										} else {
											mergingHandlingStringList += QString("newly-merged-individuals:false");
										}
										if (backendSyncData->hasNewlyMergedAllNeighbourExpansion()) {
											mergingHandlingStringList += QString("newly-merged-individuals-all-neighbour-expansion:true");
										} else {
											mergingHandlingStringList += QString("newly-merged-individuals-all-neighbour-expansion:false");
										}
										if (backendSyncData->hasNewlyMergedInferringNeighbourExpansion()) {
											mergingHandlingStringList += QString("newly-merged-individuals-inferring-neighbour-expansion:true");
										} else {
											mergingHandlingStringList += QString("newly-merged-individuals-inferring-neighbour-expansion:false");
										}
										indiString += QString("<br>\n(based on backend data update id %1, cache update id %2, %3%4)<br>\n").arg(backendSyncData->getAssocitaionData()->getAssociationDataUpdateId()).arg(backendSyncData->getAssocitaionData()->getCacheUpdateId()).arg(mergingHandlingStringList.join(", ")).arg(neighExpQueuedString);
									}
								}

								indiStringList.append(indiString);
							} else {
								bool bug = true;
								QString nominalString = QString("");
								if (indi->getNominalIndividual()) {
									nominalString = QString(", ") + CIRIName::getRecentIRIName(indi->getNominalIndividual()->getNameLinker());
								}
								QString indiString = QString("[ %1%2%3 ] = concept set missing<br>").arg(ancIndi ? QString("%1->").arg(ancIndi->getIndividualNodeID()) : "").arg(indi->getIndividualNodeID()).arg(nominalString);
								indiStringList.append(indiString);
							}
						} else {
							//indiStringList.append(QString("[ %1, --unused--]<br>").arg(i));
							indiStringList.append(QString());
						}
					}
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi && indi->hasMergedIntoIndividualNodeID()) {
							cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
							QString meIndiString = indiStringList.value(indiReplaceOffset + mergedIntoID);
							meIndiString += QString("+%1").arg(i);
							if (indiReplaceOffset+mergedIntoID < indiStringList.count()) {
								indiStringList.replace(indiReplaceOffset+mergedIntoID,meIndiString);
							} else {
								LOG(ERROR,"::Konclude::Reasoner::Kernel::Algorithm::TableauCompletionAlgorihm",logTr("Merging of individual %1 into %2 cannot be correctly resolved for completion graph printing.").arg(i).arg(mergedIntoID),this);
							}
						}
					}
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi && indi->hasMergedIntoIndividualNodeID()) {
							cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
							QString indiString = indiStringList.value(indiReplaceOffset + i);
							indiString += QString(" -> %1").arg(mergedIntoID);
							if (indiReplaceOffset+i < indiStringList.count()) {
								indiStringList.replace(indiReplaceOffset+i,indiString);
							} else {
								LOG(ERROR,"::Konclude::Reasoner::Kernel::Algorithm::TableauCompletionAlgorihm",logTr("Merging of individual %1 into %2 cannot be correctly resolved for completion graph printing.").arg(i).arg(mergedIntoID),this);
							}
						}
					}

					cint64 succInsertions = 0;
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi) {
							CSuccessorIterator succIt = indi->getSuccessorIterator();
							while (succIt.hasNext()) {
								cint64 succIndi = succIt.nextIndividualID();
								QString succString = QString("\t--> %1: ").arg(succIndi);
								CSuccessorRoleIterator succRoleIt = indi->getSuccessorRoleIterator(succIndi);
								while (succRoleIt.hasNext()) {
									CIndividualLinkEdge* link = succRoleIt.next();
									CRole* role = link->getLinkRole();
									succString += QString::number(role->getRoleTag());
									if (role->hasPropertyName()) {
										succString += CIRIName::getRecentIRIName(role->getPropertyNameLinker());
									}
									CDependencyTrackPoint* depTrackPoint = link->getDependencyTrackPoint();
									if (depTrackPoint) {
										succString += generateDebugDependencyString(depTrackPoint,calcAlgContext);
									}
									if (succRoleIt.hasNext()) {
										succString += QString(", \r\n\t\t");
									}
								}
								indiStringList.insert(indiReplaceOffset+i+1+succInsertions++,succString);
							}
						}
					}


					QStringList filteredIndiStringList;
					for (QStringList::iterator it = indiStringList.begin(), itEnd = indiStringList.end(); it != itEnd; ++it) {
						if (!it->isEmpty()) {
							filteredIndiStringList.append(*it);
						}
					}


					if (!list) {
						if (filteredIndiStringList.size() >= 1000000) {
							QFile file(QString("./Debugging/CompletionTasks/tmp-%1.txt").arg(calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskDepth()));
							if (file.open(QIODevice::WriteOnly)) {

								for (const QString& tmpString : filteredIndiStringList) {

									QString tmpReplacedString = tmpString;
									tmpReplacedString = tmpReplacedString.replace("<br>", "\r\n");
									file.write(tmpReplacedString.toLocal8Bit());
									file.write(QString("\r\n\r\n\r\n").toLocal8Bit());
								}


								file.close();
							}
						} else {

							mDebugIndiModelStringList = filteredIndiStringList;
							mDebugIndiModelString = mDebugIndiModelStringList.join("<br><p><br>\r\n");
						}
					} else {
						mDebugIndiModelString.clear();
						*list = filteredIndiStringList;
					}


					if (calcAlgContext->getProcessingDataBox()->hasClashedDescriptorLinker()) {

						CTrackedClashedDescriptor* trackedClashDescriptors = createTrackedClashesDescriptors(calcAlgContext->getProcessingDataBox()->getClashedDescriptorLinker(), calcAlgContext);

						CPROCESSINGSET<CTrackedClashedDescriptorHasher> clashedSet(calcAlgContext->getUsedTaskProcessorContext());
						CTrackedClashedDependencyLine trackingLine(&clashedSet);
						QString clashedString = generateDebugTrackedClashedDescriptorSummaryString(trackedClashDescriptors, calcAlgContext);
						if (initializeTrackingLine(&trackingLine, trackedClashDescriptors, calcAlgContext)) {
							clashedString += "\r\n\r\n" + writeDebugTrackingLineStringToFile(generateDebugTrackingLineString(&trackingLine, calcAlgContext), "clash-details", &trackingLine, calcAlgContext);
						}

						mDebugIndiModelString = mDebugIndiModelString + QString("<br><p><br>\r\n<br><p><br>\r\nClashes<br><p><br>\r\n%1").arg(clashedString);
					}
					return mDebugIndiModelString;
				}



				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIndiModelStringList(CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CIndividualProcessNodeVector* indiVec = procDataBox->getIndividualProcessNodeVector();
					cint64 indiCount = indiVec->getItemCount();
					cint64 indiStart = indiVec->getItemMinIndex();
					QStringList indiStringList;
					if (indiStart > 0) {
						indiStart = 0;
					}
					cint64 indiReplaceOffset = -indiStart;
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi) {
							CIndividualProcessNode* ancIndi = getAncestorIndividual(indi,calcAlgContext);
							CReapplyConceptLabelSet* conSet = indi->getReapplyConceptLabelSet(false);
							if (conSet) {
								QString nominalString = QString("");
								if (indi->getNominalIndividual()) {
									nominalString = QString(", ")+CIRIName::getRecentIRIName(indi->getNominalIndividual()->getNameLinker());
								}
								QString indiString = QString("[ %1%2%3 ] = ").arg(ancIndi?QString("%1->").arg(ancIndi->getIndividualNodeID()):"").arg(indi->getIndividualNodeID()).arg(nominalString);
								QString conSetString;
								CReapplyConceptLabelSetIterator conSetIt = conSet->getConceptLabelSetIterator(false,false,false);
								while (conSetIt.hasNext()) {
									CConceptDescriptor* conDes = conSetIt.next();
									CConcept* concept = conDes->getConcept();
									cint64 conTag = conDes->getConceptTag();
									if (conTag != 1) {
										QString conString = QString("%1%2").arg((conDes->isNegated())?"-":"").arg(conTag);
										if (concept->hasClassName()) {
											conString += CIRIName::getRecentIRIName(concept->getClassNameLinker());
										}
										if (!conSetString.isEmpty()) {
											conSetString += QString(", ");
										}
										conSetString += conString;
									}
								}
								indiString += QString("{%1} ").arg(conSetString);
								indiStringList.append(indiString);
							}
						}
					}
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi && indi->hasMergedIntoIndividualNodeID()) {
							cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
							QString meIndiString = indiStringList.value(mergedIntoID);
							meIndiString += QString("+%1").arg(i);
							indiStringList.replace(indiReplaceOffset+mergedIntoID+indiStart,meIndiString);
						}
					}
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi && indi->hasMergedIntoIndividualNodeID()) {
							cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
							QString indiString = indiStringList.value(i);
							indiString += QString(" -> %1").arg(mergedIntoID);
							indiStringList.replace(indiReplaceOffset + i+indiStart,indiString);
						}
					}

					cint64 succInsertions = 0;
					for (cint64 i = indiStart; i < indiCount; ++i) {
						CIndividualProcessNode* indi = getAvailableUpToDateIndividual(i,calcAlgContext);
						if (indi) {
							CSuccessorIterator succIt = indi->getSuccessorIterator();
							while (succIt.hasNext()) {
								cint64 succIndi = succIt.nextIndividualID();
								QString succString = QString("\t--> %1: ").arg(succIndi);
								CSuccessorRoleIterator succRoleIt = indi->getSuccessorRoleIterator(succIndi);
								while (succRoleIt.hasNext()) {
									CIndividualLinkEdge* link = succRoleIt.next();
									CRole* role = link->getLinkRole();
									succString += QString::number(role->getRoleTag());
									if (role->hasPropertyName()) {
										succString += CIRIName::getRecentIRIName(role->getPropertyNameLinker());
									}
									if (succRoleIt.hasNext()) {
										succString += QString(", ");
									}
								}
								indiStringList.insert(indiReplaceOffset + i+indiStart+1+succInsertions++,succString);
							}
						}
					}
					mDebugIndiModelStringList = indiStringList;
					mDebugIndiModelString = mDebugIndiModelStringList.join("\n");
					return mDebugIndiModelString;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::initialNodeInitialize(CIndividualProcessNode*& indiProcNode, bool allowPreprocess, CCalculationAlgorithmContextBase* calcAlgContext) {


					if (indiProcNode->getNominalIndividual() && !indiProcNode->getNominalIndividual()->isFakeIndividual() && mBackendCacheHandler && !indiProcNode->isNominalIndividualRepresentativeBackendDataLoaded() && !mOptIncrementalCompatibleExpansion) {

						if (loadIndividualNodeDataFromBackendCache(indiProcNode, calcAlgContext)) {

							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiProcNode->getIndividualBackendCacheSynchronisationData(false);
							if (!backendSyncData || !backendSyncData->isBackendConceptSetInitialized()) {
								if (!allowPreprocess || backendSyncData->isBackendConceptSetInitializationRequired() || !mOptDelayedBackendInitializiation || !tryDelayIndividualNodeInitializationWithBackendConceptSetLabel(indiProcNode, calcAlgContext)) {
									initializeIndividualNodeWithBackendCache(indiProcNode, calcAlgContext);
									indiProcNode->setNominalIndividualRepresentativeBackendDataLoaded(true);
									tryEstablishExpansionBlockingWithBackendCacheSynchronisation(indiProcNode, calcAlgContext);
									indiProcNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENPROCESSINGDELAYING);
								} else {
									// mark processing blocked by setting flag
									indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENPROCESSINGDELAYING);
									return false;
								}
							}
						}
					}


					bool backendExpanded = false;
					if (indiProcNode->isNominalIndividualRepresentativeBackendDataLoaded()) {
						backendExpanded = true;
						detectIndividualNodeBackendCacheSynchronized(indiProcNode, calcAlgContext);

						if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED) && !indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION)) {

							if (allowPreprocess || mCurrentRecProcDepth < mCurrentRecProcDepthLimit) {

								if (mConfAllowBackendNeighbourExpansionBlocking) {
									indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION);
								}
								if (!expandDirectlyInfluencedIndividualNeighbourNodesFromBackendCache(indiProcNode, calcAlgContext)) {

									if (!mConfAllowBackendNeighbourExpansionBlocking) {
										indiProcNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION);
										indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION);
									}
									backendExpanded = false;
								}

								if (indiProcNode->hasPurgedBlockedProcessingRestrictionFlags()) {
									return false;
								}
							} else {
								calcAlgContext->getProcessingDataBox()->getRoleAssertionExpansionProcessingQueue(true)->insertIndiviudalProcessNode(indiProcNode);
							}
						}
					}



					if (indiProcNode->hasNominalIndividualTriplesAssertions() && !indiProcNode->areNominalIndividualTriplesAssertionsLoaded()) {

						CConcreteOntology* ontology = calcAlgContext->getUsedProcessingDataBox()->getOntology();
						COntologyTriplesData* ontologyTriplesData = ontology->getOntologyTriplesData();
						if (ontologyTriplesData) {
							COntologyTriplesAssertionsAccessor* triplesAssertionAccessor = ontologyTriplesData->getTripleAssertionAccessor();
							if (triplesAssertionAccessor && -indiProcNode->getIndividualNodeID() <= triplesAssertionAccessor->getMaxIndexedIndividualId()) {
								if (!indiProcNode->getNominalIndividual()) {
									CIndexedIndividualAssertionConvertionVisitor indiAssConvVisitor(-indiProcNode->getIndividualNodeID(), calcAlgContext);
									triplesAssertionAccessor->visitIndividualAssertions(-indiProcNode->getIndividualNodeID(), &indiAssConvVisitor);
									indiProcNode->setNominalIndividual(indiAssConvVisitor.getRetrievalIndividual());
								} else {
									CIndexedIndividualAssertionConvertionVisitor indiAssConvVisitor(indiProcNode->getNominalIndividual(), calcAlgContext);
									triplesAssertionAccessor->visitIndividualAssertions(-indiProcNode->getIndividualNodeID(), &indiAssConvVisitor);
									indiProcNode->setNominalIndividual(indiAssConvVisitor.getRetrievalIndividual());
								}
								CIndividual* nominalIndi = indiProcNode->getNominalIndividual();
								indiProcNode->setAssertionConceptLinker(nominalIndi->getAssertionConceptLinker());
								indiProcNode->setAssertionRoleLinker(nominalIndi->getAssertionRoleLinker());
								indiProcNode->setReverseAssertionRoleLinker(nominalIndi->getReverseAssertionRoleLinker());
								indiProcNode->setAssertionDataLinker(nominalIndi->getAssertionDataLinker());
							}
						}

						indiProcNode->setNominalIndividualTriplesAssertionsLoaded(true);
					}


					CConceptAssertionLinker* assertionConceptLinker = indiProcNode->getAssertionConceptLinker();
					CRoleAssertionLinker* assertionRoleLinkerIt = indiProcNode->getAssertionRoleLinker();
					CDataAssertionLinker* assertionDataLinkerIt = indiProcNode->getAssertionDataLinker();
					CReverseRoleAssertionLinker* reverseAssertionRoleLinkerIt = indiProcNode->getReverseAssertionRoleLinker();
					CAdditionalProcessRoleAssertionsLinker* addProcRoleAssertionsLinker = indiProcNode->getAdditionalRoleAssertionsLinker();
					CAdditionalProcessDataAssertionsLinker* addProcDataAssertionsLinker = indiProcNode->getAdditionalDataAssertionsLinker();
					CXSortedNegLinker<CConcept*>* initConceptLinker = indiProcNode->getProcessInitializingConceptLinker();
					CReapplyConceptLabelSet* conSet = indiProcNode->getReapplyConceptLabelSet(false);

					bool initialized = false;

					CConceptSetSignature assInitSignature;
					bool assInitSignatureBuilded = false;




					if (!indiProcNode->hasBaseConceptsInitialized()) {
						bool datatypeNode = indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE);
						if (assertionConceptLinker || initConceptLinker || !conSet) {
							for (CConceptAssertionLinker* assertionConceptLinkerIt = assertionConceptLinker; assertionConceptLinkerIt && !datatypeNode; assertionConceptLinkerIt = assertionConceptLinkerIt->getNext()) {
								CConcept* concept = assertionConceptLinkerIt->getData();
								if (concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_DATATYPE_RELATED_TYPE)) {
									datatypeNode = true;
								}
							}
							for (CXSortedNegLinker<CConcept*>* initConceptLinkerIt = initConceptLinker; initConceptLinkerIt && !datatypeNode; initConceptLinkerIt = initConceptLinkerIt->getNext()) {
								CConcept* concept = initConceptLinkerIt->getData();
								if (concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_DATATYPE_RELATED_TYPE)) {
									datatypeNode = true;
								}
							}
							if (!datatypeNode) {
								CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
								CConcept* topConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopConcept();
								addConceptToIndividual(topConcept, false, indiProcNode, depTrackPoint, allowPreprocess, true, calcAlgContext);
							} else {
								CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
								CConcept* topDataConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopDataRangeConcept();
								addConceptToIndividual(topDataConcept, false, indiProcNode, depTrackPoint, allowPreprocess, true, calcAlgContext);
								indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE);
							}
							initialized = true;
						}
						if (indiProcNode->isNominalIndividualNode()) {
							if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
								propagateIndividualNodeNominalConnectionToAncestors(indiProcNode, calcAlgContext);
							}
							//propagateIndividualNodeNominalConnectionStatusToAncestors(indiProcNode,indiProcNode,calcAlgContext);
						}
						indiProcNode->setBaseConceptsInitialized(true);
					}


					if (!indiProcNode->hasUniversallyConnectionIndividualInitialized()) {
						CConcept* univConnNomValueConcept = calcAlgContext->getProcessingDataBox()->getOntology()->getTBox()->getUniversalConnectionNominalValueConcept();
						if (univConnNomValueConcept) {
							bool datatypeNode = indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE);
							if (assertionConceptLinker || initConceptLinker || indiProcNode->getNominalIndividual()) {
								CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
								if (univConnNomValueConcept && !datatypeNode) {
									addConceptToIndividual(univConnNomValueConcept, false, indiProcNode, depTrackPoint, allowPreprocess, true, calcAlgContext);
								}
							}
							indiProcNode->setUniversallyConnectionIndividualInitialized(true);
						}
					}

					if (assertionConceptLinker) {

						CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

						for (CConceptAssertionLinker* assertionConceptLinkerIt = assertionConceptLinker; assertionConceptLinkerIt; assertionConceptLinkerIt = assertionConceptLinkerIt->getNext()) {
							CConcept* assertionConcept = assertionConceptLinkerIt->getData();
							bool assertionConceptNegation = assertionConceptLinkerIt->isNegated();
							if (assertionConcept->getOperatorCode() != CCNOMINAL) {
								assInitSignature.addConceptSignature(assertionConcept, assertionConceptNegation);
								assInitSignatureBuilded = true;
							}
						}

						if (mOptIncrementalCompatibleExpansion || !indiProcNode->isNominalIndividualRepresentativeBackendDataLoaded()) {

							addConceptsToIndividual(assertionConceptLinker,false,indiProcNode,depTrackPoint,allowPreprocess,true,nullptr,calcAlgContext);

							CIndividual* nominalIndi = indiProcNode->getNominalIndividual();
							if (nominalIndi) {
								CConcept* nominalConcept = nominalIndi->getIndividualNominalConcept();
								if (nominalConcept) {
									addConceptToIndividual(nominalConcept,false,indiProcNode,depTrackPoint,true,true,calcAlgContext);
								}
							}

						}

						initialized = true;
						indiProcNode->clearAssertionConcepts();

					}
					if (initConceptLinker) {

						if (!calcAlgContext->getUsedProcessingDataBox()->hasConstructedIndividualNodeInitialized()) {
							calcAlgContext->getUsedProcessingDataBox()->setConstructedIndividualNodeInitialized(true);
							tryCompletionGraphReuse(indiProcNode,calcAlgContext);
						}

						CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
						if (!mConfExpandCreatedSuccessorsFromSaturation || !tryInitalizingFromSaturatedData(indiProcNode,initConceptLinker,depTrackPoint,allowPreprocess,calcAlgContext) || initConceptLinker->hasNext()) {
							addConceptsToIndividual(initConceptLinker,false,indiProcNode,depTrackPoint,allowPreprocess,true,nullptr,calcAlgContext);
						}
						indiProcNode->clearProcessInitializingConcepts();
						initialized = true;
						for (CXSortedNegLinker<CConcept*>* initConceptLinkerIt = initConceptLinker; initConceptLinkerIt; initConceptLinkerIt = initConceptLinkerIt->getNext()) {
							CConcept* initConcept = initConceptLinkerIt->getData();
							bool initConceptNegation = initConceptLinkerIt->isNegated();
							if (initConcept->getOperatorCode() != CCNOMINAL) {
								assInitSignature.addConceptSignature(initConcept,initConceptNegation);
								assInitSignatureBuilded = true;
							}
						}
					}

					if (assertionRoleLinkerIt || reverseAssertionRoleLinkerIt || addProcRoleAssertionsLinker) {	

						detectIndividualNodeBackendCacheSynchronized(indiProcNode, calcAlgContext);
						if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {

							if (allowPreprocess || mCurrentRecProcDepth < mCurrentRecProcDepthLimit) {

								if (mConfAllowBackendNeighbourExpansionBlocking) {
									indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION);
								}
								if (!indiProcNode->getIndividualBackendCacheSynchronisationData(false) || !expandDirectlyInfluencedIndividualNeighbourNodesFromBackendCache(indiProcNode, calcAlgContext)) {


									if (!mConfAllowBackendNeighbourExpansionBlocking) {
										indiProcNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION);
										indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION);
									}

									indiProcNode->clearAssertionRoles();
									indiProcNode->clearReverseAssertionRoles();
									indiProcNode->clearAdditionalRoleAssertionsLinker();
									indiProcNode->clearAdditionalRoleAssertionsLinker();
									CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

									while (assertionRoleLinkerIt) {
										addRoleAssertion(indiProcNode, assertionRoleLinkerIt, depTrackPoint, calcAlgContext);
										assertionRoleLinkerIt = assertionRoleLinkerIt->getNext();
									}
									for (CAdditionalProcessRoleAssertionsLinker* addProcRoleAssertionsLinkerIt = addProcRoleAssertionsLinker; addProcRoleAssertionsLinkerIt; addProcRoleAssertionsLinkerIt = addProcRoleAssertionsLinkerIt->getNext()) {
										assertionRoleLinkerIt = addProcRoleAssertionsLinkerIt->getRoleAssertionLinker();
										CDependencyTrackPoint* addDepTrackPoint = addProcRoleAssertionsLinkerIt->getDependencyTrackPoint();
										while (assertionRoleLinkerIt) {
											addRoleAssertion(indiProcNode, assertionRoleLinkerIt, addDepTrackPoint, calcAlgContext);
											assertionRoleLinkerIt = assertionRoleLinkerIt->getNext();
										}
									}
									indiProcNode->setRoleAssertionsInitialized(true);
									while (reverseAssertionRoleLinkerIt) {
										addReverseRoleAssertion(indiProcNode, reverseAssertionRoleLinkerIt, depTrackPoint, calcAlgContext);
										reverseAssertionRoleLinkerIt = reverseAssertionRoleLinkerIt->getNext();
									}
									for (CAdditionalProcessRoleAssertionsLinker* addProcRoleAssertionsLinkerIt = addProcRoleAssertionsLinker; addProcRoleAssertionsLinkerIt; addProcRoleAssertionsLinkerIt = addProcRoleAssertionsLinkerIt->getNext()) {
										reverseAssertionRoleLinkerIt = addProcRoleAssertionsLinkerIt->getReverseRoleAssertionLinker();
										CDependencyTrackPoint* addDepTrackPoint = addProcRoleAssertionsLinkerIt->getDependencyTrackPoint();
										while (reverseAssertionRoleLinkerIt) {
											addReverseRoleAssertion(indiProcNode, reverseAssertionRoleLinkerIt, addDepTrackPoint, calcAlgContext);
											reverseAssertionRoleLinkerIt = reverseAssertionRoleLinkerIt->getNext();
										}
									}
									indiProcNode->setReverseRoleAssertionsInitialized(true);
								}

							} else {
								calcAlgContext->getProcessingDataBox()->getRoleAssertionExpansionProcessingQueue(true)->insertIndiviudalProcessNode(indiProcNode);
							}
							initialized = true;
						}

					}


					if (indiProcNode->getLastAssertedDataLiteralLinker() != indiProcNode->getAssertedDataLiteralLinker()) {
						for (CProcessAssertedDataLiteralLinker* dataLiteralLinkerIt = indiProcNode->getAssertedDataLiteralLinker(); dataLiteralLinkerIt && dataLiteralLinkerIt != indiProcNode->getLastAssertedDataLiteralLinker(); dataLiteralLinkerIt = dataLiteralLinkerIt->getNext()) {
							CDataLiteral* dataLiteral = dataLiteralLinkerIt->getDataLiteral();
							CDependencyTrackPoint* depTrackPoint = dataLiteralLinkerIt->getDependencyTrackPoint();
							if (mDatatypeHandler && mConfDatatypeReasoning) {
								mDatatypeHandler->addDataLiteral(indiProcNode, dataLiteral, false, depTrackPoint, calcAlgContext);
								CDatatype* datatype = dataLiteral->getDatatype();
								if (datatype && datatype->getDatatypeConcept()) {
									addConceptToIndividual(datatype->getDatatypeConcept(), false, indiProcNode, depTrackPoint, true, false, calcAlgContext);
								}
							}

						}
						indiProcNode->setLastAssertedDataLiteralLinker(indiProcNode->getAssertedDataLiteralLinker());
					}


					if (assertionDataLinkerIt || addProcDataAssertionsLinker) {
						CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
						while (assertionDataLinkerIt && assertionDataLinkerIt != indiProcNode->getLastProcessedAssertionDataLinker()) {
							addDataAssertion(indiProcNode, assertionDataLinkerIt, depTrackPoint, calcAlgContext);
							assertionDataLinkerIt = assertionDataLinkerIt->getNext();
						}
						indiProcNode->setLastProcessedAssertionDataLinker(indiProcNode->getAssertionDataLinker());

						if (addProcDataAssertionsLinker != indiProcNode->getLastProcessedAdditionalDataAssertionLinker()) {
							for (CAdditionalProcessDataAssertionsLinker* addProcDataAssertionsLinkerIt = indiProcNode->getAdditionalDataAssertionsLinker(); addProcDataAssertionsLinkerIt && addProcDataAssertionsLinkerIt != indiProcNode->getLastProcessedAdditionalDataAssertionLinker(); addProcDataAssertionsLinkerIt = addProcDataAssertionsLinkerIt->getNext()) {
								CDependencyTrackPoint* depTrackPoint = addProcDataAssertionsLinkerIt->getDependencyTrackPoint();
								for (CDataAssertionLinker* dataLiteralLinkerIt = addProcDataAssertionsLinkerIt->getDataAssertionLinker(); dataLiteralLinkerIt && dataLiteralLinkerIt; dataLiteralLinkerIt = dataLiteralLinkerIt->getNext()) {
									addDataAssertion(indiProcNode, dataLiteralLinkerIt, depTrackPoint, calcAlgContext);
								}
							}
							indiProcNode->setLastProcessedAdditionalDataAssertionLinker(indiProcNode->getAdditionalDataAssertionsLinker());
						}
					}

					if (assInitSignatureBuilded && mOptDetExpPreporcessing) {
						cint64 assInitSigValue = assInitSignature.getSignatureValue();
						indiProcNode->setAssertionInitialisationSignatureValue(assInitSigValue);

						STATINC(SIGNATURESAVINGCOUNT,calcAlgContext);
						CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
						CSignatureBlockingCandidateHash* sigNomDelCandHash = processingDataBox->getSignatureNominalDelayingCandidateHash(true);
						sigNomDelCandHash->insertSignatureBlockingCandidate(assInitSigValue,indiProcNode);
					}

					if (mConfAddCachedComputedConsequences && indiProcNode->isNominalIndividualNode() && !mOptIncrementalExpansion) {
						addCachedComputedTypes(indiProcNode,calcAlgContext);
					}

					return initialized;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::addCachedComputedTypes(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool addedConcepts = false;
					CIndividual* individual = indiProcNode->getNominalIndividual();
					if (individual && mCompConsCacheHandler && !indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCACHEDCOMPUTEDTYPESADDED)) {
						indiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCACHEDCOMPUTEDTYPESADDED);
						CSortedNegLinker<CConcept*>* typeConceptLinker = mCompConsCacheHandler->getCachedTypesConceptLinker(individual,calcAlgContext);
						if (typeConceptLinker) {
							CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
							CDependencyTrackPoint* expDepTrackPoint = nullptr;
							createANDDependency(expDepTrackPoint,indiProcNode,nullptr,depTrackPoint,calcAlgContext);
							addConceptsToIndividual(typeConceptLinker,false,indiProcNode,expDepTrackPoint,true,false,nullptr,calcAlgContext);
							addedConcepts = true;
						}
					}
					return addedConcepts;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::individualNodeInitializing(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* lastIndiProcNode = indiProcNode;
					indiProcNode = getLocalizedIndividual(indiProcNode,true,calcAlgContext);

					indiProcNode->setProcessingQueued(false);
					indiProcNode->setExtendedQueueProcessing(true);
					calcAlgContext->setCurrentIndividualNode(indiProcNode);


					if (mIndiNodeFromQueueType == INQT_IMMEDIATE) {
						indiProcNode->setImmediatelyProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_DELAYEDBACKENDINIT) {


						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiProcNode->getIndividualBackendCacheSynchronisationData(false);
						if (!backendSyncData->isBackendConceptSetInitializationRequired()) {


							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(true);

							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(indiProcNode, calcAlgContext);
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& processingData = (*useBackendConceptSetLabelProcessingHash)[hasher];
							processingData.decQueuedNodeInitializingCount();

							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiProcNode->getIndividualBackendCacheSynchronisationData(true);
							if (!locBackendSyncData) {
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiProcNode, calcAlgContext);
							}
							locBackendSyncData->setBackendConceptSetInitializationRequired(true);
						}
					
					} else if (mIndiNodeFromQueueType == INQT_DETEXP) {
						indiProcNode->setDeterministicExpandingProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_DEPTHNORMAL || mIndiNodeFromQueueType == INQT_NOMINAL) {
						indiProcNode->setRegularDepthProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_BLOCKREACT) {
						indiProcNode->setBlockedReactivationProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_DELAYEDNOMINAL) {
						indiProcNode->setDelayedNominalProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_BACKENDSYNCRETEST) {
						indiProcNode->setBackendSynchronRetestProcessingQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_BACKENDDIRECTINFLUENCEEXPANSION) {
						indiProcNode->setBackendDirectInfluenceExpansionQueued(false);
					} else if (mIndiNodeFromQueueType == INQT_BACKENDINDIRECTCOMPATIBILITYEXPANSION) {
						indiProcNode->setBackendIndirectCompatibilityExpansionQueued(false);
					} 


					indiProcNode->resetLastProcessingPriority();

					//if (indiProcNode->getNominalIndividual()) {
					//	if (CIRIName::getRecentIRIName(indiProcNode->getNominalIndividual()->getIndividualNameLinker()) == "#robert_david_bright_1965") {
					//		bool bug = true;
					//	}
					//}
					//} 
					if (!indiProcNode->hasPurgedBlockedProcessingRestrictionFlags()) {
						initialNodeInitialize(indiProcNode, true, calcAlgContext);


						if (mIndiNodeFromQueueType == INQT_CACHETEST) {
							testIndividualNodeUnsatisfiableCached(indiProcNode, calcAlgContext);
						} else if (mIndiNodeFromQueueType == INQT_VSTSATTESTING) {
							checkValueSpaceDistinctSatisfiability(indiProcNode, calcAlgContext);
						} else if (mIndiNodeFromQueueType == INQT_VSTRIGGERING) {
							triggerValueSpaceConcepts(indiProcNode, calcAlgContext);
						} else if (mIndiNodeFromQueueType == INQT_BACKENDEXPANSIONREUSE) {
							indiProcNode->setBackendReuseExpansionQueued(false);

							if (!indiProcNode->hasPurgedBlockedProcessingRestrictionFlags()) {
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiProcNode->getIndividualBackendCacheSynchronisationData(false);
								if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED) && !backendSyncData->getBackendExpansionReuseDependencyTrackPoint() && checkIndividualBackendExpansionReuseable(indiProcNode, calcAlgContext)) {
									CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getProcessingDataBox()->getBackendNeighbourExpansionControllingData(true);
									if (expContData->isFixedReuseExpansionMode()) {
										prepareBackendIndividualFixedReuseExpansion(indiProcNode, calcAlgContext);
									}
									if (expContData->isPrioritizedReuseExpansionMode()) {
										prepareBackendIndividualPrioritizedReuseExpansion(indiProcNode, calcAlgContext);
									}
								}
								if (!indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED)) {
									reuseIndividualBackendExpansion(indiProcNode, calcAlgContext);
								}
							}
						}



						if (isIndividualNodeProcessingBlocked(indiProcNode, calcAlgContext)) {
							eliminiateBlockedIndividuals(indiProcNode, calcAlgContext);
							return false;
						}


						// counting same concept signature
						//conSet = indiProcNode->getReapplyConceptLabelSet(false);
						//if (conSet) {
						//	cint64 sigVal = conSet->getConceptSignature()->getSignatureValue();
						//	cint64 prevCountVal = mIndiNodeInitConceptSigCountHash.value(sigVal,0);
						//	mIndiNodeInitConceptSigCountHash.insert(sigVal,prevCountVal+1);
						//}

						if (mConfSignatureSaving) {
							addSignatureIndividualNodeBlockerCandidate(indiProcNode, calcAlgContext);
						}
						return true;
					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::checkValueSpaceDistinctSatisfiability(CIndividualProcessNode* processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mDatatypeHandler && mConfDatatypeReasoning) {

						//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						//QFile file(QString("datatype-error.txt"));
						//if (file.open(QIODevice::WriteOnly)) {
						//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
						//	file.close();
						//}


						CTaskProcessorContext* taskProcessorContext = calcAlgContext->getUsedTaskProcessorContext();
						CPROCESSINGSET<CIndividualProcessNode*>* distinctIndividualNodeCollectionSet = CObjectParameterizingAllocator< CPROCESSINGSET<CIndividualProcessNode*>,CContext* >::allocateAndConstructAndParameterize(taskProcessorContext->getMemoryAllocationManager(),taskProcessorContext);
						CPROCESSINGLIST<CIndividualProcessNode*>* distinctIndividualNodeCollectionList = CObjectParameterizingAllocator< CPROCESSINGLIST<CIndividualProcessNode*>,CContext* >::allocateAndConstructAndParameterize(taskProcessorContext->getMemoryAllocationManager(),taskProcessorContext);

						if (mDatatypeHandler->requiresSatisfiabilityChecking(processIndi,calcAlgContext)) {
							distinctIndividualNodeCollectionSet->insert(processIndi);
							distinctIndividualNodeCollectionList->append(processIndi);

							while (!distinctIndividualNodeCollectionList->isEmpty()) {
								CIndividualProcessNode* distinctIndiNode = distinctIndividualNodeCollectionList->takeFirst();
								CDistinctHash* distinctHash = distinctIndiNode->getDistinctHash(false);
								if (distinctHash) {
									CDistinctIterator distinctIterator = distinctHash->getDistinctIterator();
									while (distinctIterator.hasNext()) {
										cint64 nextDistinctIndiID = distinctIterator.nextDistinctIndividualID();
										CIndividualProcessNode* nextDistinctIndiNode = getLocalizedIndividual(nextDistinctIndiID,calcAlgContext);
										if (mDatatypeHandler->involveDistinctNodeForSatisfiabilityChecking(nextDistinctIndiNode,calcAlgContext)) {
											if (!distinctIndividualNodeCollectionSet->contains(nextDistinctIndiNode)) {
												distinctIndividualNodeCollectionSet->insert(nextDistinctIndiNode);
												distinctIndividualNodeCollectionList->append(nextDistinctIndiNode);
											}
										}
									}
								}
							}		
						}

						mDatatypeHandler->checkSatisfiability(processIndi,distinctIndividualNodeCollectionSet,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::triggerValueSpaceConcepts(CIndividualProcessNode* processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mDatatypeHandler && mConfDatatypeReasoning) {
						CConceptDescriptor* triggeredConceptLinker = nullptr;


						//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						//QFile file(QString("debug-model.txt"));
						//if (file.open(QIODevice::WriteOnly)) {
						//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
						//	file.close();
						//}

						mDatatypeHandler->triggerValueSpaceConcepts(processIndi,triggeredConceptLinker,calcAlgContext);
						addtriggeredValueSpaceConcepts(processIndi, triggeredConceptLinker, calcAlgContext);
						
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::addtriggeredValueSpaceConcepts(CIndividualProcessNode* processIndi, CConceptDescriptor* triggeredConceptLinker, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptDescriptor* invTriggeredConceptLinker = nullptr;
					while (triggeredConceptLinker) {
						CConceptDescriptor* tmpTriggeredConceptLinker = triggeredConceptLinker;
						triggeredConceptLinker = triggeredConceptLinker->getNextConceptDesciptor();
						tmpTriggeredConceptLinker->clearNext();
						invTriggeredConceptLinker = tmpTriggeredConceptLinker->append(invTriggeredConceptLinker);
					}


					for (CConceptDescriptor* triggeredConceptLinkerIt = invTriggeredConceptLinker; triggeredConceptLinkerIt; triggeredConceptLinkerIt = triggeredConceptLinkerIt->getNext()) {
						CConcept* triggeredConcept = triggeredConceptLinkerIt->getConcept();
						bool triggeredNegation = triggeredConceptLinkerIt->isNegated();
						CDependencyTrackPoint* triggeredDependencyTrackPoint = triggeredConceptLinkerIt->getDependencyTrackPoint();
						addConceptToIndividual(triggeredConcept, triggeredNegation, processIndi, triggeredDependencyTrackPoint, true, false, calcAlgContext);
					}

				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::tryCompletionGraphReuse(CIndividualProcessNode* processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool minimalCompletionGraph = false;
					bool minimalCompletionGraphConnection = false;
					if (mReuseCompGraphCacheHandler && mConfCompGraphReuseCacheRetrieval) {
						STATINC(COMPLETIONGRAPHREUSECACHERETRIEVALCOUNT,calcAlgContext);

						KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(
							mComplGraphReuseCacheRetrieval.start();
						);

						CReuseCompletionGraphCacheEntry* reuseCompGraphCacheEntry = mReuseCompGraphCacheHandler->getReuseCompletionGraphEntry(processIndi,&minimalCompletionGraph,&minimalCompletionGraphConnection,calcAlgContext);

						KONCLUCE_TASK_ALGORITHM_TIME_MEASURE_INSTRUCTION(
							cint64 timeElapsed = mComplGraphReuseCacheRetrieval.elapsed();
							STATINCM(TIMECOMPLETIONGRAPHREUSERETRIVAL,timeElapsed,calcAlgContext);
						);

						if (reuseCompGraphCacheEntry) {
							STATINC(COMPLETIONGRAPHREUSECACHERETRIEVALSUCCESSCOUNT,calcAlgContext);
							CXSortedNegLinker<CConcept*>* initConceptLinkerIt = processIndi->getProcessInitializingConceptLinker();
							CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
							CSatisfiableCalculationTask* reuseSatCalcTask = (CSatisfiableCalculationTask*)reuseCompGraphCacheEntry->getJobInstantiation();
							CProcessingDataBox* reuseProcessingDataBox = reuseSatCalcTask->getProcessingDataBox();
							cint64 reuseBranchingTag = reuseProcessingDataBox->getProcessContext()->getUsedProcessTagger()->getCurrentBranchingTag();
							bool deterministicReuse = reuseBranchingTag == 0 && minimalCompletionGraph && minimalCompletionGraphConnection;


							if (!deterministicReuse && mConfCompGraphNonDeterministicReuse || deterministicReuse && mConfCompGraphDeterministicReuse) {


								cint64 taskCreationCount = 2;
								if (deterministicReuse) {
									STATINC(COMPLETIONGRAPHREUSECACHEREUSINGDETCOUNT,calcAlgContext);
									taskCreationCount = 1;
								} else {
									STATINC(COMPLETIONGRAPHREUSECACHEREUSINGNONDETCOUNT,calcAlgContext);
								}

								CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(taskCreationCount,calcAlgContext);

								CSatisfiableCalculationTask* newTaskIt = newTaskList;

								CREUSECOMPLETIONGRAPHDependencyNode* reuseDepNode = createREUSECOMPLETIONGRAPHDependency(processIndi,nullptr,nullptr,calcAlgContext);


								for (cint64 i = 0; i < taskCreationCount; ++i) {

									CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;

									bool reusingAlternative = i == 0;

									if (reusingAlternative) {

										CDependencyTrackPoint* newDependencyTrackPoint = nullptr;
										if (deterministicReuse) {
											newDependencyTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
										} else {
											newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode,false,calcAlgContext);
										}


										CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();
										newProcessingDataBox->initProcessingDataBox(reuseProcessingDataBox);

										CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
										CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
										CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

										CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
										if (!deterministicReuse) {
											newProcessTagger->incBranchingTag();
											if (!minimalCompletionGraphConnection) {
												newProcessingDataBox->setMaximumDeterministicBranchTag(-1);
											}
										}
										newProcessTagger->incLocalizationTag();


										CIndividualProcessNodeVector* indiNodeVec = newProcessingDataBox->getIndividualProcessNodeVector();
										cint64 nextIndiID = indiNodeVec->getItemMaxIndex()+1;


										CIndividualProcessNode* newIndi = CObjectParameterizingAllocator< CIndividualProcessNode,CProcessContext* >::allocateAndConstructAndParameterize(newAllocMemMan,newProcessContext);
										newIndi->setIndividualNodeID(nextIndiID);
										newIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING);
										newProcessingDataBox->setConstructedIndividualNode(newIndi);
										indiNodeVec->setData(nextIndiID,newIndi);

										addConceptsToIndividual(initConceptLinkerIt,false,newIndi,newDependencyTrackPoint,false,true,nullptr,newCalcAlgContext);

										CConcept* topConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopConcept();
										addConceptToIndividual(topConcept,false,newIndi,newDependencyTrackPoint,false,true,newCalcAlgContext);

										prepareBranchedTaskProcessing(newIndi,newSatCalcTask,newCalcAlgContext);


									} else {

										CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
										CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
										CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

										CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(processIndi,false,newCalcAlgContext);
										prepareBranchedTaskProcessing(newLocIndiNode,newSatCalcTask,newCalcAlgContext);

									}

									// set new task priority
									double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskReusing(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask(),reusingAlternative);
									newSatCalcTask->setTaskPriority(newTaskPriority);

									newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();

								}


								processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

								throw CCalculationStopProcessingException(true);
							}
						} else {
							STATINC(COMPLETIONGRAPHREUSECACHERETRIEVALFAILEDCOUNT,calcAlgContext);
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::eliminiateBlockedIndividuals(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					//if (indiProcNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDATEBLOCKERFLAGSCOMPINATION)) {
					if (indiProcNode->hasBlockedIndividualsLinker()) {
						// reactivate all blocked individuals
						reactivateBlockedIndividuals(indiProcNode,calcAlgContext);
					}
					if (indiProcNode->hasBlockingFollower()) {
						CBlockingFollowSet* followerSet = indiProcNode->getBlockingFollowSet(false);
						for (CPROCESSSET<cint64>::const_iterator it = followerSet->constBegin(), itEnd = followerSet->constEnd(); it != itEnd; ++it) {
							cint64 blockingIndiNodeID = *it;
							CIndividualProcessNode* blockingIndiNode = getUpToDateIndividual(blockingIndiNodeID,calcAlgContext);
							addIndividualToBlockingUpdateReviewProcessingQueue(blockingIndiNode,calcAlgContext);
						}
					}
					CXLinker<CIndividualProcessNode*>* processingBlockedNodeLinker = indiProcNode->getProcessingBlockedIndividualsLinker();
					while (processingBlockedNodeLinker) {
						CIndividualProcessNode* blockedNode = processingBlockedNodeLinker->getData();
						CIndividualProcessNode* locBlockedNode = getLocalizedIndividual(blockedNode,true,calcAlgContext);
						locBlockedNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEPROCESSINGCOMPLETED);
						addIndividualToProcessingQueue(locBlockedNode,calcAlgContext);
						processingBlockedNodeLinker = processingBlockedNodeLinker->getNext();
					}
					indiProcNode->clearBlockedIndividualsLinker();
					//}
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getDelayProcessingBlockingNominalNode(CIndividualProcessNode* testIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* nominalBlockerIndividual = nullptr;
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					CSignatureBlockingCandidateHash* sigNomDelCandHash = processingDataBox->getSignatureNominalDelayingCandidateHash(false);

					CReapplyConceptLabelSet* conSet = testIndi->getReapplyConceptLabelSet(false);
					if (conSet && sigNomDelCandHash) {					
						cint64 assConSig = testIndi->getAssertionInitialisationSignatureValue();
						CSignatureBlockingCandidateIterator candIt(sigNomDelCandHash->getBlockingCandidatesIterator(assConSig));
						while (!nominalBlockerIndividual && candIt.hasNext()) {
							cint64 candIndiID = candIt.next(true);
							if (candIndiID != testIndi->getIndividualNodeID()) {
								CIndividualProcessNode* candIndiNode = getUpToDateIndividual(candIndiID,calcAlgContext);
								if (candIndiNode->isNominalIndividualNode() && candIndiNode->getNominalIndividual() && !candIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {
									CReapplyConceptLabelSet* blockerConSet = candIndiNode->getReapplyConceptLabelSet(false);
									if (isLabelConceptSubSetIgnoreNominals(conSet,blockerConSet, nullptr,calcAlgContext)) {
										nominalBlockerIndividual = candIndiNode;
									}
								}
							}
						}
					}
					return nominalBlockerIndividual;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryDelayNominalProcessing(CConceptProcessDescriptor* conProDes, CIndividualProcessNode* testIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (canDelayNominalProcessing(conProDes,testIndi,calcAlgContext)) {
						testIndi->setNominalProcessingDelayingChecked(true);

						bool notConnectedNominal = false;
						CSuccessorIterator succIt(testIndi->getSuccessorIterator());
						if (!succIt.hasNext()) {
							notConnectedNominal = true;
						}

						if (notConnectedNominal) {
							CIndividualProcessNode* blockerNominalIndiNode = getDelayProcessingBlockingNominalNode(testIndi,calcAlgContext);
							if (blockerNominalIndiNode) {
								CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
								CIndividualUnsortedProcessingQueue* delayingNominalProcessingQueu = processingDataBox->getDelayingNominalProcessingQueue(true);
								delayingNominalProcessingQueu->insertIndiviudalProcessNode(testIndi);
								testIndi->setDelayedNominalProcessingQueued(true);
								return true;
							}
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::canDelayNominalProcessing(CConceptProcessDescriptor* conProDes, CIndividualProcessNode* testIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (testIndi->isNominalIndividualNode() && testIndi->getNominalIndividual()) {
						if (conProDes->getProcessPriority() < mImmediatelyProcessPriority) {
							if (!testIndi->hasNominalProcessingDelayingChecked()) {
								return true;
							}
						}
					}
					return false;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::individualNodeConclusion(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mIndiNodeConcludeUnsatCaching) {
						testIndividualNodeUnsatisfiableCached(indiProcNode,calcAlgContext);
					}

					calcAlgContext->setCurrentIndividualNode(nullptr);
					addIndividualToProcessingQueue(indiProcNode,calcAlgContext);

					//CConceptProcessingQueue* conProQue = indiProcNode->getConceptProcessingQueue(false);
					//if (nodeProcessingBreaked && conProQue && !conProQue->isEmpty()) {
					//	addIndividualToProcessingQueue(indiProcNode,false,calcAlgContext);
					//} else if (!conProQue || conProQue->isEmpty()) {
					//	propagateIndividualProcessedAndReactivate(indiProcNode,calcAlgContext);
					//}
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::tableauRuleProcessing(CIndividualProcessNode*& indiProcNode,CConceptProcessDescriptor*& conProcDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProcDes->getConceptDescriptor();
					bool conNeg = conDes->getNegation();
					CConcept* concept = conDes->getConcept();
					cint64 conOpCode = concept->getOperatorCode();

					if (tryDelayNominalProcessing(conProcDes,indiProcNode,calcAlgContext)) {
						return false;
					}

					if (needsIndividualNodeExpansionBlockingTest(conProcDes,indiProcNode,calcAlgContext)) {
						if (isIndividualNodeBackendCacheSynchronizationProcessingBlocked(indiProcNode,calcAlgContext)) {
							return false;
						}
						if (isIndividualNodeExpansionBlocked(indiProcNode,calcAlgContext)) {
							return false;
						}
					}


					tableauRuleChoice(indiProcNode,conProcDes,calcAlgContext);

					return true;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::tableauRuleChoice(CIndividualProcessNode*& indiProcNode,CConceptProcessDescriptor*& conProcDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProcDes->getConceptDescriptor();
					bool conNeg = conDes->getNegation();
					CConcept* concept = conDes->getConcept();
					cint64 conOpCode = concept->getOperatorCode();

					++mCurrentRecProcDepth;


					TableauRuleFunction func = nullptr;
					if (!conNeg) {
						func = mPosJumpFuncVec[conOpCode];
						if (func) {
							(this->*func)(indiProcNode,conProcDes,false,calcAlgContext);
						}
						mLastJumpFunc = func;
					} else {
						func = mNegJumpFuncVec[conOpCode];
						if (func) {
							(this->*func)(indiProcNode,conProcDes,true,calcAlgContext);
						}
						mLastJumpFunc = func;
					}


					--mCurrentRecProcDepth;

				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegAutomatChooseRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyAutomatChooseRule(processIndi,conProDes,!negate,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyANDRule(processIndi,conProDes,!negate,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegSOMERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applySOMERule(processIndi,conProDes,!negate,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyALLRule(processIndi,conProDes,!negate,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegORRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyORRule(processIndi,conProDes,!negate,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegATMOSTRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyATLEASTRule(processIndi,conProDes,negate,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNegATLEASTRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					applyATMOSTRule(processIndi,conProDes,negate,calcAlgContext);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatChooseRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(AUTOMATEINITCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					CAUTOMATCHOOSEDependencyNode* andDepNode = createAUTOMATCHOOSEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);

					while (conceptOpLinkerIt) {
						CConcept* opConcept = conceptOpLinkerIt->getData();
						bool opNegation = conceptOpLinkerIt->isNegated();
						if (opNegation == negate) {
							addConceptToIndividual(opConcept,false,processIndi,nextDepTrackPoint,true,false,calcAlgContext);
						}
						conceptOpLinkerIt = conceptOpLinkerIt->getNext();
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();

					applyAutomatTransactions(processIndi,conProDes,concept,negate,calcAlgContext);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isRestrictedTopObjectPropertyPropagation(CIndividualProcessNode*& processIndi, CIndividualProcessNode*& destIndi, CConcept* concept, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableTaskAnswererBindingPropagationAdapter* answererMessageAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableAnswererBindingPropagationAdapter();
					if (answererMessageAdapter) {
						CAnsweringPropagationSteeringController* propagationSteeringController = answererMessageAdapter->getAnswererPropagationSteeringController();
						if (propagationSteeringController) {
							if (propagationSteeringController->isRestrictedTopPropagation(concept)) {
								cint64 univConnIndiId = calcAlgContext->getProcessingDataBox()->getOntology()->getABox()->getUniversalConnectionIndividualID();
								if (processIndi->getIndividualNodeID() == -univConnIndiId || destIndi->getIndividualNodeID() == -univConnIndiId || processIndi->getNominalIndividual() && destIndi->getNominalIndividual() || destIndi->getNominalIndividual()) {
									return true;
								}
							}
						}
					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyAutomatTransactions(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, CConcept* concept, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(AUTOMATERULEAPPLICATIONCOUNT,calcAlgContext);

					CConceptDescriptor* baseConDes = conProDes->getConceptDescriptor();
					bool reapplied = conProDes->isConceptReapplied();
					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();


					cint64 opCode = concept->getOperatorCode();
					CSortedNegLinker<CConcept*>* opConcepts = concept->getOperandList();
					if (opCode == CCAQAND || opCode == CCIMPLAQAND || opCode == CCBRANCHAQAND) {
						while (opConcepts) {
							++mAppliedALLRuleCount;
							STATINC(AUTOMATESTATECOUNT,calcAlgContext);
							CConcept* opCon = opConcepts->getData();
							bool opConNeg = opConcepts->isNegated();
							applyAutomatTransactions(processIndi,conProDes,opCon,opConNeg,calcAlgContext);
							opConcepts = opConcepts->getNext();
						}
					} else if (opCode == CCAQALL || opCode == CCIMPLAQALL || opCode == CCBRANCHAQALL) {
						CRole* role = concept->getRole();


						if (restLink) {
							if (restLink->getLinkRole() == role) {
								++mAppliedALLRuleCount;
								STATINC(AUTOMATETRANSACTIONCOUNT,calcAlgContext);

								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CAUTOMATTRANSACTIONDependencyNode* allDepNode = nullptr;
								bool allDepNodeCreated = false;

								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,restLink,calcAlgContext);
								if (!isRestrictedTopObjectPropertyPropagation(processIndi, succIndi, concept, negated, calcAlgContext)) {
									CIndividualProcessNode* locSuccIndi = nullptr;
									CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);
									CSortedNegLinker<CConcept*>* conceptOpLinkerIt = opConcepts;
									while (conceptOpLinkerIt) {
										CConcept* opConcept = conceptOpLinkerIt->getData();
										bool opConNeg = conceptOpLinkerIt->isNegated() ^ negated;
										if (!conLabelSet->containsConcept(opConcept, opConNeg)) {

											// create dependency
											if (!allDepNodeCreated) {
												allDepNodeCreated = true;
												allDepNode = createAUTOMATTRANSACTIONDependency(nextDepTrackPoint, processIndi, baseConDes, depTrackPoint, restLink->getDependencyTrackPoint(), calcAlgContext);
											}

											// add concept
											if (!locSuccIndi) {
												locSuccIndi = getLocalizedIndividual(succIndi, false, calcAlgContext);
												conLabelSet = locSuccIndi->getReapplyConceptLabelSet(true);
											}
											addConceptToIndividual(opConcept, opConNeg, locSuccIndi, nextDepTrackPoint, true, true, calcAlgContext);
										}
										conceptOpLinkerIt = conceptOpLinkerIt->getNext();
									}
									if (locSuccIndi) {
										addIndividualToProcessingQueue(locSuccIndi, calcAlgContext);
									}
								}
							}
						} else {
							CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
							if (roleSuccHash) {
								CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
								while (roleSuccIt.hasNext()) {
									++mAppliedALLRuleCount;
									STATINC(AUTOMATETRANSACTIONCOUNT,calcAlgContext);

									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CAUTOMATTRANSACTIONDependencyNode* allDepNode = nullptr;
									bool allDepNodeCreated = false;

									CIndividualLinkEdge* link = roleSuccIt.next(true);
									CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
									if (!isRestrictedTopObjectPropertyPropagation(processIndi, succIndi, concept, negated, calcAlgContext)) {
										CIndividualProcessNode* locSuccIndi = nullptr;
										CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);
										CSortedNegLinker<CConcept*>* conceptOpLinkerIt = opConcepts;
										while (conceptOpLinkerIt) {
											CConcept* opConcept = conceptOpLinkerIt->getData();
											bool opConNeg = conceptOpLinkerIt->isNegated() ^ negated;
											if (!conLabelSet->containsConcept(opConcept, opConNeg)) {

												// create dependency
												if (!allDepNodeCreated) {
													allDepNodeCreated = true;
													allDepNode = createAUTOMATTRANSACTIONDependency(nextDepTrackPoint, processIndi, baseConDes, depTrackPoint, link->getDependencyTrackPoint(), calcAlgContext);
												}

												// add concept
												if (!locSuccIndi) {
													locSuccIndi = getLocalizedIndividual(succIndi, false, calcAlgContext);
													conLabelSet = locSuccIndi->getReapplyConceptLabelSet(true);
												}
												addConceptToIndividual(opConcept, opConNeg, locSuccIndi, nextDepTrackPoint, true, true, calcAlgContext);
											}
											conceptOpLinkerIt = conceptOpLinkerIt->getNext();
										}
										if (locSuccIndi) {
											addIndividualToProcessingQueue(locSuccIndi, calcAlgContext);
										}
									}
								}
							}
						}
						if (!reapplied) {
							// add to reapply queue
							addConceptToReapplyQueue(baseConDes,role,processIndi,true,depTrackPoint,calcAlgContext);
						}
					} else if (!reapplied) {
						addConceptToIndividual(concept,negated,processIndi,depTrackPoint,true,true,calcAlgContext);
					}

				}


				CREPRESENTATIVEGROUNDINGDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEGROUNDINGDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CVariableBindingPath* selectVarBindPath, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEGROUNDINGDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEGROUNDINGDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,selectVarBindPath,calcAlgContext);
					}
					return depNode;
				}

				CREPRESENTATIVEJOINDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEJOINDependency(CDependencyTrackPoint*& joinContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* otherDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEJOINDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEJOINDependency(joinContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,otherDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CREPRESENTATIVEBINDVARIABLEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEBINDVARIABLEDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEBINDVARIABLEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEBINDVARIABLEDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CREPRESENTATIVEIMPLICATIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEIMPLICATIONDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEIMPLICATIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEIMPLICATIONDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CREPRESENTATIVEALLDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEALLDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEALLDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEALLDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CREPRESENTATIVEANDDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREPRESENTATIVEANDDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREPRESENTATIVEANDDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREPRESENTATIVEANDDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CRESOLVEREPRESENTATIVEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createRESOLVEREPRESENTATIVEDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CRepresentativeVariableBindingPathMap* resolveVarBindPathMap, CRepresentativePropagationMap* resolveRepPropMap, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* additionalDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CRESOLVEREPRESENTATIVEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createRESOLVEREPRESENTATIVEDependency(andDepTrackPoint,processIndi,conDes,resolveVarBindPathMap,resolveRepPropMap,prevDepTrackPoint,additionalDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}










				CPROPAGATEVARIABLECONNECTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATEVARIABLECONNECTIONDependency(CIndividualProcessNode* processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATEVARIABLECONNECTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATEVARIABLECONNECTIONDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDPROPAGATEIMPLICATIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDPROPAGATEIMPLICATIONDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDPROPAGATEIMPLICATIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDPROPAGATEIMPLICATIONDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDPROPAGATEGROUNDINGDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDPROPAGATEGROUNDINGDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDPROPAGATEGROUNDINGDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDPROPAGATEGROUNDINGDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDPROPAGATEALLDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDPROPAGATEALLDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDPROPAGATEALLDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDPROPAGATEALLDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDPROPAGATEANDDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDPROPAGATEANDDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDPROPAGATEANDDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDPROPAGATEANDDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATEVARIABLEBINDINGDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATEVARIABLEBINDINGDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATEVARIABLEBINDINGDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATEVARIABLEBINDINGDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATEVARIABLEBINDINGSSUCCESSORDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATEVARIABLEBINDINGSSUCCESSORDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATEVARIABLEBINDINGSSUCCESSORDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATEVARIABLEBINDINGSSUCCESSORDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDVARIABLEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDVARIABLEDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDVARIABLEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDVARIABLEDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CVARBINDPROPAGATEJOINDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVARBINDPROPAGATEJOINDependency(CDependencyTrackPoint*& continueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* otherDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVARBINDPROPAGATEJOINDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVARBINDPROPAGATEJOINDependency(continueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,otherDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}






				CBINDPROPAGATEGROUNDINGDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDPROPAGATEGROUNDINGDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDPROPAGATEGROUNDINGDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDPROPAGATEGROUNDINGDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATECONNECTIONAWAYDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATECONNECTIONAWAYDependency(CIndividualProcessNode* processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATECONNECTIONAWAYDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATECONNECTIONAWAYDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATECONNECTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATECONNECTIONDependency(CIndividualProcessNode* processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATECONNECTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATECONNECTIONDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CBINDPROPAGATECYCLEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDPROPAGATECYCLEDependency(CDependencyTrackPoint*& continueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* triggDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDPROPAGATECYCLEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDPROPAGATECYCLEDependency(continueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,triggDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CBINDPROPAGATEALLDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDPROPAGATEALLDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDPROPAGATEALLDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDPROPAGATEALLDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATEBINDINGSSUCCESSORDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATEBINDINGSSUCCESSORDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATEBINDINGSSUCCESSORDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATEBINDINGSSUCCESSORDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CBINDPROPAGATEIMPLICATIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDPROPAGATEIMPLICATIONDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDPROPAGATEIMPLICATIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDPROPAGATEIMPLICATIONDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CANDDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createANDDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CANDDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createANDDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CBINDPROPAGATEANDDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDPROPAGATEANDDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDPROPAGATEANDDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDPROPAGATEANDDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CPROPAGATEBINDINGDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createPROPAGATEBINDINGDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROPAGATEBINDINGDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createPROPAGATEBINDINGDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}

				CBINDVARIABLEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createBINDVARIABLEDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBINDVARIABLEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createBINDVARIABLEDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CNOMINALDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createNOMINALDependency(CDependencyTrackPoint*& nominalContDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* nominalDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CNOMINALDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createNOMINALDependency(nominalContDepTrackPoint,processIndi,conDes,prevDepTrackPoint,nominalDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CAUTOMATCHOOSEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createAUTOMATCHOOSEDependency(CDependencyTrackPoint*& andDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CAUTOMATCHOOSEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createAUTOMATCHOOSEDependency(andDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CSOMEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createSOMEDependency(CDependencyTrackPoint*& someDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSOMEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createSOMEDependency(someDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CSELFDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createSELFDependency(CDependencyTrackPoint*& someDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSELFDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createSELFDependency(someDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CVALUEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createVALUEDependency(CDependencyTrackPoint*& valueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* nominalDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CVALUEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createVALUEDependency(valueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,nominalDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CROLEASSERTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createROLEASSERTIONDependency(CDependencyTrackPoint*& valueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* nominalDepTrackPoint, CRole* baseAssertionRole, CIndividual* baseAssertionIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CROLEASSERTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createROLEASSERTIONDependency(valueDepTrackPoint,processIndi,prevDepTrackPoint,nominalDepTrackPoint, baseAssertionRole, baseAssertionIndi ,calcAlgContext);
					}
					return depNode;
				}

				CDATAASSERTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createDATAASSERTIONDependency(CDependencyTrackPoint*& valueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CDATAASSERTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createDATAASSERTIONDependency(valueDepTrackPoint, processIndi, prevDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}

				CNEGVALUEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createNEGVALUEDependency(CDependencyTrackPoint*& negValueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* nominalDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CNEGVALUEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createNEGVALUEDependency(negValueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,nominalDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CALLDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createALLDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CALLDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createALLDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CMERGEDCONCEPTDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createMERGEDCONCEPTDependency(CDependencyTrackPoint*& mergedConceptContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* mergePrevDepTrackPoint, CDependencyTrackPoint* conceptPrevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMERGEDCONCEPTDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createMERGEDCONCEPTDependency(mergedConceptContinueDepTrackPoint,processIndi,conDes,mergePrevDepTrackPoint,conceptPrevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CMERGEDLINKDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createMERGEDLINKDependency(CDependencyTrackPoint*& mergedLinkContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* mergePrevDepTrackPoint, CDependencyTrackPoint* linkPrevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMERGEDLINKDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createMERGEDLINKDependency(mergedLinkContinueDepTrackPoint,processIndi,mergePrevDepTrackPoint,linkPrevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}


				CMERGEDIndividualDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createMERGEDINDIVIDUALDependency(CDependencyTrackPoint*& mergedIndividualContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* mergePrevDepTrackPoint, CDependencyTrackPoint* individualPrevDepTrackPoint, CCalculationAlgorithmContext* calcAlgContext) {
					CMERGEDIndividualDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createMERGEDINDIVIDUALDependency(mergedIndividualContinueDepTrackPoint,processIndi,mergePrevDepTrackPoint,individualPrevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}


				CFUNCTIONALDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createFUNCTIONALDependency(CDependencyTrackPoint*& functionalContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* prevLink1DependencyTrackPoint, CDependencyTrackPoint* prevLink2DependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CFUNCTIONALDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createFUNCTIONALDependency(functionalContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevLink1DependencyTrackPoint,prevLink2DependencyTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CDISTINCTDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createDISTINCTDependency(CDependencyTrackPoint*& distinctDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CDISTINCTDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createDISTINCTDependency(distinctDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CAUTOMATTRANSACTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createAUTOMATTRANSACTIONDependency(CDependencyTrackPoint*& allDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* linkDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CAUTOMATTRANSACTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createAUTOMATTRANSACTIONDependency(allDepTrackPoint,processIndi,conDes,prevDepTrackPoint,linkDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CATLEASTDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createATLEASTDependency(CDependencyTrackPoint*& atleastDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CATLEASTDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createATLEASTDependency(atleastDepTrackPoint,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CORDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createORDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CORDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createORDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CATMOSTDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createATMOSTDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CATMOSTDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createATMOSTDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CMERGEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createMERGEDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMERGEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createMERGEDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CREUSEINDIVIDUALDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSEINDIVIDUALDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEINDIVIDUALDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSEINDIVIDUALDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CREUSECOMPLETIONGRAPHDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSECOMPLETIONGRAPHDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSECOMPLETIONGRAPHDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSECOMPLETIONGRAPHDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}



				CMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode(CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CIndividualProcessNode* mergingIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createMERGEPOSSIBLEINSTANCEINDIVIDUALDependencyNode(processIndi, prevDepTrackPoint, mergingIndi, calcAlgContext);
					}
					return depNode;
				}

				CREUSECONCEPTSDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSECONCEPTSDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSECONCEPTSDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSECONCEPTSDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}

				CQUALIFYDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createQUALIFYDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CQUALIFYDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createQUALIFYDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}



				CORONLYOPTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createORONLYOPTIONDependency(CDependencyTrackPoint*& orContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CORONLYOPTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createORONLYOPTIONDependency(orContinueDepTrackPoint, processIndi, conDes, prevDepTrackPoint, prevOtherDependencies, calcAlgContext);
					}
					return depNode;
				}


				CIMPLICATIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createIMPLICATIONDependency(CDependencyTrackPoint*& implContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIMPLICATIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createIMPLICATIONDependency(implContinueDepTrackPoint,processIndi,conDes,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}


				CEXPANDEDDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createEXPANDEDDependency(CDependencyTrackPoint*& expContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CDependency* prevOtherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CEXPANDEDDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createEXPANDEDDependency(expContinueDepTrackPoint,processIndi,prevDepTrackPoint,prevOtherDependencies,calcAlgContext);
					}
					return depNode;
				}


				CCONNECTIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createCONNECTIONDependency(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CCONNECTIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createCONNECTIONDependency(processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					}
					return depNode;
				}


				CSAMEINDIVIDUALSMERGEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createSAMEINDIVIDUALMERGEDependency(CDependencyTrackPoint*& expContinueDepTrackPoint, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* prevOtherDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSAMEINDIVIDUALSMERGEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createSAMEINDIVIDUALMERGEDependency(expContinueDepTrackPoint, processIndi, prevDepTrackPoint, prevOtherDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}




				CREUSEBACKENDEXPANSIONMODESDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSEBACKENDEXPANSIONMODESDependency(CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEBACKENDEXPANSIONMODESDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSEBACKENDEXPANSIONMODESDependency(prevDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}


				CREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependency(CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependency(processIndi, prevDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}


				CREUSEBACKENDPRIORITIZEDINDIVIDUALEXPANSIONDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSEBACKENDPRIORITIZEDINDIVIDUALEXPANSIONDependency(CIndividualProcessNode*& processIndi, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEBACKENDPRIORITIZEDINDIVIDUALEXPANSIONDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSEBACKENDPRIORITIZEDINDIVIDUALEXPANSIONDependency(processIndi, prevDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}




				CREUSEBACKENDVALUEDependencyNode* CCalculationTableauCompletionTaskHandleAlgorithm::createREUSEBACKENDVALUEDependency(CDependencyTrackPoint*& valueDepTrackPoint, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CDependencyTrackPoint* nominalDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CREUSEBACKENDVALUEDependencyNode* depNode = nullptr;
					if (mConfBuildDependencies) {
						depNode = calcAlgContext->getUsedDependencyFactory()->createREUSEBACKENDVALUEDependency(valueDepTrackPoint, processIndi, conDes, prevDepTrackPoint, nominalDepTrackPoint, calcAlgContext);
					}
					return depNode;
				}












































				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEGROUNDINGRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();
					bool negated = conDes->isNegated();
					cint64 opCount = concept->getOperandCount();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CConceptRepresentativePropagationSetHash* repPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(false);
					CRepresentativePropagationSet* repPropSet = repPropSetHash->getRepresentativePropagationSet(concept,false);

					STATINC(VARBINDRULEGROUNDINGAPPLICATIONCOUNT,calcAlgContext);

					if (repPropSet) {

						CRepresentativePropagationDescriptor* outRepPropDes = repPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
						if (outRepPropDes) {
							CRepresentativeVariableBindingPathSetData* repVarBindPathSetData = outRepPropDes->getRepresentativeVariableBindingPathSetData();
							if (repVarBindPathSetData) {
								CRepresentativeVariableBindingPathSetMigrateData* repVarBindPathSetMigData = repVarBindPathSetData->getMigrateData(false);
								if (repVarBindPathSetMigData) {
									CRepresentativeVariableBindingPathMap* repVarBindPathSetMap = repVarBindPathSetMigData->getRepresentativeVariableBindingPathMap();

									KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));

									CPROCESSINGHASH<CConcept*,CVariableBindingPath*>* groundedConVarBindPathHash = nullptr;
									CSortedNegLinker<CConcept*>* newGroundedLinker = mGroundingHandler->getGroundingConceptLinker(processIndi,repVarBindPathSetMap,concept,negated,groundedConVarBindPathHash,calcAlgContext);

									if (newGroundedLinker) {
										for (CSortedNegLinker<CConcept*>* newGroundedLinkerIt = newGroundedLinker; newGroundedLinkerIt; newGroundedLinkerIt = newGroundedLinkerIt->getNext()) {
											STATINC(VARBINDGROUNDINGCOUNT,calcAlgContext);
											++mStatRepresentativeGroundingCount;
											CConcept* newGroundedCocnept = newGroundedLinkerIt->getData();
											bool newGroundedConceptNegation = newGroundedLinkerIt->isNegated();

											CVariableBindingPath* selectedVarBindPath = groundedConVarBindPathHash->value(newGroundedCocnept);

											CDependencyTrackPoint* nextDepTrackPoint = nullptr;
											CREPRESENTATIVEGROUNDINGDependencyNode* groundingDepNode = createREPRESENTATIVEGROUNDINGDependency(nextDepTrackPoint,processIndi,conDes,outRepPropDes->getDependencyTrackPoint(),selectedVarBindPath,calcAlgContext);

											addConceptToIndividual(newGroundedCocnept,newGroundedConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);

										}
									}

									KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mAfterGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));

								}
							}
						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEJOINRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();


					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* joinConDes = nullptr;
					CDependencyTrackPoint* joinDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* joinConcept = opLinker->getData();
					bool joinConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();

					CSortedLinker<CVariable*>* varLinker = concept->getVariableLinker();

					STATINC(VARBINDRULEJOINAPPLICATIONCOUNT,calcAlgContext);

					bool propagateJoins = false;
					bool createJoinConcept = false;
					if (!conSet->getConceptDescriptorAndReapplyQueue(joinConcept,joinConDes,joinDepTrackPoint,reapplyQueue)) {
						// search next not existing trigger
						bool allTriggersAvailable = true;
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CSortedNegLinker<CConcept*>* triggerLinkerIt = nullptr;
						for (triggerLinkerIt = triggerLinker; triggerLinkerIt && allTriggersAvailable; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
								if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
									return;
								}
							} else {
								allTriggersAvailable = false;
								break;
							}
						}

						if (!allTriggersAvailable) {
							// install to trigger
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							bool triggerNegation = !nextTrigger->isNegated();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						} else {
							propagateJoins = true;
							createJoinConcept = true;
						}
					} else {
						propagateJoins = true;
					}

					//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);

					bool propagationsDone = false;
					if (propagateJoins) {

						for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,false,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,false,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						}

						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(false);
						CConceptRepresentativePropagationSetHash* repPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(false);
						CPropagationBindingSet* propBindingSet = nullptr;
						if (conPropBindingSetHash && repPropSetHash) {
							propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							if (propBindingSet) {

								CPropagationRepresentativeTransitionExtension* propRepTransExt = propBindingSet->getPropagationRepresentativeTransitionExtension(false);

								CSortedNegLinker<CConcept*>* leftTriggerLinker = triggerLinker;
								CSortedNegLinker<CConcept*>* rightTriggerLinker = triggerLinker->getNext();

								CConcept* leftConcept = leftTriggerLinker->getData();
								CConcept* rightConcept = rightTriggerLinker->getData();

								CRepresentativePropagationSet* leftRepPropSet = repPropSetHash->getRepresentativePropagationSet(leftConcept,false);
								CRepresentativePropagationSet* rightRepPropSet = repPropSetHash->getRepresentativePropagationSet(rightConcept,false);

								bool examineTransExt = false;


								CRepresentativePropagationDescriptor* leftRepPropDes = leftRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
								CRepresentativePropagationDescriptor* rightRepPropDes = rightRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();

								if (leftRepPropSet && rightRepPropSet && leftRepPropDes && rightRepPropDes) {

									if (!propRepTransExt) {
										examineTransExt = true;
									} else {
										if (propRepTransExt->getLastAnalysedPropagateAllFlag() != propBindingSet->getPropagateAllFlag() ||
													propRepTransExt->getLastAnalysedPropagationBindingDescriptor() != propBindingSet->getPropagationBindingDescriptorLinker() || 
													propRepTransExt->getLeftLastRepresentativeJoiningDescriptor() != leftRepPropDes || 
													propRepTransExt->getRightLastRepresentativeJoiningDescriptor() != rightRepPropDes) {

											examineTransExt = true;
										}
									}
								}

								if (examineTransExt) {
									++mStatRepresentativeJoinCount;

									conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
									repPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(true);
									propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,true);
									propRepTransExt = propBindingSet->getPropagationRepresentativeTransitionExtension(true);

									CRepresentativePropagationSet* joinRepPropSet = repPropSetHash->getRepresentativePropagationSet(joinConcept,true);

									CPropagationBindingDescriptor* lastAnalyPropBindDes = propRepTransExt->getLastAnalysedPropagationBindingDescriptor();
									CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();

									bool propAllFlag = propBindingSet->hasPropagateAllFlag();

									CRepresentativeVariableBindingPathSetData* leftRepData = leftRepPropDes->getRepresentativeVariableBindingPathSetData();
									CRepresentativeVariableBindingPathSetData* rightRepData = rightRepPropDes->getRepresentativeVariableBindingPathSetData();


									if (areRepresentativesJoinable(processIndi,leftRepData,rightRepData,varLinker,calcAlgContext)) {

										CRepresentativeJoiningData* joinData = nullptr;
										CRepresentativeJoiningData* locJoinData = nullptr;
										CRepresentativeJoiningHash* repJoiningHash = procDataBox->getRepresentativeJoiningHash(false);
										if (repJoiningHash) {
											joinData = repJoiningHash->getRepresentativeJoiningData(leftRepData,rightRepData,false);
										}

										if (!joinData) {

											CRepresentativeVariableBindingPathSetHash* repVarBindPathSetHash = nullptr;
											if (!leftRepData->hasJoiningData(concept)) {
												if (!repVarBindPathSetHash) {
													repVarBindPathSetHash = procDataBox->getRepresentativeVariableBindingPathSetHash(true);
												}
												leftRepData = repVarBindPathSetHash->getRepresentativeVariableBindingPathSetData(leftRepData,true);
											}
											if (!rightRepData->hasJoiningData(concept)) {
												if (!repVarBindPathSetHash) {
													repVarBindPathSetHash = procDataBox->getRepresentativeVariableBindingPathSetHash(true);
												}
												rightRepData = repVarBindPathSetHash->getRepresentativeVariableBindingPathSetData(rightRepData,true);
											}

											if (!locJoinData) {
												repJoiningHash = procDataBox->getRepresentativeJoiningHash(true);
												locJoinData = repJoiningHash->getRepresentativeJoiningData(leftRepData,rightRepData,true);
												joinData = locJoinData;
											}

											CRepresentativeVariableBindingPathSetJoiningKeyMap* leftJoiningKeyMap = getRepresentativeJoiningKeyData(leftRepData,concept,calcAlgContext);
											CRepresentativeVariableBindingPathSetJoiningKeyMap* rightJoiningKeyMap = getRepresentativeJoiningKeyData(rightRepData,concept,calcAlgContext);

											CRepresentativeJoiningCommonKeyMap* repJoinCommonKeyMap = joinData->getRepresentativeJoiningCommonKeyMap();

											createCommonJoiningKeyMap(repJoinCommonKeyMap,leftJoiningKeyMap,leftRepData,rightJoiningKeyMap,rightRepData,true,calcAlgContext);
										}

										CRepresentativeJoiningCommonKeyMap* repJoinCommonKeyMap = joinData->getRepresentativeJoiningCommonKeyMap();
										if (!repJoinCommonKeyMap->isEmpty()) {
											++mStatRepresentativeJoinedCount;

											if (propAllFlag) {
												CRepresentativeJoiningAllDataExtension* joinAllExtData = joinData->getJoiningAllExtension(false);
												if (!joinAllExtData) {
													if (!locJoinData) {
														repJoiningHash = procDataBox->getRepresentativeJoiningHash(true);
														locJoinData = repJoiningHash->getRepresentativeJoiningData(leftRepData,rightRepData,true);
														joinData = locJoinData;
													}

													joinAllExtData = joinData->getJoiningAllExtension(true);

													createCommonJoiningAll(joinData->getRepresentativeJoiningCommonKeyMap(),joinAllExtData,leftRepData,rightRepData,calcAlgContext);
												}

												CRepresentativeVariableBindingPathSetData* joinedRepData = joinAllExtData->getRepresentativeVariableBindingPathSetData();

												CRepresentativePropagationMap* leftRepPropMap = propRepTransExt->getLeftRepresentativePropagationMap();
												CRepresentativePropagationMap* rightRepPropMap = propRepTransExt->getRightRepresentativePropagationMap();
												if (!leftRepPropMap->contains(leftRepData->getRepresentativeID())) {
													CDependencyTrackPoint* nextDepTrackPoint = nullptr;
													CREPRESENTATIVEANDDependencyNode* repPropDepNode = createREPRESENTATIVEANDDependency(nextDepTrackPoint,processIndi,conDes,leftRepPropDes->getDependencyTrackPoint(),calcAlgContext);
													CRepresentativePropagationDescriptor* propagateRepDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);
													propagateRepDes->initRepresentativeDescriptor(leftRepData,nextDepTrackPoint);
													leftRepPropMap->insert(leftRepData->getRepresentativeID(),CRepresentativePropagationMapData(propagateRepDes));
												}
												if (!rightRepPropMap->contains(rightRepData->getRepresentativeID())) {
													CDependencyTrackPoint* nextDepTrackPoint = nullptr;
													CREPRESENTATIVEANDDependencyNode* repPropDepNode = createREPRESENTATIVEANDDependency(nextDepTrackPoint,processIndi,conDes,rightRepPropDes->getDependencyTrackPoint(),calcAlgContext);
													CRepresentativePropagationDescriptor* propagateRepDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);
													propagateRepDes->initRepresentativeDescriptor(rightRepData,nextDepTrackPoint);
													rightRepPropMap->insert(rightRepData->getRepresentativeID(),CRepresentativePropagationMapData(propagateRepDes));
												}

												CDependencyTrackPoint* leftNextResolveDepTrackPoint = nullptr;
												CRESOLVEREPRESENTATIVEDependencyNode* leftResolveRepNode = createRESOLVEREPRESENTATIVEDependency(leftNextResolveDepTrackPoint,processIndi,nullptr,joinAllExtData->getLeftResolveVariableBindingPathMap(false),leftRepPropMap,leftRepPropDes->getDependencyTrackPoint(),nullptr,calcAlgContext);
												
												CDependencyTrackPoint* rightNextResolveDepTrackPoint = nullptr;
												CRESOLVEREPRESENTATIVEDependencyNode* rightResolveRepNode = createRESOLVEREPRESENTATIVEDependency(rightNextResolveDepTrackPoint,processIndi,nullptr,joinAllExtData->getRightResolveVariableBindingPathMap(false),rightRepPropMap,rightRepPropDes->getDependencyTrackPoint(),nullptr,calcAlgContext);

												CDependencyTrackPoint* joinNextDepTrackPoint = nullptr;
												CREPRESENTATIVEJOINDependencyNode* joinResolveRepNode = createREPRESENTATIVEJOINDependency(joinNextDepTrackPoint,processIndi,conDes,leftNextResolveDepTrackPoint,rightNextResolveDepTrackPoint,calcAlgContext);

												CRepresentativePropagationDescriptor* propagateRepDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);
												propagateRepDes->initRepresentativeDescriptor(joinedRepData,joinNextDepTrackPoint);
												joinRepPropSet->addIncomingRepresentativePropagation(propagateRepDes);
												updateRepresentativePropagationSet(processIndi,joinRepPropSet,calcAlgContext);

												if (!joinConDes) {
													joinDepTrackPoint = joinNextDepTrackPoint;
													joinConDes = addConceptToIndividualReturnConceptDescriptor(joinConcept,false,processIndi,joinNextDepTrackPoint,false,false,calcAlgContext);
												}
											} else {
												// ToDo!
											}

											propagationsDone = true;
										}
									}

									propRepTransExt->setLeftLastRepresentativeJoiningDescriptor(leftRepPropDes);
									propRepTransExt->setRightLastRepresentativeJoiningDescriptor(rightRepPropDes);
									propRepTransExt->setLastAnalysedPropagationBindingDescriptor(propBindDes);
									propRepTransExt->setLastAnalysedPropagateAllFlag(propBindingSet->hasPropagateAllFlag());
								}
							}
						}
					}

					if (propagationsDone) {
						if (!createJoinConcept) {
							reapplyConceptUpdatedRepresentative(processIndi,joinConDes,joinDepTrackPoint,conSet,reapplyQueue,calcAlgContext);
						}
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasCommonVariableBindings(CIndividualProcessNode*& processIndi, CRepresentativeVariableBindingPathMap* leftRepVarBindMap, CRepresentativeVariableBindingPathMap* rightRepVarBindMap, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (rightRepVarBindMap->count() < leftRepVarBindMap->count()) {
						return hasCommonVariableBindings(processIndi,rightRepVarBindMap,leftRepVarBindMap,calcAlgContext);
					}

					if (leftRepVarBindMap->count()*mMapComparisonDirectLookupFactor < rightRepVarBindMap->count()) {
						for (CRepresentativeVariableBindingPathMap::const_iterator it1 = leftRepVarBindMap->constBegin(), it1End = leftRepVarBindMap->constEnd(); it1 != it1End; ++it1) {
							if (rightRepVarBindMap->contains(it1.key())) {
								return true;
							}
						}
						return false;
					} else {
						CRepresentativeVariableBindingPathMap::const_iterator it1 = leftRepVarBindMap->constBegin(), it1End = leftRepVarBindMap->constEnd();
						CRepresentativeVariableBindingPathMap::const_iterator it2 = rightRepVarBindMap->constBegin(), it2End = rightRepVarBindMap->constEnd();

						while (it1 != it1End && it2 != it2End) {
							cint64 key1 = it1.key();
							cint64 key2 = it2.key();
							if (key1 == key2) {
								return true;
							}
							if (key1 < key2) {
								++it1;
							} else if (key2 < key1) {
								++it2;
							}
						}
						return false;
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::areRepresentativesJoinable(CIndividualProcessNode*& processIndi, CRepresentativeVariableBindingPathSetData* leftRepData, CRepresentativeVariableBindingPathSetData* rightRepData, CSortedLinker<CVariable*>* varLinker, CCalculationAlgorithmContextBase* calcAlgContext) {
					CRepresentativeVariableBindingPathSetMigrateData* leftRepMigData = leftRepData->getMigrateData();
					CRepresentativeVariableBindingPathSetMigrateData* rightRepMigData = rightRepData->getMigrateData();
					if (varLinker && leftRepMigData && rightRepMigData) {
						CRepresentativeVariableBindingPathMap* leftRepVarBindMap = leftRepMigData->getRepresentativeVariableBindingPathMap();
						CRepresentativeVariableBindingPathMap* rightRepVarBindMap = rightRepMigData->getRepresentativeVariableBindingPathMap();

						const CRepresentativeVariableBindingPathMapData& leftRepVarBindData = leftRepVarBindMap->constBegin().value();
						const CRepresentativeVariableBindingPathMapData& rightRepVarBindData = rightRepVarBindMap->constBegin().value();
						CVariableBindingPath* leftVarBindPath = leftRepVarBindData.getVariableBindingPath();
						CVariableBindingPath* rightVarBindPath = rightRepVarBindData.getVariableBindingPath();
						if (leftVarBindPath->getVariableBindingCount() == 1 && rightVarBindPath->getVariableBindingCount() == 1) {
							if (!hasCommonVariableBindings(processIndi,leftRepVarBindMap,rightRepVarBindMap,calcAlgContext)) {
								++mStatRepresentativeJoinQuickFailCount;
								return false;
							}
						}
					}
					return true;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::createCommonJoiningAll(CRepresentativeJoiningCommonKeyMap* repJoinCommonKeyMap, CRepresentativeJoiningAllDataExtension* joinAllExtData, CRepresentativeVariableBindingPathSetData* leftRepData, CRepresentativeVariableBindingPathSetData* rightRepData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CRepresentativeVariableBindingPathSetData* repData = CObjectParameterizingAllocator< CRepresentativeVariableBindingPathSetData,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);
					repData->initRepresentativeVariableBindingPathData(nullptr);
					repData->setRepresentativeID(procDataBox->getNextRepresentativeVariableBindingPathID(true));
					repData->setMigratable(false);
					repData->incUseCount();
					repData->incShareCount();
					CRepresentativeVariableBindingPathSetMigrateData* repMigData = repData->getMigrateData(true);
					CRepresentativeVariableBindingPathMap* varBindPathResolveMap = repMigData->getRepresentativeVariableBindingPathMap();

					CRepresentativeVariableBindingPathMap* leftRepVarBindPathResolveMap = joinAllExtData->getLeftResolveVariableBindingPathMap(true);
					CRepresentativeVariableBindingPathMap* rightRepVarBindPathResolveMap = joinAllExtData->getRightResolveVariableBindingPathMap(true);

					for (CRepresentativeJoiningCommonKeyMap::const_iterator it = repJoinCommonKeyMap->constBegin(), itEnd = repJoinCommonKeyMap->constEnd(); it != itEnd; ++it) {
						cint64 joiningKey = it.key();
						const CRepresentativeJoiningCommonKeyData& commonKeyData = it.value();
						CRepresentativeVariableBindingPathSetJoiningKeyDataMap* leftKeyDataMap = commonKeyData.getLeftJoiningDataMap();
						CRepresentativeVariableBindingPathSetJoiningKeyDataMap* rightKeyDataMap = commonKeyData.getRightJoiningDataMap();

						for (CRepresentativeVariableBindingPathSetJoiningKeyDataMap::const_iterator it1 = leftKeyDataMap->constBegin(), it1End = leftKeyDataMap->constEnd(); it1 != it1End; ++it1) {
							for (CRepresentativeVariableBindingPathSetJoiningKeyDataMap::const_iterator it2 = rightKeyDataMap->constBegin(), it2End = rightKeyDataMap->constEnd(); it2 != it2End; ++it2) {
								CVariableBindingPath* varBindPath1 = it1.value();
								CVariableBindingPath* varBindPath2 = it2.value();

								CVariableBindingPath* mergedVarBindPath = getJoinedVariableBindingPath(varBindPath1,varBindPath2,calcAlgContext);

								leftRepVarBindPathResolveMap->insert(mergedVarBindPath->getPropagationID(),CRepresentativeVariableBindingPathMapData(mergedVarBindPath,varBindPath1,leftRepData));
								rightRepVarBindPathResolveMap->insert(mergedVarBindPath->getPropagationID(),CRepresentativeVariableBindingPathMapData(mergedVarBindPath,varBindPath2,rightRepData));

								varBindPathResolveMap->insert(mergedVarBindPath->getPropagationID(),CRepresentativeVariableBindingPathMapData(mergedVarBindPath,repData));
							}
						}
					}

					++mStatRepresentativeJoinCombinesCount;
					repMigData->getRepresentativeContainingMap()->insertContainedRepresentative(repData,false);
					repData->addKeySignatureValue(repData->getRepresentativeID());
					CRepresentativeVariableBindingPathSetHash* repVarBindPathSetHash = procDataBox->getRepresentativeVariableBindingPathSetHash(true);
					repVarBindPathSetHash->insertRepresentativeVariableBindingPathSetData(repData);
					joinAllExtData->setRepresentativeVariableBindingPathSetData(repData);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::createCommonJoiningKeyMap(CRepresentativeJoiningCommonKeyMap* repJoinCommonKeyMap, CRepresentativeVariableBindingPathSetJoiningKeyMap* firstJoiningKeyMap, CRepresentativeVariableBindingPathSetData* firstRepData,
							CRepresentativeVariableBindingPathSetJoiningKeyMap* secJoiningKeyMap, CRepresentativeVariableBindingPathSetData* secRepData, bool firstLeft, CCalculationAlgorithmContextBase* calcAlgContext) {

					if (secJoiningKeyMap->count() < firstJoiningKeyMap->count()) {
						createCommonJoiningKeyMap(repJoinCommonKeyMap,secJoiningKeyMap,secRepData,firstJoiningKeyMap,firstRepData,!firstLeft,calcAlgContext);
					}
					if (firstJoiningKeyMap->count()*mMapComparisonDirectLookupFactor < secJoiningKeyMap->count()) {
						for (CRepresentativeVariableBindingPathSetJoiningKeyMap::const_iterator it = firstJoiningKeyMap->constBegin(), itEnd = firstJoiningKeyMap->constEnd(); it != itEnd; ++it) {
							cint64 joiningKey = it.key();
							CRepresentativeVariableBindingPathSetJoiningKeyDataMap* firstJoiningDataMap = it.value().getRepresentativeVariableBindingPathSetJoiningKeyDataMap();
							CRepresentativeVariableBindingPathSetJoiningKeyDataMap* secJoiningDataMap = secJoiningKeyMap->value(joiningKey).getRepresentativeVariableBindingPathSetJoiningKeyDataMap();
							if (secJoiningDataMap) {
								CRepresentativeVariableBindingPathSetJoiningKeyDataMap* leftJoiningDataMap = firstJoiningDataMap;
								CRepresentativeVariableBindingPathSetJoiningKeyDataMap* rightJoiningDataMap = secJoiningDataMap;
								if (!firstLeft) {
									leftJoiningDataMap = secJoiningDataMap;
									rightJoiningDataMap = firstJoiningDataMap;
								}
								repJoinCommonKeyMap->insert(joiningKey,CRepresentativeJoiningCommonKeyData(leftJoiningDataMap,rightJoiningDataMap));
							}
						}
					} else {
						CRepresentativeVariableBindingPathSetJoiningKeyMap::const_iterator it1 = firstJoiningKeyMap->constBegin(), it1End = firstJoiningKeyMap->constEnd();
						CRepresentativeVariableBindingPathSetJoiningKeyMap::const_iterator it2 = secJoiningKeyMap->constBegin(), it2End = secJoiningKeyMap->constEnd();
						while (it1 != it1End && it2 != it2End) {
							cint64 joiningKey1 = it1.key();
							cint64 joiningKey2 = it2.key();
							if (joiningKey1 == joiningKey2) {
								CRepresentativeVariableBindingPathSetJoiningKeyDataMap* firstJoiningDataMap = it1.value().getRepresentativeVariableBindingPathSetJoiningKeyDataMap();
								CRepresentativeVariableBindingPathSetJoiningKeyDataMap* secJoiningDataMap = it2.value().getRepresentativeVariableBindingPathSetJoiningKeyDataMap();
								if (firstJoiningDataMap && secJoiningDataMap) {
									CRepresentativeVariableBindingPathSetJoiningKeyDataMap* leftJoiningDataMap = firstJoiningDataMap;
									CRepresentativeVariableBindingPathSetJoiningKeyDataMap* rightJoiningDataMap = secJoiningDataMap;
									if (!firstLeft) {
										leftJoiningDataMap = secJoiningDataMap;
										rightJoiningDataMap = firstJoiningDataMap;
									}
									repJoinCommonKeyMap->insert(joiningKey1,CRepresentativeJoiningCommonKeyData(leftJoiningDataMap,rightJoiningDataMap));
								}
								++it1;
								++it2;
							} else if (joiningKey1 < joiningKey2) {
								++it1;
							} else if (joiningKey2 < joiningKey1) {
								++it2;
							}
						}
					}
				}



				CRepresentativeVariableBindingPathSetJoiningKeyMap* CCalculationTableauCompletionTaskHandleAlgorithm::getRepresentativeJoiningKeyData(CRepresentativeVariableBindingPathSetData* repVarBindPathSetData, CConcept* joinConcept, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CSortedLinker<CVariable*>* keyVarLinker = joinConcept->getVariableLinker();

					CRepresentativeVariableBindingPathSetJoiningData* joiningData = nullptr;

					CRepresentativeVariableBindingPathSetJoiningHash* joiningHash = repVarBindPathSetData->getJoiningHash(false);
					if (joiningHash) {
						joiningData = joiningHash->getRepresentativeVariableBindingPathSetJoiningData(joinConcept,false);
					}
					if (!joiningData) {
						joiningHash = repVarBindPathSetData->getJoiningHash(true);
						joiningData = joiningHash->getRepresentativeVariableBindingPathSetJoiningData(joinConcept,true);

						CRepresentativeVariableBindingPathJoiningKeyHash* varBindPathJoiningKeyHash = procDataBox->getRepresentativeVariableBindingPathJoiningKeyHash(true);

						CRepresentativeVariableBindingPathSetJoiningKeyMap* joiningKeyMap = joiningData->getJoiningKeyMap();
						CRepresentativeVariableBindingPathMap* varBindPathMap = repVarBindPathSetData->getMigrateData(false)->getRepresentativeVariableBindingPathMap();
						for (CRepresentativeVariableBindingPathMap::const_iterator it = varBindPathMap->constBegin(), itEnd = varBindPathMap->constEnd(); it != itEnd; ++it) {
							CVariableBindingPath* varBindPath = it.value().getVariableBindingPath();
							cint64 joinKey = varBindPathJoiningKeyHash->getRepresentativeVariableBindingPathJoiningKey(varBindPath,keyVarLinker,true);			
							CRepresentativeVariableBindingPathSetJoiningKeyDataMap* joiningKeyDataMap = joiningKeyMap->getJoiningKeyDataMap(joinKey,true);
							joiningKeyDataMap->insert(varBindPath->getPropagationID(),varBindPath);
						}
					}
					return joiningData->getJoiningKeyMap();
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEBINDVARIABLERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CVariable* variable = concept->getVariable();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();

					CConcept* bindingTriggerConcept = opConLinker->getData();
					bool bindingTriggerConceptNegation = opConLinker->isNegated();

					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					STATINC(VARBINDRULEBINDAPPLICATIONCOUNT,calcAlgContext);

					bool updateExt = false;


					CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(false);
					if (conPropBindingSetHash) {
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);

						if (propBindingSet) {
							CPropagationVariableBindingTransitionExtension* propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(false);
							if (!propVarBindTransExt || !propVarBindTransExt->isProcessingCompleted()) {
								if (!propVarBindTransExt || propBindingSet->hasPropagateAllFlag()) {
									updateExt = true;
								} else {
									CPropagationBindingDescriptor* lastAnalyPropBindDes = propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor();
									CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();
									if (lastAnalyPropBindDes != propBindDes) {
										updateExt = true;
									}
								}
							}
						}
					}



					if (updateExt) {

						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,true);
						CPropagationVariableBindingTransitionExtension* propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(true);

						CPropagationBindingDescriptor* lastAnalyPropBindDes = propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor();
						CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();

						propVarBindTransExt->setTriggeredVariableIndividualPair(variable,processIndi);
						bool createVarBinding = false;
						createVarBinding = propBindingSet->hasPropagateAllFlag();
						for (CPropagationBindingDescriptor* propBindDesIt = propBindDes; propBindDesIt != lastAnalyPropBindDes; propBindDesIt = propBindDesIt->getNext()) {
							if (propVarBindTransExt->addAnalysedPropagationBindingDescriptorReturnMatched(propBindDesIt)) {
								createVarBinding = true;
							}
						}
						propVarBindTransExt->setLastAnalysedPropagationBindingDescriptor(propBindDes);
						propVarBindTransExt->setLastAnalysedPropagateAllFlag(propBindingSet->hasPropagateAllFlag());

						if (createVarBinding) {
							++mStatRepresentativeCreatedCount;
							STATINC(VARBINDVARIABLEBINDCOUNT,calcAlgContext);
							propVarBindTransExt->setProcessingCompleted(true);

							CConceptRepresentativePropagationSetHash* conRepPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(true);
							CRepresentativePropagationSet* repPropSet = conRepPropSetHash->getRepresentativePropagationSet(bindingTriggerConcept,true);

							CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
							cint64 nextPathPropID = processingDataBox->getNextVariableBindingPathID(true);

							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CREPRESENTATIVEBINDVARIABLEDependencyNode* bindDepNode = createREPRESENTATIVEBINDVARIABLEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);


							if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
								bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);
							} else {
								reapplyConceptUpdatedRepresentative(processIndi,bindingConDes,bindingDepTrackPoint,conSet,reapplyQueue,calcAlgContext);
							}

							repPropSet->setConceptDescriptor(bindingConDes);
							CVariableBinding* varBinding = CObjectAllocator<CVariableBinding>::allocateAndConstruct(taskMemMan);
							varBinding->initVariableBinding(nextDepTrackPoint,processIndi,variable);
							CVariableBindingDescriptor* varBindingDes = CObjectAllocator<CVariableBindingDescriptor>::allocateAndConstruct(taskMemMan);
							varBindingDes->initVariableBindingDescriptor(varBinding);
							CVariableBindingPath* varBindingPath = CObjectAllocator<CVariableBindingPath>::allocateAndConstruct(taskMemMan);
							varBindingPath->initVariableBindingPath(nextPathPropID,varBindingDes);

							CRepresentativeVariableBindingPathHash* repVarBindPathHash = procDataBox->getRepresentativeVariableBindingPathHash(true);
							CRepresentativeVariableBindingPathSetData* repData = repVarBindPathHash->getRepresentativeVariableBindingPathSetData(varBindingPath,true);
							repData->setRepresentativeID(procDataBox->getNextRepresentativeVariableBindingPathID(true));
							repData->setMigratable(false);
							repData->incUseCount();
							repData->incShareCount();
							CRepresentativeVariableBindingPathSetMigrateData* repMigData = repData->getMigrateData(true);
							repMigData->getRepresentativeVariableBindingPathMap()->insert(varBindingPath->getPropagationID(),CRepresentativeVariableBindingPathMapData(varBindingPath,repData));
							repMigData->getRepresentativeContainingMap()->insertContainedRepresentative(repData,false);
							repData->addKeySignatureValue(repData->getRepresentativeID());

							CRepresentativeVariableBindingPathSetHash* repVarBindPathSetHash = procDataBox->getRepresentativeVariableBindingPathSetHash(true);
							repVarBindPathSetHash->insertRepresentativeVariableBindingPathSetData(repData);


							CRepresentativePropagationDescriptor* repPropDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);
							repPropDes->initRepresentativeDescriptor(repData,nextDepTrackPoint);

							repPropSet->addIncomingRepresentativePropagationDescriptorLinker(repPropDes);
							updateRepresentativePropagationSet(processIndi,repPropSet,calcAlgContext);

						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();


					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* bindingTriggerConcept = opLinker->getData();
					bool bindingTriggerConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();

					STATINC(VARBINDRULEIMPLICATIONAPPLICATIONCOUNT,calcAlgContext);

					if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {

						// search next not existing trigger
						bool allTriggersAvailable = true;
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CSortedNegLinker<CConcept*>* triggerLinkerIt = nullptr;
						for (triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
								if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
									return;
								}
							} else {
								allTriggersAvailable = false;
								break;
							}
						}

						if (!allTriggersAvailable) {
							// install to trigger
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							bool triggerNegation = !nextTrigger->isNegated();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						} else {
							CDependency* triggerDeps = nullptr;
							for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
								CConcept* triggerConcept = triggerLinkerIt->getData();
								CConceptDescriptor* triggerConDes = nullptr;
								CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
								conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
								CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
								connDep->setNext(triggerDeps);
								triggerDeps = connDep;
							}

							++mStatRepresentativeImplicationCount;

							CConceptRepresentativePropagationSetHash* conRepPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(true);
							CRepresentativePropagationSet* prevRepPropSet = conRepPropSetHash->getRepresentativePropagationSet(concept,false);
							CRepresentativePropagationSet* repPropSet = conRepPropSetHash->getRepresentativePropagationSet(bindingTriggerConcept,true);
							CRepresentativePropagationDescriptor* procRepPropDes = nullptr;
							CDependencyTrackPoint* propDepTrackPoint = nullptr;
							if (prevRepPropSet) {
								procRepPropDes = prevRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
							}
							if (procRepPropDes) {
								propDepTrackPoint = procRepPropDes->getDependencyTrackPoint();

								repPropSet->setConceptDescriptor(bindingConDes);

								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CREPRESENTATIVEIMPLICATIONDependencyNode* implDepNode = createREPRESENTATIVEIMPLICATIONDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,triggerDeps,calcAlgContext);

								bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);


								propagateRepresentative(processIndi,procRepPropDes,repPropSet,nextDepTrackPoint,calcAlgContext);
							}

						}
					} else {

						CConceptRepresentativePropagationSetHash* conRepPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(true);
						CRepresentativePropagationSet* prevRepPropSet = conRepPropSetHash->getRepresentativePropagationSet(concept,false);
						CRepresentativePropagationSet* repPropSet = conRepPropSetHash->getRepresentativePropagationSet(bindingTriggerConcept,true);
						CRepresentativePropagationDescriptor* procRepPropDes = nullptr;
						CDependencyTrackPoint* propDepTrackPoint = nullptr;
						if (prevRepPropSet) {
							procRepPropDes = prevRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
						}
						if (procRepPropDes) {
							propDepTrackPoint = procRepPropDes->getDependencyTrackPoint();

							if (requiresRepresentativePropagation(processIndi,procRepPropDes,repPropSet,calcAlgContext)) {
								CDependency* triggerDeps = nullptr;
								for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
									CConcept* triggerConcept = triggerLinkerIt->getData();
									CConceptDescriptor* triggerConDes = nullptr;
									CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
									conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
									CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
									connDep->setNext(triggerDeps);
									triggerDeps = connDep;
								}

								++mStatRepresentativeImplicationCount;
								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CREPRESENTATIVEIMPLICATIONDependencyNode* implDepNode = createREPRESENTATIVEIMPLICATIONDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,triggerDeps,calcAlgContext);

								propagateRepresentative(processIndi,procRepPropDes,repPropSet,nextDepTrackPoint,calcAlgContext);
								reapplyConceptUpdatedRepresentative(processIndi,bindingConDes,bindingDepTrackPoint,conSet,reapplyQueue,calcAlgContext);
							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateRepresentativeToSuccessor(CIndividualProcessNode* processIndi, CIndividualProcessNode*& succIndi, CSortedNegLinker<CConcept*>* conceptOpLinker, bool negate, CConceptDescriptor* conDes, CIndividualLinkEdge* restLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();


					succIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
					CReapplyConceptLabelSet* conSet = succIndi->getReapplyConceptLabelSet(false);

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					bool continuePropagation = false;

					for (CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker; conceptOpLinkerIt; conceptOpLinkerIt = conceptOpLinkerIt->getNext()) {
						CConcept* opConcept = conceptOpLinkerIt->getData();
						bool opConNeg = conceptOpLinkerIt->isNegated() ^ negate;

						CConceptDescriptor* bindingConDes = nullptr;
						CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
						CCondensedReapplyQueue* reapplyQueue = nullptr;

						CConceptRepresentativePropagationSetHash* conRepPropSetHash = processIndi->getConceptRepresentativePropagationSetHash(true);
						CRepresentativePropagationSet* prevRepPropSet = conRepPropSetHash->getRepresentativePropagationSet(concept,false);
						CConceptRepresentativePropagationSetHash* succConRepPropSetHash = succIndi->getConceptRepresentativePropagationSetHash(true);
						CRepresentativePropagationSet* succRepPropSet = succConRepPropSetHash->getRepresentativePropagationSet(opConcept,true);
						CRepresentativePropagationDescriptor* procRepPropDes = nullptr;
						CDependencyTrackPoint* propDepTrackPoint = nullptr;
						if (prevRepPropSet) {
							procRepPropDes = prevRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
						}
						if (procRepPropDes) {
							propDepTrackPoint = procRepPropDes->getDependencyTrackPoint();

							if (!conSet->getConceptDescriptorAndReapplyQueue(opConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {

								++mStatRepresentativePropagateSuccCount;
								if (!nextDepTrackPoint) {
									conSet = succIndi->getReapplyConceptLabelSet(true);
									CREPRESENTATIVEALLDependencyNode* repAllDepNode = createREPRESENTATIVEALLDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,restLink->getDependencyTrackPoint(),calcAlgContext);
								}

								bindingConDes = addConceptToIndividualReturnConceptDescriptor(opConcept,opConNeg,succIndi,nextDepTrackPoint,false,false,calcAlgContext);
								succRepPropSet->setConceptDescriptor(bindingConDes);

								propagateRepresentative(succIndi,procRepPropDes,succRepPropSet,nextDepTrackPoint,calcAlgContext);
								continuePropagation = true;
							} else {

								if (requiresRepresentativePropagation(succIndi,procRepPropDes,succRepPropSet,calcAlgContext)) {
									++mStatRepresentativePropagateSuccCount;
									if (!nextDepTrackPoint) {
										conSet = succIndi->getReapplyConceptLabelSet(true);
										CREPRESENTATIVEALLDependencyNode* repAllDepNode = createREPRESENTATIVEALLDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,restLink->getDependencyTrackPoint(),calcAlgContext);
									}

									propagateRepresentative(succIndi,procRepPropDes,succRepPropSet,nextDepTrackPoint,calcAlgContext);
									cint64 varCount = succRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker()->getRepresentativeVariableBindingPathSetData()->getRepresentatedVariableCount();
									reapplyConceptUpdatedRepresentative(succIndi,bindingConDes,bindingDepTrackPoint,varCount,conSet,reapplyQueue,calcAlgContext);
									continuePropagation = true;
								}
							}
						}
					}

					if (continuePropagation) {
						addIndividualToProcessingQueue(succIndi,calcAlgContext);
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();

					STATINC(VARBINDRULEALLAPPLICATIONCOUNT,calcAlgContext);

					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					if (restLink) {
						CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,restLink,calcAlgContext);

						propagateRepresentativeToSuccessor(processIndi,succIndi,opLinker,negate,conDes,restLink,calcAlgContext);

					} else {
						CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
						if (roleSuccHash) {
							CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
							while (roleSuccIt.hasNext()) {
								CIndividualLinkEdge* link = roleSuccIt.next(true);
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);

								propagateRepresentativeToSuccessor(processIndi,succIndi,opLinker,negate,conDes,link,calcAlgContext);
							}
						}
					}
					if (!conProDes->isConceptReapplied()) {
						if (!isConceptInReapplyQueue(conDes,role,processIndi,calcAlgContext)) {
							addConceptToReapplyQueue(conDes,role,processIndi,true,depTrackPoint,calcAlgContext);
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyREPRESENTATIVEANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();


					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;

					CConceptRepresentativePropagationSetHash* conRepPropHash = nullptr;
					CRepresentativePropagationSet* prevRepPropSet = nullptr;
					CRepresentativePropagationDescriptor* procRepPropDes = nullptr;
					CDependencyTrackPoint* propDepTrackPoint = nullptr;

					STATINC(VARBINDRULEANDAPPLICATIONCOUNT,calcAlgContext);

					for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
						CConcept* bindingTriggerConcept = opConLinkerIt->getData();
						bool bindingTriggerConceptNegation = opConLinkerIt->isNegated()^conceptNegation;

						if (!conRepPropHash) {
							conRepPropHash = processIndi->getConceptRepresentativePropagationSetHash(true);
						}
						if (!prevRepPropSet) {
							prevRepPropSet = conRepPropHash->getRepresentativePropagationSet(concept,false);
						}
						if (prevRepPropSet) {
							procRepPropDes = prevRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
						}
						if (procRepPropDes) {
							propDepTrackPoint = procRepPropDes->getDependencyTrackPoint();
							CRepresentativePropagationSet* repPropSet = conRepPropHash->getRepresentativePropagationSet(bindingTriggerConcept,true);

							CConceptDescriptor* bindingConDes = nullptr;
							CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
							CCondensedReapplyQueue* reapplyQueue = nullptr;

							if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {

								++mStatRepresentativePropagateCount;
								if (!nextDepTrackPoint) {
									conSet = processIndi->getReapplyConceptLabelSet(true);
									CREPRESENTATIVEANDDependencyNode* repPropDepNode = createREPRESENTATIVEANDDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,calcAlgContext);
								}
								bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);
								repPropSet->setConceptDescriptor(bindingConDes);

								propagateRepresentative(processIndi,procRepPropDes,repPropSet,nextDepTrackPoint,calcAlgContext);

							} else {

								if (requiresRepresentativePropagation(processIndi,procRepPropDes,repPropSet,calcAlgContext)) {
									++mStatRepresentativePropagateCount;
									if (!nextDepTrackPoint) {
										conSet = processIndi->getReapplyConceptLabelSet(true);
										CREPRESENTATIVEANDDependencyNode* repPropDepNode = createREPRESENTATIVEANDDependency(nextDepTrackPoint,processIndi,conDes,propDepTrackPoint,calcAlgContext);
									}

									propagateRepresentative(processIndi,procRepPropDes,repPropSet,nextDepTrackPoint,calcAlgContext);
									cint64 varCount = repPropSet->getOutgoingRepresentativePropagationDescriptorLinker()->getRepresentativeVariableBindingPathSetData()->getRepresentatedVariableCount();
									reapplyConceptUpdatedRepresentative(processIndi,bindingConDes,bindingDepTrackPoint,varCount,conSet,reapplyQueue,calcAlgContext);
								}
							}
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::reapplyConceptUpdatedRepresentative(CIndividualProcessNode*& processIndi, CConceptDescriptor* bindingConDes, CDependencyTrackPoint* bindingDepTrackPoint, CReapplyConceptLabelSet* conSet, CCondensedReapplyQueue* reapplyQueue, CCalculationAlgorithmContextBase* calcAlgContext) {
					setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
					addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
					if (!reapplyQueue->isEmpty()) {
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
						applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::reapplyConceptUpdatedRepresentative(CIndividualProcessNode*& processIndi, CConceptDescriptor* bindingConDes, CDependencyTrackPoint* bindingDepTrackPoint, cint64 bindingCount, CReapplyConceptLabelSet* conSet, CCondensedReapplyQueue* reapplyQueue, CCalculationAlgorithmContextBase* calcAlgContext) {
					setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
					addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,bindingCount,calcAlgContext);
					if (!reapplyQueue->isEmpty()) {
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
						applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::updateRepresentativePropagationSet(CIndividualProcessNode*& processIndi, CRepresentativePropagationSet* repPropSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (repPropSet->getLastProcessedIncomingRepresentativePropagationDescriptorLinker() != repPropSet->getIncomingRepresentativePropagationDescriptorLinker()) {
						CRepresentativePropagationDescriptor* lastRepPropDes = repPropSet->getLastProcessedIncomingRepresentativePropagationDescriptorLinker();		
						CRepresentativePropagationDescriptor* lastIncRepPropDes = repPropSet->getIncomingRepresentativePropagationDescriptorLinker();
						CRepresentativePropagationDescriptor* lastOutRepPropDes = repPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
						repPropSet->setLastProcessedIncomingRepresentativePropagationDescriptorLinker(lastIncRepPropDes);

						
						if (!repPropSet->getOutgoingRepresentativePropagationDescriptorLinker() && !lastIncRepPropDes->hasNext()) {
							repPropSet->setOutgoingRepresentativePropagationDescriptorLinker(lastIncRepPropDes);
							if (lastIncRepPropDes->getRepresentativeVariableBindingPathSetData()->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger())) {
								lastIncRepPropDes->getRepresentativeVariableBindingPathSetData()->incShareCount();
							}
						} else {
							++mStatRepresentativePropagateUseRepresentativeCount;

							CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
							CRepresentativeVariableBindingPathSetHash* repVarBindPathSetHash = procDataBox->getRepresentativeVariableBindingPathSetHash(true);

							CRepresentativeVariableBindingPathSetData* lastRepVarBindPathSetData = nullptr;
							bool migrateable = false;
							if (lastOutRepPropDes) {
								lastRepVarBindPathSetData = lastOutRepPropDes->getRepresentativeVariableBindingPathSetData();
							}
							if (lastRepVarBindPathSetData) {
								if (lastRepVarBindPathSetData->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger())) {
									lastRepVarBindPathSetData->decShareCount();
									if (lastRepVarBindPathSetData->isMigratable() && lastRepVarBindPathSetData->getShareCount() <= 0 && lastRepVarBindPathSetData->getUseCount() <= 20) {
										migrateable = true;
									}
								}
							}

							CRepresentativeVariableBindingPathSetData* repVarBindPathSetData = repVarBindPathSetHash->getRepresentativeVariableBindingPathSetData(repPropSet,true);
							repVarBindPathSetData->incShareCount();
							repVarBindPathSetData->incUseCount();
							if (!repVarBindPathSetData->hasMigrateData()) {
								++mStatRepresentativePropagateNewRepresentativeCount;
								repVarBindPathSetData->setRepresentativeID(procDataBox->getNextRepresentativeVariableBindingPathID(true));
								bool updateNewOnly = false;
								if (migrateable) {
									updateNewOnly = true;
									repVarBindPathSetData->takeMigrateDataFrom(lastRepVarBindPathSetData);
								} else if (lastRepVarBindPathSetData) {
									updateNewOnly = true;
									repVarBindPathSetData->copyMigrateDataFrom(lastRepVarBindPathSetData);
								} 

								CRepresentativeVariableBindingPathSetMigrateData* repMigrateData = repVarBindPathSetData->getMigrateData(true);
								CRepresentativeVariableBindingPathMap* repVarBindPathMap = repMigrateData->getRepresentativeVariableBindingPathMap();
								CRepresentativePropagationDescriptor* untilUpdateRepPropDes = nullptr;
								if (updateNewOnly) {
									untilUpdateRepPropDes = lastRepPropDes;
								}
								for (CRepresentativePropagationDescriptor* newRepPropDesIt = lastIncRepPropDes; newRepPropDesIt != untilUpdateRepPropDes; newRepPropDesIt = newRepPropDesIt->getNext()) {
									CRepresentativeVariableBindingPathSetData* newRepVarBindPathSetData = newRepPropDesIt->getRepresentativeVariableBindingPathSetData();
									CRepresentativeVariableBindingPathSetMigrateData* newRepMigrateData = newRepVarBindPathSetData->getMigrateData(true);
									repMigrateData->getRepresentativeContainingMap()->insertContainedRepresentative(newRepVarBindPathSetData,true);
									repVarBindPathSetData->addKeySignatureValue(newRepVarBindPathSetData->getRepresentativeKey());

									CRepresentativeVariableBindingPathMap* newRepVarBindPathMap = newRepMigrateData->getRepresentativeVariableBindingPathMap();

									if (newRepVarBindPathMap->count()*mMapComparisonDirectLookupFactor <= repVarBindPathMap->count()) {
										for (CRepresentativeVariableBindingPathMap::const_iterator propIt = newRepVarBindPathMap->constBegin(), propItEnd = newRepVarBindPathMap->constEnd(); propIt != propItEnd; ++propIt) {
											cint64 propVarBindPathID = propIt.key();
											if (!repVarBindPathMap->contains(propVarBindPathID)) {
												repVarBindPathMap->insert(propVarBindPathID,CRepresentativeVariableBindingPathMapData(propIt.value().getVariableBindingPath(),newRepVarBindPathSetData));
											}
										}
									} else {

										CRepresentativeVariableBindingPathMap::const_iterator availIt = repVarBindPathMap->begin(), availItEnd = repVarBindPathMap->end();
										CRepresentativeVariableBindingPathMap::const_iterator propIt = newRepVarBindPathMap->constBegin(), propItEnd = newRepVarBindPathMap->constEnd();

										while (propIt != propItEnd) {
											cint64 propID = propIt.key();
											if (availIt == availItEnd) {
												availIt = repVarBindPathMap->insert(propID,CRepresentativeVariableBindingPathMapData(propIt.value().getVariableBindingPath(),newRepVarBindPathSetData));
												++propIt;
												++availIt;
											} else {
												cint64 availID = availIt.key();
												if (availID < propID) {
													++availIt;
												} else if (availID > propID) {
													availIt = repVarBindPathMap->insert(propID,CRepresentativeVariableBindingPathMapData(propIt.value().getVariableBindingPath(),newRepVarBindPathSetData));
													++propIt;
													++availIt;
												} else {
													++propIt;
													++availIt;
												}
											}
										}
									}
								}

							} else {
								++mStatRepresentativePropagateReusedRepresentativeCount;
							}

							CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
							CRepresentativePropagationDescriptor* outPropRepDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);


							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CRepresentativeVariableBindingPathMap* repVarBindPathMap = repVarBindPathSetData->getMigrateData(false)->getRepresentativeVariableBindingPathMap();
							CRepresentativeContainingMap* repConMap = repVarBindPathSetData->getMigrateData(false)->getRepresentativeContainingMap();
							CRESOLVEREPRESENTATIVEDependencyNode* resolveRepNode = createRESOLVEREPRESENTATIVEDependency(nextDepTrackPoint,processIndi,repPropSet->getConceptDescriptor(),repVarBindPathMap,repPropSet->getRepresentativePropagationMap(),lastIncRepPropDes->getDependencyTrackPoint(),lastOutRepPropDes->getDependencyTrackPoint(),calcAlgContext);
							
							outPropRepDes->initRepresentativeDescriptor(repVarBindPathSetData,nextDepTrackPoint);
							repPropSet->addOutgoingRepresentativePropagationDescriptorLinker(outPropRepDes);

						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateRepresentative(CIndividualProcessNode*& processIndi, CRepresentativePropagationDescriptor* repPropDes, CRepresentativePropagationSet* repPropSet, CDependencyTrackPoint* nextDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CRepresentativePropagationDescriptor* propagateRepDes = CObjectAllocator<CRepresentativePropagationDescriptor>::allocateAndConstruct(taskMemMan);

					propagateRepDes->initRepresentativeDescriptor(repPropDes->getRepresentativeVariableBindingPathSetData(),nextDepTrackPoint);
					repPropSet->addIncomingRepresentativePropagation(propagateRepDes);

					updateRepresentativePropagationSet(processIndi,repPropSet,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::requiresRepresentativePropagation(CIndividualProcessNode*& processIndi, CRepresentativePropagationDescriptor* repPropDes, CRepresentativePropagationSet* testRepPropSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 propRepID = repPropDes->getRepresentativeVariableBindingPathSetData()->getRepresentativeID();
					if (testRepPropSet->containsRepresentativePropagation(propRepID)) {
						return false;
					}

					CRepresentativePropagationDescriptor* lastRepPropDes = testRepPropSet->getOutgoingRepresentativePropagationDescriptorLinker();
					if (lastRepPropDes) {
						CRepresentativeVariableBindingPathSetData* availRepData = lastRepPropDes->getRepresentativeVariableBindingPathSetData();
						CRepresentativeVariableBindingPathSetMigrateData* availMigData = availRepData->getMigrateData(false);
						if (availMigData) {
							CRepresentativeContainingMap* repContMap = availMigData->getRepresentativeContainingMap();
							if (repContMap->contains(propRepID)) {
								return false;
							}
							CRepresentativeVariableBindingPathMap* availVarBindPathMap = availMigData->getRepresentativeVariableBindingPathMap();
							CRepresentativeVariableBindingPathSetMigrateData* propMigData = repPropDes->getRepresentativeVariableBindingPathSetData()->getMigrateData(false);
							CRepresentativeVariableBindingPathMap* propVarBindPathMap = propMigData->getRepresentativeVariableBindingPathMap();


							if (propVarBindPathMap->count()*mMapComparisonDirectLookupFactor <= availVarBindPathMap->count()) {
								for (CRepresentativeVariableBindingPathMap::const_iterator propIt = propVarBindPathMap->constBegin(), propItEnd = propVarBindPathMap->constEnd(); propIt != propItEnd; ++propIt) {
									cint64 propVarBindPathID = propIt.key();
									if (!availVarBindPathMap->contains(propVarBindPathID)) {
										return true;
									}
								}
								return false;
							} else {
								CRepresentativeVariableBindingPathMap::const_iterator availIt = availVarBindPathMap->constBegin(), availItEnd = availVarBindPathMap->constEnd();
								CRepresentativeVariableBindingPathMap::const_iterator propIt = propVarBindPathMap->constBegin(), propItEnd = propVarBindPathMap->constEnd();

								while (propIt != propItEnd) {
									cint64 propID = propIt.key();
									if (availIt == availItEnd) {
										return true;
									}
									cint64 availID = availIt.key();
									if (availID < propID) {
										++availIt;
									} else  if (propID < availID) {
										return true;
									} else {
										++availIt;
										++propIt;
									}
								}
								return false;

							}
						}

					}
					return true;
				}





































































				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARIABLEBINDINGANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();


					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CDependencyTrackPoint* nextDepTrackPoint = nullptr;

					STATINC(VARBINDRULEANDAPPLICATIONCOUNT,calcAlgContext);


					for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
						CConcept* bindingTriggerConcept = opConLinkerIt->getData();
						bool bindingTriggerConceptNegation = opConLinkerIt->isNegated()^conceptNegation;

						CConceptDescriptor* bindingConDes = nullptr;
						CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
						CCondensedReapplyQueue* reapplyQueue = nullptr;

						if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
							if (!nextDepTrackPoint) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CVARBINDPROPAGATEANDDependencyNode* bindDepNode = createVARBINDPROPAGATEANDDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);
							}
							bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);

							CConceptVariableBindingPathSetHash* conVarBindingSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(concept,false);
							CVariableBindingPathSet* varBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(bindingTriggerConcept,true);
							varBindingPathSet->setConceptDescriptor(bindingConDes);

							propagateInitialVariableBindings(processIndi,bindingConDes,varBindingPathSet,prevVarBindingPathSet,nullptr, conVarBindingSetHash,calcAlgContext);



						} else {

							CConceptVariableBindingPathSetHash* conVarBindingSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(concept,false);
							CVariableBindingPathSet* varBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(bindingTriggerConcept,true);



							if (propagateFreshVariableBindings(processIndi,conDes,varBindingPathSet,prevVarBindingPathSet,nullptr, conVarBindingSetHash, calcAlgContext)) {
								setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
								CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
								cint64 bindingCount = varBindingPathSet->getVariableBindingPathMap()->count();
								addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
								if (!reapplyQueue->isEmpty()) {
									conSet = processIndi->getReapplyConceptLabelSet(true);
									CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
									applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
								}
							}
						}
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateInitialVariableBindings(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CVariableBindingPathSet* newVarBindingSet, CVariableBindingPathSet* prevVarBindingSet, CDependency* otherDependencies, CConceptVariableBindingPathSetHash* conVarBindingSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					CVariableBindingPathDescriptor* newVarBindPathDesLinker = nullptr;
					if (prevVarBindingSet) {
						newVarBindingSet->copyVariableBindingPaths(prevVarBindingSet->getVariableBindingPathMap());
						CVariableBindingPathMap* varBindMap = newVarBindingSet->getVariableBindingPathMap();
						for (CVariableBindingPathMap::iterator it = varBindMap->begin(), itEnd = varBindMap->end(); it != itEnd; ++it) {
							++mStatVarBindingPropagateCount;
							++mStatVarBindingPropagateInitialCount;
							STATINC(VARBINDPROPAGATEDCOUNT,calcAlgContext);
							STATINC(VARBINDPROPAGATEDINITIALCOUNT,calcAlgContext);
							CVariableBindingPathMapData& varBindPathMapData = it.value();
							CVariableBindingPathDescriptor* prevVarBindPathDes = varBindPathMapData.getVariableBindingPathDescriptor();
							CVariableBindingPathDescriptor* newVarBindPathDes = CObjectAllocator<CVariableBindingPathDescriptor>::allocateAndConstruct(taskMemMan);
							CDependencyTrackPoint* newDepTrackPoint = nullptr;
							CPROPAGATEVARIABLEBINDINGDependencyNode* bindDepNode = createPROPAGATEVARIABLEBINDINGDependency(newDepTrackPoint,processIndi,conDes,prevVarBindPathDes->getDependencyTrackPoint(),otherDependencies,calcAlgContext);
							newVarBindPathDes->initVariableBindingPathDescriptor(prevVarBindPathDes->getVariableBindingPath(),newDepTrackPoint);
							varBindPathMapData.setVariableBindingPathDescriptor(newVarBindPathDes);
							newVarBindPathDesLinker = newVarBindPathDes->append(newVarBindPathDesLinker);
							propagations = true;
						}
						if (newVarBindPathDesLinker) {
							newVarBindingSet->addVariableBindingPathDescriptorLinker(newVarBindPathDesLinker);
							conVarBindingSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDesLinker);
						}
					}
					return propagations;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateFreshVariableBindings(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CVariableBindingPathSet* newVarBindingSet, CVariableBindingPathSet* prevVarBindingSet, CDependency* otherDependencies, CConceptVariableBindingPathSetHash* conVarBindingSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					if (prevVarBindingSet) {
						CVariableBindingPathMap* prevVarBindPathMap = prevVarBindingSet->getVariableBindingPathMap();
						CVariableBindingPathMap* newVarBindPathMap = newVarBindingSet->getVariableBindingPathMap();

						CVariableBindingPathMap::iterator itNew = newVarBindPathMap->begin();
						CVariableBindingPathMap::const_iterator itPrev = prevVarBindPathMap->constBegin(), itPrevEnd = prevVarBindPathMap->constEnd();

						CVariableBindingPathDescriptor* newVarBindPathDesLinker = nullptr;

						while (itPrev != itPrevEnd) {
							cint64 prevPropID = itPrev.key();
							bool doPropagation = false;
							if (itNew == newVarBindPathMap->end()) {
								doPropagation = true;
							} else {
								cint64 newPropID = itNew.key();
								if (newPropID < prevPropID) {
									++itNew;
								} else if (newPropID == prevPropID) {
									++itNew;
									++itPrev;
								} else {
									doPropagation = true;
								}
							}
							if (doPropagation) {
								++mStatVarBindingPropagateCount;
								++mStatVarBindingPropagateFreshCount;
								STATINC(VARBINDPROPAGATEDCOUNT,calcAlgContext);
								STATINC(VARBINDPROPAGATEDFRESHCOUNT,calcAlgContext);
								const CVariableBindingPathMapData& prevVarBindPathMapData = itPrev.value();
								CVariableBindingPathDescriptor* prevVarBindPathDes = prevVarBindPathMapData.getVariableBindingPathDescriptor();

								CVariableBindingPathDescriptor* newVarBindPathDes = CObjectAllocator<CVariableBindingPathDescriptor>::allocateAndConstruct(taskMemMan);
								CDependencyTrackPoint* newDepTrackPoint = nullptr;
								CPROPAGATEVARIABLEBINDINGDependencyNode* bindDepNode = createPROPAGATEVARIABLEBINDINGDependency(newDepTrackPoint,processIndi,conDes,prevVarBindPathDes->getDependencyTrackPoint(),otherDependencies,calcAlgContext);
								CVariableBindingPath* varBindingPath = prevVarBindPathDes->getVariableBindingPath();
								newVarBindPathDes->initVariableBindingPathDescriptor(varBindingPath,newDepTrackPoint);

								itNew = newVarBindPathMap->insert(varBindingPath->getPropagationID(),CVariableBindingPathMapData(newVarBindPathDes));

								newVarBindPathDesLinker = newVarBindPathDes->append(newVarBindPathDesLinker);
								propagations = true;
							}
						}
						if (newVarBindPathDesLinker) {
							newVarBindingSet->addVariableBindingPathDescriptorLinker(newVarBindPathDesLinker);
							conVarBindingSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDesLinker);
						}
					}
					return propagations;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateVariableBindingsToSuccessor(CIndividualProcessNode* processIndi, CIndividualProcessNode*& succIndi, CSortedNegLinker<CConcept*>* conceptOpLinker, bool negate, CConceptDescriptor* conDes, CIndividualLinkEdge* restLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();


					succIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
					CReapplyConceptLabelSet* conSet = succIndi->getReapplyConceptLabelSet(false);

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					bool continuePropagation = false;

					for (CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker; conceptOpLinkerIt; conceptOpLinkerIt = conceptOpLinkerIt->getNext()) {
						CConcept* opConcept = conceptOpLinkerIt->getData();
						bool opConNeg = conceptOpLinkerIt->isNegated() ^ negate;

						CConceptDescriptor* bindingConDes = nullptr;
						CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
						CCondensedReapplyQueue* reapplyQueue = nullptr;
						if (!conSet->getConceptDescriptorAndReapplyQueue(opConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {


							if (!nextDepTrackPoint) {
								conSet = succIndi->getReapplyConceptLabelSet(true);
								CVARBINDPROPAGATEALLDependencyNode* bindDepNode = createVARBINDPROPAGATEALLDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,restLink->getDependencyTrackPoint(),calcAlgContext);
							}
							bindingConDes = addConceptToIndividualReturnConceptDescriptor(opConcept,opConNeg,succIndi,nextDepTrackPoint,false,false,calcAlgContext);

							CConceptVariableBindingPathSetHash* conVarBindingPathSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingPathSetHash->getVariableBindingPathSet(concept,false);
							CConceptVariableBindingPathSetHash* succConVarBindingPathSetHash = succIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* succVarBindingPathSet = succConVarBindingPathSetHash->getVariableBindingPathSet(opConcept,true);
							succVarBindingPathSet->setConceptDescriptor(bindingConDes);

							propagateInitialVariableBindingsToSuccessor(processIndi,succIndi,bindingConDes,succVarBindingPathSet,prevVarBindingPathSet,restLink, succConVarBindingPathSetHash,calcAlgContext);
							continuePropagation = true;
						} else {

							CConceptVariableBindingPathSetHash* conVarBindingPathSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingPathSetHash->getVariableBindingPathSet(concept,false);
							CConceptVariableBindingPathSetHash* succConVarBindingPathSetHash = succIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* succVarBindingPathSet = succConVarBindingPathSetHash->getVariableBindingPathSet(opConcept,true);

							if (propagateFreshVariableBindingsToSuccessor(processIndi,succIndi,conDes,succVarBindingPathSet,prevVarBindingPathSet,restLink, succConVarBindingPathSetHash,calcAlgContext)) {
								setIndividualNodeConceptLabelSetModified(succIndi,calcAlgContext);
								CConceptProcessingQueue* conProQueue = succIndi->getConceptProcessingQueue(true);;
								cint64 bindingCount = succVarBindingPathSet->getVariableBindingPathMap()->count();
								addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,succIndi,true,calcAlgContext);
								if (!reapplyQueue->isEmpty()) {
									conSet = succIndi->getReapplyConceptLabelSet(true);
									CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
									applyReapplyQueueConcepts(succIndi,&reapplyQueueIt,calcAlgContext);
								}
								continuePropagation = true;
							}
						}
					}

					if (continuePropagation) {
						addIndividualToProcessingQueue(succIndi,calcAlgContext);
					}

				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateInitialVariableBindingsToSuccessor(CIndividualProcessNode*& processIndi, CIndividualProcessNode* succIndi, CConceptDescriptor* conDes, CVariableBindingPathSet* newVarBindingPathSet, CVariableBindingPathSet* prevVarBindingPathSet, CIndividualLinkEdge* restLink, CConceptVariableBindingPathSetHash* conVarBindingSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					CVariableBindingPathDescriptor* newVarBindPathDesLinker = nullptr;
					if (prevVarBindingPathSet) {
						newVarBindingPathSet->copyVariableBindingPaths(prevVarBindingPathSet->getVariableBindingPathMap());
						CVariableBindingPathMap* varBindPathMap = newVarBindingPathSet->getVariableBindingPathMap();
						for (CVariableBindingPathMap::iterator it = varBindPathMap->begin(), itEnd = varBindPathMap->end(); it != itEnd; ++it) {
							STATINC(VARBINDPROPAGATEDCOUNT,calcAlgContext);
							STATINC(VARBINDPROPAGATEDINITIALCOUNT,calcAlgContext);
							++mStatVarBindingPropagateSuccCount;
							++mStatVarBindingPropagateSuccInitialCount;
							CVariableBindingPathMapData& varBindPathMapData = it.value();
							CVariableBindingPathDescriptor* prevVarBindPathDes = varBindPathMapData.getVariableBindingPathDescriptor();
							CVariableBindingPathDescriptor* newVarBindPathDes = CObjectAllocator<CVariableBindingPathDescriptor>::allocateAndConstruct(taskMemMan);
							CDependencyTrackPoint* newDepTrackPoint = nullptr;
							CPROPAGATEVARIABLEBINDINGSSUCCESSORDependencyNode* bindDepNode = createPROPAGATEVARIABLEBINDINGSSUCCESSORDependency(newDepTrackPoint,processIndi,conDes,prevVarBindPathDes->getDependencyTrackPoint(),restLink->getDependencyTrackPoint(),calcAlgContext);
							newVarBindPathDes->initVariableBindingPathDescriptor(prevVarBindPathDes->getVariableBindingPath(),newDepTrackPoint);
							varBindPathMapData.setVariableBindingPathDescriptor(newVarBindPathDes);
							newVarBindPathDesLinker = newVarBindPathDes->append(newVarBindPathDesLinker);
							propagations = true;
						}
						if (newVarBindPathDesLinker) {
							newVarBindingPathSet->addVariableBindingPathDescriptorLinker(newVarBindPathDesLinker);
							conVarBindingSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDesLinker);
						}
					}
					return propagations;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateFreshVariableBindingsToSuccessor(CIndividualProcessNode*& processIndi, CIndividualProcessNode* succIndi, CConceptDescriptor* conDes, CVariableBindingPathSet* newVarBindingPathSet, CVariableBindingPathSet* prevVarBindingPathSet, CIndividualLinkEdge* restLink, CConceptVariableBindingPathSetHash* conVarBindingSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					if (prevVarBindingPathSet) {

						CVariableBindingPathMap* prevVarBindPathMap = prevVarBindingPathSet->getVariableBindingPathMap();
						CVariableBindingPathMap* newVarBindPathMap = newVarBindingPathSet->getVariableBindingPathMap();

						CVariableBindingPathMap::iterator itNew = newVarBindPathMap->begin();
						CVariableBindingPathMap::const_iterator itPrev = prevVarBindPathMap->constBegin(), itPrevEnd = prevVarBindPathMap->constEnd();

						CVariableBindingPathDescriptor* newVarBindPathDesLinker = nullptr;

						while (itPrev != itPrevEnd) {
							cint64 prevPropID = itPrev.key();
							bool doPropagation = false;
							if (itNew == newVarBindPathMap->end()) {
								doPropagation = true;
							} else {
								cint64 newPropID = itNew.key();
								if (newPropID < prevPropID) {
									++itNew;
								} else if (newPropID == prevPropID) {
									++itNew;
									++itPrev;
								} else {
									doPropagation = true;
								}
							}
							if (doPropagation) {
								STATINC(VARBINDPROPAGATEDCOUNT,calcAlgContext);
								STATINC(VARBINDPROPAGATEDFRESHCOUNT,calcAlgContext);
								++mStatVarBindingPropagateSuccCount;
								++mStatVarBindingPropagateSuccFreshCount;
								const CVariableBindingPathMapData& prevVarBindPathMapData = itPrev.value();
								CVariableBindingPathDescriptor* prevVarBindPathDes = prevVarBindPathMapData.getVariableBindingPathDescriptor();

								CVariableBindingPathDescriptor* newVarBindPathDes = CObjectAllocator<CVariableBindingPathDescriptor>::allocateAndConstruct(taskMemMan);

								CDependencyTrackPoint* newDepTrackPoint = nullptr;
								CPROPAGATEVARIABLEBINDINGSSUCCESSORDependencyNode* bindDepNode = createPROPAGATEVARIABLEBINDINGSSUCCESSORDependency(newDepTrackPoint,processIndi,conDes,prevVarBindPathDes->getDependencyTrackPoint(),restLink->getDependencyTrackPoint(),calcAlgContext);
								CVariableBindingPath* varBindingPath = prevVarBindPathDes->getVariableBindingPath();
								newVarBindPathDes->initVariableBindingPathDescriptor(varBindingPath,newDepTrackPoint);

								itNew = newVarBindPathMap->insert(varBindingPath->getPropagationID(),CVariableBindingPathMapData(newVarBindPathDes));

								newVarBindPathDesLinker = newVarBindPathDes->append(newVarBindPathDesLinker);
								propagations = true;
							}
						}
						if (newVarBindPathDesLinker) {
							newVarBindingPathSet->addVariableBindingPathDescriptorLinker(newVarBindPathDesLinker);
							conVarBindingSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDesLinker);
						}
					}
					return propagations;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();

					STATINC(VARBINDRULEALLAPPLICATIONCOUNT,calcAlgContext);

					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					if (restLink) {
						CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,restLink,calcAlgContext);

						propagateVariableBindingsToSuccessor(processIndi,succIndi,opLinker,negate,conDes,restLink,calcAlgContext);

					} else {
						CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
						if (roleSuccHash) {
							CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
							while (roleSuccIt.hasNext()) {
								CIndividualLinkEdge* link = roleSuccIt.next(true);
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);

								propagateVariableBindingsToSuccessor(processIndi,succIndi,opLinker,negate,conDes,link,calcAlgContext);
							}
						}
					}
					if (!conProDes->isConceptReapplied()) {
						if (!isConceptInReapplyQueue(conDes,role,processIndi,calcAlgContext)) {
							addConceptToReapplyQueue(conDes,role,processIndi,true,depTrackPoint,calcAlgContext);
						}
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDVARIABLERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CVariable* variable = concept->getVariable();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();

					CConcept* bindingTriggerConcept = opConLinker->getData();
					bool bindingTriggerConceptNegation = opConLinker->isNegated();

					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					STATINC(VARBINDRULEBINDAPPLICATIONCOUNT,calcAlgContext);

					bool updateExt = false;


					CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(false);
					if (conPropBindingSetHash) {
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);

						if (propBindingSet) {
							CPropagationVariableBindingTransitionExtension* propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(false);
							if (!propVarBindTransExt || !propVarBindTransExt->isProcessingCompleted()) {
								if (!propVarBindTransExt || propBindingSet->hasPropagateAllFlag()) {
									updateExt = true;
								} else {
									CPropagationBindingDescriptor* lastAnalyPropBindDes = propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor();
									CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();
									if (lastAnalyPropBindDes != propBindDes) {
										updateExt = true;
									}
								}
							}
						}
					}



					if (updateExt) {


						if (!mFirstBindingCreationDebugWritten) {
							mFirstBindingCreationDebugWritten = true;
							if (mConfDebuggingWriteData) {
								QString writingFolder = "./Debugging/CompletionTasks/";
								QFile file(QString("%1%2-task.txt").arg(writingFolder, "first-binding-creation"));
								mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
								if (file.open(QIODevice::WriteOnly)) {
									file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
									file.close();
								}
							}
						}


						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,true);
						CPropagationVariableBindingTransitionExtension* propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(true);

						CPropagationBindingDescriptor* lastAnalyPropBindDes = propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor();
						CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();

						propVarBindTransExt->setTriggeredVariableIndividualPair(variable,processIndi);
						bool createVarBinding = false;
						createVarBinding = propBindingSet->hasPropagateAllFlag();
						for (CPropagationBindingDescriptor* propBindDesIt = propBindDes; propBindDesIt != lastAnalyPropBindDes; propBindDesIt = propBindDesIt->getNext()) {
							if (propVarBindTransExt->addAnalysedPropagationBindingDescriptorReturnMatched(propBindDesIt)) {
								createVarBinding = true;
							}
						}
						propVarBindTransExt->setLastAnalysedPropagationBindingDescriptor(propBindDes);
						propVarBindTransExt->setLastAnalysedPropagateAllFlag(propBindingSet->hasPropagateAllFlag());

						if (createVarBinding) {
							++mStatVarBindingCreatedCount;
							STATINC(VARBINDVARIABLEBINDCOUNT,calcAlgContext);
							propVarBindTransExt->setProcessingCompleted(true);

							CConceptVariableBindingPathSetHash* conVarBindingPathSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* varBindPathSet = conVarBindingPathSetHash->getVariableBindingPathSet(bindingTriggerConcept,true);

							CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
							cint64 nextPathPropID = processingDataBox->getNextVariableBindingPathID(true);

							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CVARBINDVARIABLEDependencyNode* bindDepNode = createVARBINDVARIABLEDependency(nextDepTrackPoint,processIndi,conDes, depTrackPoint,calcAlgContext);


							if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
								bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);
							} else {
								setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
								CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
								addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
								if (!reapplyQueue->isEmpty()) {
									conSet = processIndi->getReapplyConceptLabelSet(true);
									CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
									applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
								}
							}

							varBindPathSet->setConceptDescriptor(bindingConDes);
							CVariableBinding* varBinding = CObjectAllocator<CVariableBinding>::allocateAndConstruct(taskMemMan);
							varBinding->initVariableBinding(nextDepTrackPoint,processIndi,variable);
							CVariableBindingDescriptor* varBindingDes = CObjectAllocator<CVariableBindingDescriptor>::allocateAndConstruct(taskMemMan);
							varBindingDes->initVariableBindingDescriptor(varBinding);
							CVariableBindingPath* varBindingPath = CObjectAllocator<CVariableBindingPath>::allocateAndConstruct(taskMemMan);
							varBindingPath->initVariableBindingPath(nextPathPropID,varBindingDes);
							CVariableBindingPathDescriptor* varBindingPathDes = CObjectAllocator<CVariableBindingPathDescriptor>::allocateAndConstruct(taskMemMan);
							varBindingPathDes->initVariableBindingPathDescriptor(varBindingPath,nextDepTrackPoint);
							varBindPathSet->addVariableBindingPath(varBindingPathDes);
							conVarBindingPathSetHash->setLastVariableBindingDescriptionLinker(varBindingPathDes);

						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEJOINRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();


					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* joinConDes = nullptr;
					CDependencyTrackPoint* joinDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* joinConcept = opLinker->getData();
					bool joinConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();

					CSortedLinker<CVariable*>* varLinker = concept->getVariableLinker();

					STATINC(VARBINDRULEJOINAPPLICATIONCOUNT,calcAlgContext);

					bool propagateJoins = false;
					bool createJoinConcept = false;
					if (!conSet->getConceptDescriptorAndReapplyQueue(joinConcept,joinConDes,joinDepTrackPoint,reapplyQueue)) {
						// search next not existing trigger
						bool allTriggersAvailable = true;
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CSortedNegLinker<CConcept*>* triggerLinkerIt = nullptr;
						for (triggerLinkerIt = triggerLinker; triggerLinkerIt && allTriggersAvailable; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
								if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
									return;
								}
							} else {
								allTriggersAvailable = false;
								break;
							}
						}

						if (!allTriggersAvailable) {
							// install to trigger
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							bool triggerNegation = !nextTrigger->isNegated();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						} else {
							propagateJoins = true;
							createJoinConcept = true;
						}
					} else {
						propagateJoins = true;
					}

					//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);

					bool propagationsDone = false;
					if (propagateJoins) {

						for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,false,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,false,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						}

						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(false);
						CConceptVariableBindingPathSetHash* varBindingPathSetHash = processIndi->getConceptVariableBindingPathSetHash(false);
						CPropagationBindingSet* propBindingSet = nullptr;
						if (conPropBindingSetHash && varBindingPathSetHash) {
							propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							if (propBindingSet) {

								CPropagationVariableBindingTransitionExtension* propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(false);

								CSortedNegLinker<CConcept*>* leftTriggerLinker = triggerLinker;
								CSortedNegLinker<CConcept*>* rightTriggerLinker = triggerLinker->getNext();

								CConcept* leftConcept = leftTriggerLinker->getData();
								CConcept* rightConcept = rightTriggerLinker->getData();

								CVariableBindingPathSet* leftVarBindPathSet = varBindingPathSetHash->getVariableBindingPathSet(leftConcept,false);
								CVariableBindingPathSet* rightVarBindPathSet = varBindingPathSetHash->getVariableBindingPathSet(rightConcept,false);

								bool examineTransExt = false;

								if (leftVarBindPathSet && rightVarBindPathSet) {

									if (!propVarBindTransExt) {
										examineTransExt = true;
									} else {
										if (propVarBindTransExt->getLastAnalysedPropagateAllFlag() != propBindingSet->getPropagateAllFlag() ||
													propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor() != propBindingSet->getPropagationBindingDescriptorLinker() || 
													propVarBindTransExt->getLeftLastVariableBindingPathJoiningDescriptor() != leftVarBindPathSet->getVariableBindingPathDescriptorLinker() || 
													propVarBindTransExt->getRightLastVariableBindingPathJoiningDescriptor() != rightVarBindPathSet->getVariableBindingPathDescriptorLinker()) {

											examineTransExt = true;
										}
									}
								}

								if (examineTransExt) {
									conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
									varBindingPathSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
									propBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,true);
									propVarBindTransExt = propBindingSet->getPropagationVariableBindingTransitionExtension(true);


									CVariableBindingPathSet* joinVarBindingPathSet = nullptr;

									CVariableBindingTriggerHash* varBindTriggerHash = propVarBindTransExt->getVariableBindingTriggerHash(true);
									CVariableBindingPathJoiningHash* varBindPathJoinHash = propVarBindTransExt->getVariableBindingPathJoiningHash(true);

									CPropagationBindingDescriptor* lastAnalyPropBindDes = propVarBindTransExt->getLastAnalysedPropagationBindingDescriptor();
									CPropagationBindingDescriptor* propBindDes = propBindingSet->getPropagationBindingDescriptorLinker();

									bool propAllFlag = propBindingSet->hasPropagateAllFlag();

									if (propAllFlag) {

										for (CVariableBindingTriggerHash::iterator it = varBindTriggerHash->begin(), itEnd = varBindTriggerHash->end(); it != itEnd; ++it) {
											CVariableBindingTriggerData& data = it.value();
											CVariableBindingTriggerLinker* varBindTriggerLinker = data.getVariableBindingTriggerLinker();
											data.setTriggered(true);
											data.clearVariableBindingTriggerLinker();
											for (CVariableBindingTriggerLinker* varBindTriggerIt = varBindTriggerLinker; varBindTriggerIt; varBindTriggerIt = varBindTriggerIt->getNext()) {
												STATINC(VARBINDJOINTRIGGEREXECUTECOUNT,calcAlgContext);

												CVariableBindingPathDescriptor* varBindPathDes = varBindTriggerIt->getVariableBindingPathDescriptor();
												CVariableBindingDescriptor* varBindTriggerDes = varBindTriggerIt->getNextTriggerVariableBindingDescriptor();
												bool leftTriggered = varBindTriggerIt->isLeftTriggered();

												propagationsDone |= propagateVariableBindingsJoins(processIndi,conDes,joinConcept,varBindPathDes,leftTriggered,varBindPathJoinHash,varBindingPathSetHash,joinConDes,joinVarBindingPathSet,calcAlgContext);
											}
										}

									} else {

										for (CPropagationBindingDescriptor* propBindDesIt = propBindDes; propBindDesIt != lastAnalyPropBindDes; propBindDesIt = propBindDesIt->getNext()) {
											CVariableBindingTriggerLinker* varBindTriggerLinker = nullptr;
											if (propVarBindTransExt->addAnalysedPropagationBindingDescriptorReturnMatched(propBindDesIt,&varBindTriggerLinker)) {
												for (CVariableBindingTriggerLinker* varBindTriggerIt = varBindTriggerLinker; varBindTriggerIt; varBindTriggerIt = varBindTriggerIt->getNext()) {
													STATINC(VARBINDJOINTRIGGEREXECUTECOUNT,calcAlgContext);

													CVariableBindingPathDescriptor* varBindPathDes = varBindTriggerIt->getVariableBindingPathDescriptor();
													CVariableBindingDescriptor* varBindTriggerDes = varBindTriggerIt->getNextTriggerVariableBindingDescriptor();
													bool leftTriggered = varBindTriggerIt->isLeftTriggered();

													if (!triggerVariableBindingPathJoining(processIndi,varBindPathDes,varBindTriggerDes,leftTriggered,varBindTriggerHash,calcAlgContext)) {
														propagationsDone |= propagateVariableBindingsJoins(processIndi,conDes,joinConcept,varBindPathDes,leftTriggered,varBindPathJoinHash,varBindingPathSetHash,joinConDes,joinVarBindingPathSet,calcAlgContext);
													}
												}
											}
										}

									}
									propVarBindTransExt->setLastAnalysedPropagationBindingDescriptor(propBindDes);
									propVarBindTransExt->setLastAnalysedPropagateAllFlag(propBindingSet->hasPropagateAllFlag());



									if (propVarBindTransExt->getLeftLastVariableBindingPathJoiningDescriptor() != leftVarBindPathSet->getVariableBindingPathDescriptorLinker()) {
										for (CVariableBindingPathDescriptor* varBindPathDes = leftVarBindPathSet->getVariableBindingPathDescriptorLinker(); varBindPathDes != propVarBindTransExt->getLeftLastVariableBindingPathJoiningDescriptor(); varBindPathDes = varBindPathDes->getNext()) {
											CVariableBindingPath* varBindPath = varBindPathDes->getVariableBindingPath();

											CVariableBindingDescriptor* varBindTriggerDes = varBindPath->getVariableBindingDescriptorLinker();
											bool leftTriggered = true;

											if (propAllFlag || !triggerVariableBindingPathJoining(processIndi,varBindPathDes,varBindTriggerDes,leftTriggered,varBindTriggerHash,calcAlgContext)) {
												propagationsDone |= propagateVariableBindingsJoins(processIndi,conDes,joinConcept,varBindPathDes,leftTriggered,varBindPathJoinHash,varBindingPathSetHash,joinConDes,joinVarBindingPathSet,calcAlgContext);
											}
										}
										propVarBindTransExt->setLeftLastVariableBindingPathJoiningDescriptor(leftVarBindPathSet->getVariableBindingPathDescriptorLinker());
									}



									if (propVarBindTransExt->getRightLastVariableBindingPathJoiningDescriptor() != rightVarBindPathSet->getVariableBindingPathDescriptorLinker()) {
										for (CVariableBindingPathDescriptor* varBindPathDes = rightVarBindPathSet->getVariableBindingPathDescriptorLinker(); varBindPathDes != propVarBindTransExt->getRightLastVariableBindingPathJoiningDescriptor(); varBindPathDes = varBindPathDes->getNext()) {
											CVariableBindingPath* varBindPath = varBindPathDes->getVariableBindingPath();

											CVariableBindingDescriptor* varBindTriggerDes = varBindPath->getVariableBindingDescriptorLinker();
											bool leftTriggered = false;

											if (propAllFlag || !triggerVariableBindingPathJoining(processIndi,varBindPathDes,varBindTriggerDes,leftTriggered,varBindTriggerHash,calcAlgContext)) {
												propagationsDone |= propagateVariableBindingsJoins(processIndi,conDes,joinConcept,varBindPathDes,leftTriggered,varBindPathJoinHash,varBindingPathSetHash,joinConDes,joinVarBindingPathSet,calcAlgContext);
											}
										}
										propVarBindTransExt->setRightLastVariableBindingPathJoiningDescriptor(rightVarBindPathSet->getVariableBindingPathDescriptorLinker());
									}


								}
							}
						}


					}

					if (propagationsDone) {
						if (!createJoinConcept) {
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
							addConceptPreprocessedToProcessingQueue(joinConDes,joinDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
							if (!reapplyQueue->isEmpty()) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(joinConDes));
								applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
							}
						}
					}
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateVariableBindingsJoins(CIndividualProcessNode* processIndi, CConceptDescriptor* joiningConDes, CConcept* joinConcept, CVariableBindingPathDescriptor* varBindPathDes, bool leftTriggerPath,  
								CVariableBindingPathJoiningHash* varBindPathJoinHash, CConceptVariableBindingPathSetHash* varBindingPathSetHash, CConceptDescriptor*& joinConDes, CVariableBindingPathSet*& varBindingPathSet, CCalculationAlgorithmContextBase* calcAlgContext) {

					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConcept* joiningConcept = joiningConDes->getConcept();
					CSortedLinker<CVariable*>* varLinker = joiningConcept->getVariableLinker();

					CVariableBindingPath* varBindPath = varBindPathDes->getVariableBindingPath();
					CVariableBindingPathJoiningData* varBindPathJoinData = varBindPathJoinHash->getVariableBindingPathJoiningData(CVariableBindingPathJoiningHasher(varBindPath,varLinker),true);
					CVariableBindingDescriptor* varBindDes = varBindPath->getVariableBindingDescriptorLinker();

					if (!varBindPathJoinData) {
						varBindPathJoinData = CObjectAllocator< CVariableBindingPathJoiningData >::allocateAndConstruct(taskMemMan);
						CVariableBindingDescriptor* keyVarBindDesLinker = createVariableBindingPathKey(processIndi,varLinker,varBindDes,calcAlgContext);
						varBindPathJoinData->initVariableBindingPathJoiningData(keyVarBindDesLinker,nullptr,nullptr);
						varBindPathJoinHash->insertVariableBindingPathJoiningData(CVariableBindingPathJoiningHasher(varBindPathJoinData),varBindPathJoinData);
					}


					CVariableBindingPathDescriptor* otherVarBindPathDes = nullptr;
					if (leftTriggerPath) {
						otherVarBindPathDes = varBindPathJoinData->getRightVariableBindingPathDescriptorLinker();
					} else {
						otherVarBindPathDes = varBindPathJoinData->getLeftVariableBindingPathDescriptorLinker();
					}


					bool addedVarBindPath = false;
					for (CVariableBindingPathDescriptor* otherVarBindPathDesIt = otherVarBindPathDes; otherVarBindPathDesIt; otherVarBindPathDesIt = otherVarBindPathDesIt->getNext()) {
						STATINC(VARBINDJOINCOMBINECOUNT,calcAlgContext);
						++mStatVarBindingJoinCombinesCount;

						CVariableBindingPath* mergedVarBindPath = getJoinedVariableBindingPath(varBindPathDes->getVariableBindingPath(),otherVarBindPathDesIt->getVariableBindingPath(),calcAlgContext);
						CVariableBindingPathDescriptor* mergedVarBindPathDes = CObjectAllocator< CVariableBindingPathDescriptor >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());

						CDependencyTrackPoint* mergedDependencyTrackPoint = nullptr;
						CVARBINDPROPAGATEJOINDependencyNode* bindJoinDepNode = createVARBINDPROPAGATEJOINDependency(mergedDependencyTrackPoint,processIndi,joiningConDes,varBindPathDes->getDependencyTrackPoint(),otherVarBindPathDesIt->getDependencyTrackPoint(),calcAlgContext);

						forceVariableBindingJoinCreated(processIndi,joiningConDes,joinConcept,joinConDes,mergedDependencyTrackPoint,varBindingPathSet,varBindingPathSetHash,calcAlgContext);

						mergedVarBindPathDes->initVariableBindingPathDescriptor(mergedVarBindPath,mergedDependencyTrackPoint);
						varBindingPathSet->addVariableBindingPath(mergedVarBindPathDes);

						addedVarBindPath = true;
					}

					CVariableBindingPathDescriptor* newVarBindPathDes = CObjectAllocator< CVariableBindingPathDescriptor >::allocateAndConstruct(taskMemMan);
					newVarBindPathDes->initVariableBindingPathDescriptor(varBindPath,varBindPathDes->getDependencyTrackPoint());


					if (leftTriggerPath) {
						varBindingPathSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDes);
						varBindPathJoinData->addLeftVariableBindingPathDescriptorLinker(newVarBindPathDes);
					} else {
						varBindingPathSetHash->setLastVariableBindingDescriptionLinker(newVarBindPathDes);
						varBindPathJoinData->addRightVariableBindingPathDescriptorLinker(newVarBindPathDes);
					}

					return addedVarBindPath;
				}





				CVariableBindingDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createVariableBindingPathKey(CIndividualProcessNode* processIndi, CSortedLinker<CVariable*>* varLinker, CVariableBindingDescriptor* varBindDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CVariableBindingDescriptor* keyVarBindDesLinker = nullptr;
					CVariableBindingDescriptor* lastKeyVarBindDesLinker = nullptr;
					CSortedLinker<CVariable*>* varLinkerIt = varLinker;
					CVariableBindingDescriptor* varBindDesIt = varBindDes;
					while (varLinkerIt) {
						CVariableBinding* varBind = varBindDesIt->getVariableBinding();
						if (varBind->getBindedVariable() == varLinkerIt->getData()) {
							CVariableBindingDescriptor* nextKeyVarBindDesLinker = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
							nextKeyVarBindDesLinker->initVariableBindingDescriptor(varBind);

							if (lastKeyVarBindDesLinker) {
								lastKeyVarBindDesLinker->setNext(nextKeyVarBindDesLinker);
								lastKeyVarBindDesLinker = nextKeyVarBindDesLinker;
							} else {
								keyVarBindDesLinker = lastKeyVarBindDesLinker = nextKeyVarBindDesLinker;
							}
							varLinkerIt = varLinkerIt->getNext();
							varBindDesIt = varBindDesIt->getNext();
						} else {
							varBindDesIt = varBindDesIt->getNext();
						}
					}
					return keyVarBindDesLinker;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::triggerVariableBindingPathJoining(CIndividualProcessNode* processIndi, CVariableBindingPathDescriptor* varBindPathDes, CVariableBindingDescriptor* varBindDes, bool leftTriggered, CVariableBindingTriggerHash* varBindTriggerHash, CCalculationAlgorithmContextBase* calcAlgContext) {

					CVariableBindingDescriptor* nextVarBindDesTrigger = varBindDes;
					if (nextVarBindDesTrigger) {
						while (nextVarBindDesTrigger) {
							CVariableBinding* varBind = nextVarBindDesTrigger->getVariableBinding();
							nextVarBindDesTrigger = nextVarBindDesTrigger->getNext();
							if (!varBindTriggerHash->tryInsertVariableBindingTrigger(varBind->getBindedVariable(),varBind->getBindedIndividual(),varBindPathDes,nextVarBindDesTrigger,leftTriggered)) {
							} else {
								STATINC(VARBINDJOINTRIGGERINSTALLCOUNT,calcAlgContext);
								return true;
							}
						}
					}
					return false;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::forceVariableBindingJoinCreated(CIndividualProcessNode* processIndi, CConceptDescriptor* joiningConDes, CConcept* joinConcept, CConceptDescriptor*& joinConDes, CDependencyTrackPoint* mergedDependencyTrackPoint, CVariableBindingPathSet*& varBindingPathSet, CConceptVariableBindingPathSetHash* varBindingPathSetHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!joinConDes) {
						joinConDes = addConceptToIndividualReturnConceptDescriptor(joinConcept,false,processIndi,mergedDependencyTrackPoint,false,false,calcAlgContext);
					}
					if (!varBindingPathSet) {
						varBindingPathSet = varBindingPathSetHash->getVariableBindingPathSet(joinConcept,true);
						varBindingPathSet->setConceptDescriptor(joinConDes);
					}
				}



				CVariableBindingPath* CCalculationTableauCompletionTaskHandleAlgorithm::getJoinedVariableBindingPath(CVariableBindingPath* leftVarBindPath, CVariableBindingPath* rightVarBindPath, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
					CVariableBindingPathMergingHash* varBindPathMergingHash = processingDataBox->getVariableBindingPathMergingHash(true);

					CVariableBindingPathMergingHashData* mergeHashData = varBindPathMergingHash->getMergedVariableBindingPathData(leftVarBindPath,rightVarBindPath);
					CVariableBindingPath* mergedVarBindPath = mergeHashData->getVariableBindingPath();
					if (!mergedVarBindPath) {
						STATINC(VARBINDJOINCREATENEWCOUNT,calcAlgContext);

						CVariableBindingDescriptor* leftVarBindDesIt = leftVarBindPath->getVariableBindingDescriptorLinker();
						CVariableBindingDescriptor* rightVarBindDesIt = rightVarBindPath->getVariableBindingDescriptorLinker();

						CVariableBindingDescriptor* mergedVarBindDes = nullptr;
						CVariableBindingDescriptor* lastMergedVarBindDes = nullptr;

						while (leftVarBindDesIt || rightVarBindDesIt) {
							CVariableBindingDescriptor* nextMergedVarBindDes = nullptr;
							if (leftVarBindDesIt && rightVarBindDesIt) {
								bool leftLE = *leftVarBindDesIt->getVariableBinding() <= *rightVarBindDesIt->getVariableBinding();
								bool rightLE = *rightVarBindDesIt->getVariableBinding() <= *leftVarBindDesIt->getVariableBinding();
								if (leftLE && rightLE) {
									nextMergedVarBindDes = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
									nextMergedVarBindDes->initVariableBindingDescriptor(leftVarBindDesIt->getVariableBinding());
									leftVarBindDesIt = leftVarBindDesIt->getNext();
									rightVarBindDesIt = rightVarBindDesIt->getNext();
								} else if (rightLE) {
									nextMergedVarBindDes = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
									nextMergedVarBindDes->initVariableBindingDescriptor(rightVarBindDesIt->getVariableBinding());
									rightVarBindDesIt = rightVarBindDesIt->getNext();
								} else if (leftLE) {
									nextMergedVarBindDes = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
									nextMergedVarBindDes->initVariableBindingDescriptor(leftVarBindDesIt->getVariableBinding());
									leftVarBindDesIt = leftVarBindDesIt->getNext();
								} 
							} else if (leftVarBindDesIt) {
								nextMergedVarBindDes = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
								nextMergedVarBindDes->initVariableBindingDescriptor(leftVarBindDesIt->getVariableBinding());
								leftVarBindDesIt = leftVarBindDesIt->getNext();
							} else if (rightVarBindDesIt) {
								nextMergedVarBindDes = CObjectAllocator< CVariableBindingDescriptor >::allocateAndConstruct(taskMemMan);
								nextMergedVarBindDes->initVariableBindingDescriptor(rightVarBindDesIt->getVariableBinding());
								rightVarBindDesIt = rightVarBindDesIt->getNext();
							}

							if (nextMergedVarBindDes) {
								if (lastMergedVarBindDes) {
									lastMergedVarBindDes->setNext(nextMergedVarBindDes);
									lastMergedVarBindDes = nextMergedVarBindDes;
								} else {
									mergedVarBindDes = lastMergedVarBindDes = nextMergedVarBindDes;
								}
							}
						}

						mergedVarBindPath = CObjectAllocator< CVariableBindingPath >::allocateAndConstruct(taskMemMan);
						mergedVarBindPath->initVariableBindingPath(processingDataBox->getNextVariableBindingPathID(true),mergedVarBindDes);
						mergeHashData->setVariableBindingPath(mergedVarBindPath);
					}
					return mergedVarBindPath;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEGROUNDINGRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();
					bool negated = conDes->isNegated();
					cint64 opCount = concept->getOperandCount();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CConceptVariableBindingPathSetHash* conVarBindPathSetHash = processIndi->getConceptVariableBindingPathSetHash(false);
					CVariableBindingPathSet* varBindPathSet = conVarBindPathSetHash->getVariableBindingPathSet(concept,false);

					STATINC(VARBINDRULEGROUNDINGAPPLICATIONCOUNT,calcAlgContext);

					if (varBindPathSet) {

						KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));

						CPROCESSINGHASH<CConcept*,CVariableBindingPathDescriptor*>* groundedConVarBindPathDesHash = nullptr;
						CSortedNegLinker<CConcept*>* newGroundedLinker = mGroundingHandler->getGroundingConceptLinker(processIndi,varBindPathSet,concept,negated,groundedConVarBindPathDesHash,calcAlgContext);

						if (newGroundedLinker) {
							for (CSortedNegLinker<CConcept*>* newGroundedLinkerIt = newGroundedLinker; newGroundedLinkerIt; newGroundedLinkerIt = newGroundedLinkerIt->getNext()) {
								STATINC(VARBINDGROUNDINGCOUNT,calcAlgContext);
								++mStatVarBindingGroundingCount;
								CConcept* newGroundedCocnept = newGroundedLinkerIt->getData();
								bool newGroundedConceptNegation = newGroundedLinkerIt->isNegated();

								CDependencyTrackPoint* baseDependencyTrackPoint = nullptr;
								CDependency* additionalsDependencies = nullptr;
								// collect dependencies

								CPROCESSINGHASH<CConcept*,CVariableBindingPathDescriptor*>::const_iterator it = groundedConVarBindPathDesHash->constFind(newGroundedCocnept), itEnd = groundedConVarBindPathDesHash->constEnd();
								while (it != itEnd && it.key() == newGroundedCocnept) {
									CVariableBindingPathDescriptor* varBindPathDes = it.value();
									CDependencyTrackPoint* propVarDepTrackPoint = varBindPathDes->getDependencyTrackPoint();
									if (propVarDepTrackPoint) {
										if (!baseDependencyTrackPoint) {
											baseDependencyTrackPoint = propVarDepTrackPoint;
										}
									}
									++it;
								}

								if (!baseDependencyTrackPoint) {
									baseDependencyTrackPoint = depTrackPoint;
								}

								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CVARBINDPROPAGATEGROUNDINGDependencyNode* groundingDepNode = createVARBINDPROPAGATEGROUNDINGDependency(nextDepTrackPoint,processIndi,conDes,baseDependencyTrackPoint,additionalsDependencies,calcAlgContext);

								addConceptToIndividual(newGroundedCocnept,newGroundedConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);

							}
						}

						KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mAfterGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPROPAGATEIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();


					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* bindingTriggerConcept = opLinker->getData();
					bool bindingTriggerConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();

					STATINC(VARBINDRULEIMPLICATIONAPPLICATIONCOUNT,calcAlgContext);

					if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {

						// search next not existing trigger
						bool allTriggersAvailable = true;
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CSortedNegLinker<CConcept*>* triggerLinkerIt = nullptr;
						for (triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
								if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
									return;
								}
							} else {
								allTriggersAvailable = false;
								break;
							}
						}

						if (!allTriggersAvailable) {
							// install to trigger
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							bool triggerNegation = !nextTrigger->isNegated();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						} else {
							CDependency* triggerDeps = nullptr;
							for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
								CConcept* triggerConcept = triggerLinkerIt->getData();
								CConceptDescriptor* triggerConDes = nullptr;
								CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
								conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
								CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
								connDep->setNext(triggerDeps);
								triggerDeps = connDep;
							}

							++mStatVarBindingImplicationCount;
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CVARBINDPROPAGATEIMPLICATIONDependencyNode* implDepNode = createVARBINDPROPAGATEIMPLICATIONDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,triggerDeps,calcAlgContext);

							bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);

							CConceptVariableBindingPathSetHash* conVarBindingSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
							CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(concept,false);
							CVariableBindingPathSet* varBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(bindingTriggerConcept,true);
							varBindingPathSet->setConceptDescriptor(bindingConDes);

							propagateInitialVariableBindings(processIndi,bindingConDes,varBindingPathSet,prevVarBindingPathSet,triggerDeps, conVarBindingSetHash, calcAlgContext);


						}
					} else {
						CDependency* triggerDeps = nullptr;
						for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CConcept* triggerConcept = triggerLinkerIt->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
							CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
							connDep->setNext(triggerDeps);
							triggerDeps = connDep;
						}
						++mStatVarBindingImplicationCount;

						CConceptVariableBindingPathSetHash* conVarBindingSetHash = processIndi->getConceptVariableBindingPathSetHash(true);
						CVariableBindingPathSet* prevVarBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(concept,false);
						CVariableBindingPathSet* varBindingPathSet = conVarBindingSetHash->getVariableBindingPathSet(bindingTriggerConcept,true);

						if (propagateFreshVariableBindings(processIndi,conDes,varBindingPathSet,prevVarBindingPathSet,triggerDeps, conVarBindingSetHash, calcAlgContext)) {
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
							cint64 bindingCount = varBindingPathSet->getVariableBindingPathMap()->count();
							addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,bindingCount,calcAlgContext);
							if (!reapplyQueue->isEmpty()) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
								applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
							}
						}
					}
				}






				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDPREPARERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();


					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CDependencyTrackPoint* nextDepTrackPoint = nullptr;

					STATINC(VARBINDRULEANDAPPLICATIONCOUNT, calcAlgContext);

					CSatisfiableTaskAnswererBindingPropagationAdapter* answererMessageAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableAnswererBindingPropagationAdapter();
					if (answererMessageAdapter) {
						CAnsweringPropagationSteeringController* propagationSteeringController = answererMessageAdapter->getAnswererPropagationSteeringController();
						if (propagationSteeringController) {

							for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
								CConcept* bindingTriggerConcept = opConLinkerIt->getData();
								bool bindingTriggerConceptNegation = opConLinkerIt->isNegated() ^ conceptNegation;

								CConceptDescriptor* bindingConDes = nullptr;
								CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
								CCondensedReapplyQueue* reapplyQueue = nullptr;

								if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept, bindingConDes, bindingDepTrackPoint, reapplyQueue)) {

									bool propagateAll = false;
									bool propagateNominal = false;
									bool propagateBindings = false;
									CVariable* variable = nullptr;
									CIndividual* nominalIndi = processIndi->getNominalIndividual();
									if (bindingTriggerConcept->getOperatorCode() == CCVARBINDJOIN) {
										propagateAll = true;
										propagateBindings = true;
									} else {
										variable = bindingTriggerConcept->getVariable();
										if (bindingTriggerConcept->getOperatorCode() == CCVARBINDVARIABLE) {
											propagateBindings = true;
										} else {
											variable = concept->getVariable();
										}
										if (variable) {
											propagateAll = propagationSteeringController->isPreparationBindingAllIndividuals(variable);
											if (nominalIndi) {
												propagateNominal = propagationSteeringController->isPreparationBindingNominalIndividual(variable, nominalIndi);
											}
										}
									}

									if (!nextDepTrackPoint) {
										conSet = processIndi->getReapplyConceptLabelSet(true);
										if (propagateBindings) {
											CVARBINDPROPAGATEANDDependencyNode* bindDepNode = createVARBINDPROPAGATEANDDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, calcAlgContext);
										} else {
											CANDDependencyNode* andDepNode = createANDDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, calcAlgContext);
										}
									}

									CPropagationBindingSet* propBindingSet = nullptr;
									if (propagateBindings) {
										CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
										propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept, true);
										if (propagateAll | propagateNominal) {
											propBindingSet->setPropagateAllFlag(true);
										}
									}

									bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept, bindingTriggerConceptNegation, processIndi, nextDepTrackPoint, false, false, calcAlgContext);
									if (propBindingSet) {
										propBindingSet->setConceptDescriptor(bindingConDes);
									}

								}
							}
						}
					}
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVARBINDFINALIZERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();


					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);


					STATINC(VARBINDRULEANDAPPLICATIONCOUNT, calcAlgContext);

					CConcept* topConcept = procDataBox->getOntologyTopConcept();

					CSatisfiableTaskAnswererBindingPropagationAdapter* answererMessageAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableAnswererBindingPropagationAdapter();
					if (answererMessageAdapter) {
						CAnsweringPropagationSteeringController* propagationSteeringController = answererMessageAdapter->getAnswererPropagationSteeringController();
						if (propagationSteeringController) {
							if (propagationSteeringController->finalizeWithClashing()) {
								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								if (!nextDepTrackPoint) {
									conSet = processIndi->getReapplyConceptLabelSet(true);
									CVARBINDPROPAGATEANDDependencyNode* bindDepNode = createVARBINDPROPAGATEANDDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, calcAlgContext);
								}
								addConceptToIndividualReturnConceptDescriptor(topConcept, true, processIndi, nextDepTrackPoint, false, false, calcAlgContext);
							}
							if (propagationSteeringController->finalizeWithBindingExtraction()) {
								bool nondeterministically = true;
								if (depTrackPoint && depTrackPoint->getBranchingTag() <= 0) {
									nondeterministically = false;
								}

								calcAlgContext->getProcessingDataBox()->getMarkerIndividualNodeHash(true)->addMarkerIndividualNode(concept, processIndi, nondeterministically);
							}
						}
					}




				}




































































































				// back propagation (propagation of candidates)

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEGROUNDINGRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();
					bool negated = conDes->isNegated();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CConceptPropagationBindingSetHash* conPropBindSetHash = processIndi->getConceptPropagationBindingSetHash(false);
					CPropagationBindingSet* propBindSet = conPropBindSetHash->getPropagationBindingSet(concept,false);

					if (propBindSet) {
						STATINC(PBINDRULEGROUNDINGAPPLICATIONCOUNT,calcAlgContext);

						if (!opConLinker) {

							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));

							CPROCESSINGHASH<CConcept*,CPropagationBindingDescriptor*>* groundedConPropBindDesHash = nullptr;
							CPROCESSINGHASH<CVariable*,CPropagationBindingDescriptor*>* additionalPropBindDesHash = nullptr;
							CSortedNegLinker<CConcept*>* newGroundedLinker = mGroundingHandler->getGroundingConceptLinker(processIndi,propBindSet,concept,negated,groundedConPropBindDesHash,additionalPropBindDesHash,calcAlgContext);

							if (newGroundedLinker) {
								for (CSortedNegLinker<CConcept*>* newGroundedLinkerIt = newGroundedLinker; newGroundedLinkerIt; newGroundedLinkerIt = newGroundedLinkerIt->getNext()) {
									CConcept* newGroundedCocnept = newGroundedLinkerIt->getData();
									bool newGroundedConceptNegation = newGroundedLinkerIt->isNegated();

									STATINC(PBINDGROUNDINGCOUNT,calcAlgContext);

									CDependencyTrackPoint* baseDependencyTrackPoint = nullptr;
									CDependency* additionalsDependencies = nullptr;
									// collect dependencies


									CPROCESSINGHASH<CConcept*,CPropagationBindingDescriptor*>::const_iterator it = groundedConPropBindDesHash->constFind(newGroundedCocnept), itEnd = groundedConPropBindDesHash->constEnd();
									while (it != itEnd && it.key() == newGroundedCocnept) {
										CPropagationBindingDescriptor* propBindDes = it.value();
										CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();
										if (propBindDepTrackPoint) {
											if (!baseDependencyTrackPoint) {
												baseDependencyTrackPoint = propBindDepTrackPoint;
											} else {
												CPROPAGATECONNECTIONDependencyNode* connDep = createPROPAGATECONNECTIONDependency(nullptr,conDes,propBindDepTrackPoint,calcAlgContext);
												additionalsDependencies = connDep->append(additionalsDependencies);
											}
										}
										++it;
									}

									for (CPROCESSINGHASH<CVariable*,CPropagationBindingDescriptor*>::const_iterator it = additionalPropBindDesHash->constBegin(), itEnd = additionalPropBindDesHash->constEnd(); it != itEnd; ++it) {
										CPropagationBindingDescriptor* propBindDes = *it;
										CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();
										if (propBindDepTrackPoint) {
											if (!baseDependencyTrackPoint) {
												baseDependencyTrackPoint = propBindDepTrackPoint;
											} else {
												CPROPAGATECONNECTIONDependencyNode* connDep = createPROPAGATECONNECTIONDependency(nullptr,conDes,propBindDepTrackPoint,calcAlgContext);
												additionalsDependencies = connDep->append(additionalsDependencies);
											}
										}
									}

									if (!baseDependencyTrackPoint) {
										baseDependencyTrackPoint = depTrackPoint;
									}

									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CBINDPROPAGATEGROUNDINGDependencyNode* groundingDepNode = createBINDPROPAGATEGROUNDINGDependency(nextDepTrackPoint,processIndi,conDes,baseDependencyTrackPoint,additionalsDependencies,calcAlgContext);
									addConceptToIndividual(newGroundedCocnept,newGroundedConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);
								}
							}
							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mAfterGroundingDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext));
						} else {


							CPROCESSINGHASH<CConcept*,CPropagationBindingDescriptor*>* groundedConPropBindDesHash = nullptr;
							CPROCESSINGHASH<CVariable*,CPropagationBindingDescriptor*>* additionalPropBindDesHash = nullptr;
							CSortedNegLinker<CConcept*>* newGroundedLinker = mGroundingHandler->getGroundingConceptLinker(processIndi,propBindSet,concept,negated,groundedConPropBindDesHash,additionalPropBindDesHash,calcAlgContext);

							if (newGroundedLinker) {

								for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
									CConcept* bindingTriggerConcept = opConLinkerIt->getData();
									bool bindingTriggerConceptNegation = opConLinkerIt->isNegated();

									CConceptDescriptor* bindingConDes = nullptr;
									CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
									CCondensedReapplyQueue* reapplyQueue = nullptr;

									CPropagationBindingSet* prevPropBindingSet = propBindSet;
									CPropagationBindingSet* newPropBindingSet = conPropBindSetHash->getPropagationBindingSet(bindingTriggerConcept,true);

									bool createdBindConcept = false;
									bool doneBindPropagations = false;

									if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
										CConcept* newGroundedCocnept = newGroundedLinker->getData();
										bool newGroundedConceptNegation = newGroundedLinker->isNegated();

										CDependencyTrackPoint* baseDependencyTrackPoint = nullptr;
										CDependency* additionalsDependencies = nullptr;
										CPROCESSINGHASH<CConcept*,CPropagationBindingDescriptor*>::const_iterator it = groundedConPropBindDesHash->constFind(newGroundedCocnept), itEnd = groundedConPropBindDesHash->constEnd();
										while (it != itEnd && it.key() == newGroundedCocnept) {
											CPropagationBindingDescriptor* propBindDes = it.value();
											CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();
											if (propBindDepTrackPoint) {
												if (!baseDependencyTrackPoint) {
													baseDependencyTrackPoint = propBindDepTrackPoint;
												} else {
													CPROPAGATECONNECTIONDependencyNode* connDep = createPROPAGATECONNECTIONDependency(nullptr,conDes,propBindDepTrackPoint,calcAlgContext);
													additionalsDependencies = connDep->append(additionalsDependencies);
												}
											}
											++it;
										}

										for (CPROCESSINGHASH<CVariable*,CPropagationBindingDescriptor*>::const_iterator it = additionalPropBindDesHash->constBegin(), itEnd = additionalPropBindDesHash->constEnd(); it != itEnd; ++it) {
											CPropagationBindingDescriptor* propBindDes = *it;
											CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();
											if (propBindDepTrackPoint) {
												if (!baseDependencyTrackPoint) {
													baseDependencyTrackPoint = propBindDepTrackPoint;
												} else {
													CPROPAGATECONNECTIONDependencyNode* connDep = createPROPAGATECONNECTIONDependency(nullptr,conDes,propBindDepTrackPoint,calcAlgContext);
													additionalsDependencies = connDep->append(additionalsDependencies);
												}
											}
										}

										if (!baseDependencyTrackPoint) {
											baseDependencyTrackPoint = depTrackPoint;
										}
										CDependencyTrackPoint* nextDepTrackPoint = nullptr;
										CBINDPROPAGATEGROUNDINGDependencyNode* groundingDepNode = createBINDPROPAGATEGROUNDINGDependency(nextDepTrackPoint,processIndi,conDes,baseDependencyTrackPoint,additionalsDependencies,calcAlgContext);

										bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);
										conSet = processIndi->getReapplyConceptLabelSet(true);

										createdBindConcept = true;
									}



									for (CSortedNegLinker<CConcept*>* newGroundedLinkerIt = newGroundedLinker; newGroundedLinkerIt; newGroundedLinkerIt = newGroundedLinkerIt->getNext()) {
										CConcept* newGroundedCocnept = newGroundedLinkerIt->getData();
										bool newGroundedConceptNegation = newGroundedLinkerIt->isNegated();

										CPROCESSINGHASH<CConcept*,CPropagationBindingDescriptor*>::const_iterator it = groundedConPropBindDesHash->constFind(newGroundedCocnept), itEnd = groundedConPropBindDesHash->constEnd();
										while (it != itEnd && it.key() == newGroundedCocnept) {
											CPropagationBindingDescriptor* propBindDes = it.value();
											CPropagationBinding* propBinding = propBindDes->getPropagationBinding();
											if (!newPropBindingSet->containsPropagationBinding(propBinding)) {
												STATINC(PBINDGROUNDINGCOUNT,calcAlgContext);
												CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();

												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,propBindDepTrackPoint,nullptr,calcAlgContext);
												CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
												newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);
												newPropBindingSet->addPropagationBinding(newPropBindDes,false);

												doneBindPropagations = true;
											}
											++it;
										}
										for (CPROCESSINGHASH<CVariable*,CPropagationBindingDescriptor*>::const_iterator it = additionalPropBindDesHash->constBegin(), itEnd = additionalPropBindDesHash->constEnd(); it != itEnd; ++it) {
											CPropagationBindingDescriptor* propBindDes = *it;
											CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();
											CPropagationBinding* propBinding = propBindDes->getPropagationBinding();
											if (!newPropBindingSet->containsPropagationBinding(propBinding)) {
												STATINC(PBINDGROUNDINGCOUNT,calcAlgContext);
												CDependencyTrackPoint* propBindDepTrackPoint = propBindDes->getDependencyTrackPoint();

												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,propBindDepTrackPoint,nullptr,calcAlgContext);
												CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
												newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);
												newPropBindingSet->addPropagationBinding(newPropBindDes,false);

												doneBindPropagations = true;
											}
										}


									}


									if (doneBindPropagations) {
										if (!createdBindConcept) {
											if (propagateFreshPropagationBindings(processIndi,conDes,newPropBindingSet,prevPropBindingSet,nullptr,calcAlgContext)) {
												setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
												CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
												addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
												if (!reapplyQueue->isEmpty()) {
													conSet = processIndi->getReapplyConceptLabelSet(true);
													CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
													applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
												}
											}
										}
									}


								}
							}
						}

					}
				}







				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATECYCLERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();


					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* bindingTriggerConcept = opLinker->getData();
					bool bindingTriggerConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();
					CConcept* cycleTriggerConcept = triggerLinker->getData();
					bool cycleTriggerConceptNegation = triggerLinker->isNegated();
					CConceptDescriptor* cycleTriggerConDes = nullptr;
					CDependencyTrackPoint* cycleTriggerDepTrackPoint = nullptr;



					bool testCycleBindingClosed = false;
					bool addCycleCloseConcept = false;
					if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
						bool cycleTriggersAvailable = true;
						if (conSet->getConceptDescriptor(cycleTriggerConcept,cycleTriggerConDes,cycleTriggerDepTrackPoint)) {
							if (cycleTriggerConDes->isNegated() == cycleTriggerConceptNegation) {
								return;
							}
						} else {
							cycleTriggersAvailable = false;
						}

						if (cycleTriggersAvailable) {
							addCycleCloseConcept = true;
							testCycleBindingClosed = true;
						}
					} else {
						testCycleBindingClosed = true;
					}


					CPropagationBindingDescriptor* cycleTriggerConceptNewBindingDescriptor = nullptr;
					CPropagationBindingDescriptor* cyclePropagationConceptDescriptor = nullptr;
					CPropagationBindingSet* cycleTriggerConceptBindingSet = nullptr;
					CPropagationBindingSet* cyclePropConceptBindingSet = nullptr;
					CConceptPropagationBindingSetHash* conPropBindingSetHash = nullptr;
					CPropagationBinding* cycleTriggerConceptNewBinding = nullptr;
					bool cycleBindingPropagation = false;
					if (testCycleBindingClosed) {
						conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(false);
						if (conPropBindingSetHash) {
							cycleTriggerConceptBindingSet = conPropBindingSetHash->getPropagationBindingSet(cycleTriggerConcept,false);
							if (cycleTriggerConceptBindingSet) {
								cycleTriggerConceptNewBindingDescriptor = cycleTriggerConceptBindingSet->getNewSepcialPropagationBindingDescriptor();
								cycleTriggerConceptNewBinding = cycleTriggerConceptNewBindingDescriptor->getPropagationBinding();
								cint64 bindingID = cycleTriggerConceptNewBinding->getPropagationID();

								cyclePropConceptBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
								if (cyclePropConceptBindingSet) {
									cyclePropagationConceptDescriptor = cyclePropConceptBindingSet->getPropagationBindingDescriptor(cycleTriggerConceptNewBinding);
									if (cyclePropagationConceptDescriptor) {
										cycleBindingPropagation = true;
									}
								}
							}
						}
					}


					bool propagations = false;
					if (cycleBindingPropagation) {
						STATINC(PBINDRULECYCLEAPPLICATIONCOUNT,calcAlgContext);

						if (addCycleCloseConcept) {
							conSet = processIndi->getReapplyConceptLabelSet(true);
							CBINDPROPAGATECYCLEDependencyNode* cycleDepNode = createBINDPROPAGATECYCLEDependency(bindingDepTrackPoint,processIndi,conDes,cyclePropagationConceptDescriptor->getDependencyTrackPoint(),cycleTriggerConceptNewBindingDescriptor->getDependencyTrackPoint(),calcAlgContext);

							bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,bindingDepTrackPoint,true,false,calcAlgContext);
						}

						// propagate bindings
						CPropagationBindingMap* cyclePropConceptBindingMap = cyclePropConceptBindingSet->getPropagationBindingMap();
						CPropagationBindingMap* cycleTriggerConceptBindingMap = cycleTriggerConceptBindingSet->getPropagationBindingMap();

						CPropagationBindingMap::iterator itCycle = cyclePropConceptBindingMap->begin(), itCycleEnd = cyclePropConceptBindingMap->end();
						CPropagationBindingMap::iterator itTrigger = cycleTriggerConceptBindingMap->begin(), itTriggerEnd = cycleTriggerConceptBindingMap->end();

						CPropagationBindingSet* newPropBindSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,false);
						CPropagationBindingMap* newPropBindMap = nullptr;
						CPropagationBindingDescriptor* newPropBindDesLinker = nullptr;
						if (newPropBindSet) {
							newPropBindMap = newPropBindSet->getPropagationBindingMap();
						}

						while (itCycle != itCycleEnd) {
							cint64 cycleID = itCycle.key();
							cint64 triggerID = -1;
							if (itTrigger != itTriggerEnd) {
								triggerID = itTrigger.key();
							}
							if (triggerID != -1 && triggerID < cycleID) {
								++itTrigger;
							} else if (triggerID == cycleID) {

								if (!newPropBindSet || !newPropBindSet->containsPropagationBinding(cycleID)) {
									STATINC(PBINDCYCLEPROPAGATECOUNT,calcAlgContext);
									if (!newPropBindSet) {
										newPropBindSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);
										newPropBindMap = newPropBindSet->getPropagationBindingMap();
										newPropBindSet->setConceptDescriptor(bindingConDes);
									}

									CPropagationBindingMapData& cyclePropBindMapData = itCycle.value();
									CPropagationBindingDescriptor* cyclePropBindDes = cyclePropBindMapData.getPropagationBindingDescriptor();

									CPropagationBindingMapData& triggerPropBindMapData = itTrigger.value();
									CPropagationBindingDescriptor* triggerPropBindDes = triggerPropBindMapData.getPropagationBindingDescriptor();

									CPROPAGATECONNECTIONDependencyNode* connDep1 = createPROPAGATECONNECTIONDependency(nullptr,cycleTriggerConceptBindingSet->getConceptDescriptor(),triggerPropBindDes->getDependencyTrackPoint(),calcAlgContext);
									CPROPAGATECONNECTIONDependencyNode* connDep2 = createPROPAGATECONNECTIONDependency(nullptr,conDes,cyclePropagationConceptDescriptor->getDependencyTrackPoint(),calcAlgContext);
									CDependency* connDep = connDep1->setNext(connDep2);

									CDependencyTrackPoint* newDepTrackPoint = nullptr;
									CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,cyclePropBindDes->getDependencyTrackPoint(),connDep,calcAlgContext);
									CPropagationBinding* propBinding = cyclePropBindDes->getPropagationBinding();
									CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
									newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);

									CPropagationBindingMapData& data = (*newPropBindMap)[propBinding->getPropagationID()];
									data.setPropagationBindingDescriptor(newPropBindDes);
									CPropagationBindingReapplyConceptDescriptor* reapplyDes = data.getReapplyConceptDescriptor();
									if (reapplyDes) {
										applyReapplyQueueConcepts(processIndi,reapplyDes,calcAlgContext);
									}
									newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);

									propagations = true;
								}

								++itCycle;
								++itTrigger;

							} else {

								if (!newPropBindSet || !newPropBindSet->containsPropagationBinding(cycleID)) {

									CPropagationBindingMapData& cyclePropBindMapData = itCycle.value();
									CPropagationBindingDescriptor* cyclePropBindDes = cyclePropBindMapData.getPropagationBindingDescriptor();
									CPropagationBinding* propBinding = cyclePropBindDes->getPropagationBinding();
									CIndividualProcessNode* bindedIndiNode = propBinding->getBindedIndividual();
									CConceptDescriptor* bindedConDes = propBinding->getBindedConceptDescriptor();

									bindedIndiNode = getUpToDateIndividual(bindedIndiNode,calcAlgContext);
									bindedIndiNode = getCorrectedMergedIntoIndividualNode(bindedIndiNode,calcAlgContext);

									CConceptPropagationBindingSetHash* bindedIndiConPropBindingSetHash = bindedIndiNode->getConceptPropagationBindingSetHash(false);
									if (bindedIndiConPropBindingSetHash) {
										CPropagationBindingSet* bindedIndiConPropBindingSet = bindedIndiConPropBindingSetHash->getPropagationBindingSet(bindedConDes->getConcept(),false);
										if (bindedIndiConPropBindingSet) {

											CPropagationBindingDescriptor* triggerPropBindDes = bindedIndiConPropBindingSet->getPropagationBindingDescriptor(cycleTriggerConceptNewBinding);
											if (triggerPropBindDes) {
												STATINC(PBINDCYCLEPROPAGATECOUNT,calcAlgContext);
												if (!newPropBindSet) {
													newPropBindSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);
													newPropBindMap = newPropBindSet->getPropagationBindingMap();
												}

												// do propagation
												CPROPAGATECONNECTIONDependencyNode* connDep1 = createPROPAGATECONNECTIONDependency(bindedIndiNode,cycleTriggerConceptBindingSet->getConceptDescriptor(),triggerPropBindDes->getDependencyTrackPoint(),calcAlgContext);
												CPROPAGATECONNECTIONDependencyNode* connDep2 = createPROPAGATECONNECTIONDependency(nullptr,conDes,cyclePropagationConceptDescriptor->getDependencyTrackPoint(),calcAlgContext);
												CDependency* connDep = connDep1->setNext(connDep2);

												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,cyclePropBindDes->getDependencyTrackPoint(),connDep,calcAlgContext);
												CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
												newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);

												CPropagationBindingMapData& data = (*newPropBindMap)[propBinding->getPropagationID()];
												data.setPropagationBindingDescriptor(newPropBindDes);
												CPropagationBindingReapplyConceptDescriptor* reapplyDes = data.getReapplyConceptDescriptor();
												if (reapplyDes) {
													applyReapplyQueueConcepts(processIndi,reapplyDes,calcAlgContext);
												}
												newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);
												propagations = true;
											} else {
												// install rule reapplication if variable bindings will change
												TIndividualConceptPair indiConPair(bindedIndiNode->getIndividualNodeID(),concept);
												CPropagationBindingReapplyConceptHash* reapplyHash = bindedIndiConPropBindingSet->getPropagationBindingReapplyConceptHash(false);
												if (reapplyHash) {
													if (!reapplyHash->hasPropagationBindingReapplyConceptDescriptor(indiConPair)) {
														STATINC(PBINDCYCLEREAPPLYINSTALLCOUNT,calcAlgContext);
														bindedIndiNode = getLocalizedIndividual(bindedIndiNode,false,calcAlgContext);
														bindedIndiConPropBindingSetHash = bindedIndiNode->getConceptPropagationBindingSetHash(true);
														bindedIndiConPropBindingSet = bindedIndiConPropBindingSetHash->getPropagationBindingSet(bindedConDes->getConcept(),true);

														CPropagationBindingReapplyConceptDescriptor* propBindReapplyConDes = CObjectAllocator<CPropagationBindingReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
														propBindReapplyConDes->initReapllyDescriptor(processIndi,cycleTriggerConceptNewBinding,conDes,depTrackPoint);

														bindedIndiConPropBindingSet->addPropagationBindingReapplyConceptDescriptor(propBindReapplyConDes);
													}
												}
											}
										}
									}
								}
								++itCycle;

							}
						}
						if (newPropBindSet && newPropBindDesLinker) {
							newPropBindSet->addPropagationBindingDescriptorLinker(newPropBindDesLinker);
						}


					}


					if (propagations && !addCycleCloseConcept) {
						setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
						CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
						addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
						if (!reapplyQueue->isEmpty()) {
							conSet = processIndi->getReapplyConceptLabelSet(true);
							CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
							applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
						}
					}



					if (!isConceptInReapplyQueue(conDes,cycleTriggerConcept,!cycleTriggerConceptNegation,processIndi,calcAlgContext)) {
						addConceptToReapplyQueue(conDes,cycleTriggerConcept,!cycleTriggerConceptNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
					}

				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::propagatePropagationBindingsToSuccessor(CIndividualProcessNode* processIndi, CIndividualProcessNode*& succIndi, CSortedNegLinker<CConcept*>* conceptOpLinker, bool negate, CConceptDescriptor* conDes, CIndividualLinkEdge* restLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();


					succIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
					CReapplyConceptLabelSet* conSet = succIndi->getReapplyConceptLabelSet(false);

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					bool continuePropagation = false;

					for (CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker; conceptOpLinkerIt; conceptOpLinkerIt = conceptOpLinkerIt->getNext()) {
						CConcept* opConcept = conceptOpLinkerIt->getData();
						bool opConNeg = conceptOpLinkerIt->isNegated() ^ negate;

						CConceptDescriptor* bindingConDes = nullptr;
						CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
						CCondensedReapplyQueue* reapplyQueue = nullptr;
						if (!conSet->getConceptDescriptorAndReapplyQueue(opConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {


							if (!nextDepTrackPoint) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CBINDPROPAGATEALLDependencyNode* bindDepNode = createBINDPROPAGATEALLDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,restLink->getDependencyTrackPoint(),calcAlgContext);
							}
							bindingConDes = addConceptToIndividualReturnConceptDescriptor(opConcept,opConNeg,succIndi,nextDepTrackPoint,false,false,calcAlgContext);

							CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							CConceptPropagationBindingSetHash* succConPropBindingSetHash = succIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* propBindingSet = succConPropBindingSetHash->getPropagationBindingSet(opConcept,true);
							propBindingSet->setConceptDescriptor(bindingConDes);

							propagateInitialPropagationBindingsToSuccessor(processIndi,succIndi,bindingConDes,propBindingSet,prevPropBindingSet,restLink,calcAlgContext);
							continuePropagation = true;
						} else {

							CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							CConceptPropagationBindingSetHash* succConPropBindingSetHash = succIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* propBindingSet = succConPropBindingSetHash->getPropagationBindingSet(opConcept,true);

							if (propagateFreshPropagationBindingsToSuccessor(processIndi,succIndi,conDes,propBindingSet,prevPropBindingSet,restLink,calcAlgContext)) {
								setIndividualNodeConceptLabelSetModified(succIndi,calcAlgContext);
								CConceptProcessingQueue* conProQueue = succIndi->getConceptProcessingQueue(true);;
								addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,succIndi,true,calcAlgContext);
								if (!reapplyQueue->isEmpty()) {
									conSet = succIndi->getReapplyConceptLabelSet(true);
									CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
									applyReapplyQueueConcepts(succIndi,&reapplyQueueIt,calcAlgContext);
								}
								continuePropagation = true;
							}
						}
					}

					if (continuePropagation) {
						addIndividualToProcessingQueue(succIndi,calcAlgContext);
					}
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateInitialPropagationBindingsToSuccessor(CIndividualProcessNode*& processIndi, CIndividualProcessNode* succIndi, CConceptDescriptor* conDes, CPropagationBindingSet* newPropBindingSet, CPropagationBindingSet* prevPropBindingSet, CIndividualLinkEdge* restLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					CPropagationBindingDescriptor* newPropBindDesLinker = nullptr;
					if (prevPropBindingSet) {
						propagations |= newPropBindingSet->adoptPropagateAllFlag(prevPropBindingSet);

						newPropBindingSet->copyPropagationBindings(prevPropBindingSet->getPropagationBindingMap());
						CPropagationBindingMap* propBindMap = newPropBindingSet->getPropagationBindingMap();
						for (CPropagationBindingMap::iterator it = propBindMap->begin(), itEnd = propBindMap->end(); it != itEnd; ++it) {
							STATINC(PBINDPROPAGATEDCOUNT,calcAlgContext);
							STATINC(PBINDPROPAGATEDINITIALCOUNT,calcAlgContext);
							CPropagationBindingMapData& propBindMapData = it.value();
							propBindMapData.clearReapplyConceptDescriptor();
							CPropagationBindingDescriptor* prevPropBindDes = propBindMapData.getPropagationBindingDescriptor();
							CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
							CDependencyTrackPoint* newDepTrackPoint = nullptr;
							CPROPAGATEBINDINGSSUCCESSORDependencyNode* bindDepNode = createPROPAGATEBINDINGSSUCCESSORDependency(newDepTrackPoint,processIndi,conDes,prevPropBindDes->getDependencyTrackPoint(),restLink->getDependencyTrackPoint(),calcAlgContext);
							newPropBindDes->initPropagationBindingDescriptor(prevPropBindDes->getPropagationBinding(),newDepTrackPoint);
							propBindMapData.setPropagationBindingDescriptor(newPropBindDes);
							newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);
							propagations = true;
						}
						if (newPropBindDesLinker) {
							newPropBindingSet->addPropagationBindingDescriptorLinker(newPropBindDesLinker);
						}
					}
					return propagations;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateFreshPropagationBindingsToSuccessor(CIndividualProcessNode*& processIndi, CIndividualProcessNode* succIndi, CConceptDescriptor* conDes, CPropagationBindingSet* newPropBindingSet, CPropagationBindingSet* prevPropBindingSet, CIndividualLinkEdge* restLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					if (prevPropBindingSet) {
						propagations |= newPropBindingSet->adoptPropagateAllFlag(prevPropBindingSet);

						CPropagationBindingMap* prevPropBindMap = prevPropBindingSet->getPropagationBindingMap();
						CPropagationBindingMap* newPropBindMap = newPropBindingSet->getPropagationBindingMap();

						CPropagationBindingMap::iterator itNew = newPropBindMap->begin();
						CPropagationBindingMap::const_iterator itPrev = prevPropBindMap->constBegin(), itPrevEnd = prevPropBindMap->constEnd();
						
						CPropagationBindingDescriptor* newPropBindDesLinker = nullptr;

						while (itPrev != itPrevEnd) {
							cint64 prevPropID = itPrev.key();
							bool doPropagation = false;
							bool updateExisting = false;
							if (itNew == newPropBindMap->end()) {
								doPropagation = true;
							} else {
								cint64 newPropID = itNew.key();
								if (newPropID < prevPropID) {
									++itNew;
								} else if (newPropID == prevPropID) {
									if (!itNew.value().hasPropagationBindingDescriptor()) {
										doPropagation = true;
										updateExisting = true;
									} else {
										++itNew;
										++itPrev;
									}
								} else {
									doPropagation = true;
								}
							}
							if (doPropagation) {
								STATINC(PBINDPROPAGATEDCOUNT,calcAlgContext);
								STATINC(PBINDPROPAGATEDFRESHCOUNT,calcAlgContext);
								const CPropagationBindingMapData& prevPropBindMapData = itPrev.value();
								CPropagationBindingDescriptor* prevPropBindDes = prevPropBindMapData.getPropagationBindingDescriptor();

								CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);

								CDependencyTrackPoint* newDepTrackPoint = nullptr;
								CPROPAGATEBINDINGSSUCCESSORDependencyNode* bindDepNode = createPROPAGATEBINDINGSSUCCESSORDependency(newDepTrackPoint,processIndi,conDes,prevPropBindDes->getDependencyTrackPoint(),restLink->getDependencyTrackPoint(),calcAlgContext);
								CPropagationBinding* propBinding = prevPropBindDes->getPropagationBinding();
								newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);

								if (updateExisting) {
									CPropagationBindingMapData& data = (*newPropBindMap)[propBinding->getPropagationID()];
									data.setPropagationBindingDescriptor(newPropBindDes);
									CPropagationBindingReapplyConceptDescriptor* reapplyDes = data.getReapplyConceptDescriptor();
									if (reapplyDes) {
										applyReapplyQueueConcepts(succIndi,reapplyDes,calcAlgContext);
									}
								} else {
									itNew = newPropBindMap->insert(propBinding->getPropagationID(),CPropagationBindingMapData(newPropBindDes));
								}
								newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);
								propagations = true;
							}
						}
						if (newPropBindDesLinker) {
							newPropBindingSet->addPropagationBindingDescriptorLinker(newPropBindDesLinker);
						}
					}
					return propagations;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();

					STATINC(PBINDRULEALLAPPLICATIONCOUNT,calcAlgContext);

					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					if (restLink) {
						CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,restLink,calcAlgContext);

						propagatePropagationBindingsToSuccessor(processIndi,succIndi,opLinker,negate,conDes,restLink,calcAlgContext);
						
					} else {
						CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
						if (roleSuccHash) {
							CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
							while (roleSuccIt.hasNext()) {
								CIndividualLinkEdge* link = roleSuccIt.next(true);
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);

								propagatePropagationBindingsToSuccessor(processIndi,succIndi,opLinker,negate,conDes,link,calcAlgContext);
							}
						}
					}
					if (!conProDes->isConceptReapplied()) {
						if (!isConceptInReapplyQueue(conDes,role,processIndi,calcAlgContext)) {
							addConceptToReapplyQueue(conDes,role,processIndi,true,depTrackPoint,calcAlgContext);
						}
					}
				}






				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					STATINC(PBINDRULEIMPLICATIONAPPLICATIONCOUNT,calcAlgContext);

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					CConcept* bindingTriggerConcept = opLinker->getData();
					bool bindingTriggerConceptNegation = opLinker->isNegated();
					CSortedNegLinker<CConcept*>* triggerLinker = opLinker->getNext();

					if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {

						// search next not existing trigger
						bool allTriggersAvailable = true;
						conSet = processIndi->getReapplyConceptLabelSet(true);
						CSortedNegLinker<CConcept*>* triggerLinkerIt = nullptr;
						for (triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
								if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
									return;
								}
							} else {
								allTriggersAvailable = false;
								break;
							}
						}

						if (!allTriggersAvailable) {
							// install to trigger
							CSortedNegLinker<CConcept*>* nextTrigger = triggerLinkerIt;
							CConcept* triggerConcept = nextTrigger->getData();
							bool triggerNegation = !nextTrigger->isNegated();
							if (!isConceptInReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,calcAlgContext)) {
								addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,(CProcessingRestrictionSpecification*)nullptr,depTrackPoint,calcAlgContext);
							}
						} else {
							CDependency* triggerDeps = nullptr;
							for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
								CConcept* triggerConcept = triggerLinkerIt->getData();
								CConceptDescriptor* triggerConDes = nullptr;
								CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
								conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
								CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
								connDep->setNext(triggerDeps);
								triggerDeps = connDep;
							}

							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CBINDPROPAGATEIMPLICATIONDependencyNode* implDepNode = createBINDPROPAGATEIMPLICATIONDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,triggerDeps,calcAlgContext);

							bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,true,false,calcAlgContext);

							CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);
							propBindingSet->setConceptDescriptor(bindingConDes);

							propagateInitialPropagationBindings(processIndi,bindingConDes,propBindingSet,prevPropBindingSet,triggerDeps,calcAlgContext);

						}
					} else {
						CDependency* triggerDeps = nullptr;
						for (CSortedNegLinker<CConcept*>* triggerLinkerIt = triggerLinker; triggerLinkerIt; triggerLinkerIt = triggerLinkerIt->getNext()) {
							CConcept* triggerConcept = triggerLinkerIt->getData();
							CConceptDescriptor* triggerConDes = nullptr;
							CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
							conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint);
							CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
							connDep->setNext(triggerDeps);
							triggerDeps = connDep;
						}

						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
						CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);

						if (propagateFreshPropagationBindings(processIndi,conDes,propBindingSet,prevPropBindingSet,triggerDeps,calcAlgContext)) {
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
							addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
							if (!reapplyQueue->isEmpty()) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
								applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
							}
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagatePropagationBindings(processIndi,conProDes,negate,false,calcAlgContext);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDPROPAGATEANDFLAGALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					++mStatBackPropActivationCount;
					propagatePropagationBindings(processIndi,conProDes,negate,true,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagatePropagationBindings(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, bool propagateAllFlag, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();

					STATINC(PBINDRULEANDAPPLICATIONCOUNT,calcAlgContext);

					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CDependencyTrackPoint* nextDepTrackPoint = nullptr;

					for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
						CConcept* bindingTriggerConcept = opConLinkerIt->getData();
						bool bindingTriggerConceptNegation = opConLinkerIt->isNegated()^conceptNegation;

						CConceptDescriptor* bindingConDes = nullptr;
						CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
						CCondensedReapplyQueue* reapplyQueue = nullptr;

						if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
							if (!nextDepTrackPoint) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CBINDPROPAGATEANDDependencyNode* bindDepNode = createBINDPROPAGATEANDDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);
							}
							bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);

							CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);
							propBindingSet->setConceptDescriptor(bindingConDes);

							if (propagateAllFlag) {
								propBindingSet->setPropagateAllFlag(true);
							}

							propagateInitialPropagationBindings(processIndi,bindingConDes,propBindingSet,prevPropBindingSet,nullptr,calcAlgContext);
						} else {

							CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
							CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
							CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);

							if (propagateFreshPropagationBindings(processIndi,conDes,propBindingSet,prevPropBindingSet,nullptr,calcAlgContext) || propagateAllFlag && !propBindingSet->hasPropagateAllFlag()) {
								if (propagateAllFlag) {
									propBindingSet->setPropagateAllFlag(true);
								}
								setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
								CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
								addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
								if (!reapplyQueue->isEmpty()) {
									conSet = processIndi->getReapplyConceptLabelSet(true);
									CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
									applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
								}
							}
						}
					}
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBINDVARIABLERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CVariable* variable = concept->getVariable();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();

					CConcept* bindingTriggerConcept = opConLinker->getData();
					bool bindingTriggerConceptNegation = opConLinker->isNegated();

					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* bindingConDes = nullptr;
					CDependencyTrackPoint* bindingDepTrackPoint = nullptr;
					CCondensedReapplyQueue* reapplyQueue = nullptr;

					STATINC(PBINDRULEBINDNAPPLICATIONCOUNT,calcAlgContext);

					if (!conSet->getConceptDescriptorAndReapplyQueue(bindingTriggerConcept,bindingConDes,bindingDepTrackPoint,reapplyQueue)) {
						STATINC(PBINDVARIABLEBINDCOUNT,calcAlgContext);
						CDependencyTrackPoint* nextDepTrackPoint = nullptr;
						CBINDVARIABLEDependencyNode* bindDepNode = createBINDVARIABLEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);
						conSet = processIndi->getReapplyConceptLabelSet(true);

						bindingConDes = addConceptToIndividualReturnConceptDescriptor(bindingTriggerConcept,bindingTriggerConceptNegation,processIndi,nextDepTrackPoint,false,false,calcAlgContext);

						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
						CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);
						propBindingSet->setConceptDescriptor(bindingConDes);
						propagateInitialPropagationBindings(processIndi,bindingConDes,propBindingSet,prevPropBindingSet,nullptr,calcAlgContext);


						CPropagationBinding* propVarBinding = CObjectAllocator<CPropagationBinding>::allocateAndConstruct(taskMemMan);
						cint64 nextPropBindingID = procDataBox->getNextBindingPropagationID(true);
						propVarBinding->initPropagationBinding(nextPropBindingID,nextDepTrackPoint,processIndi,bindingConDes,variable);
						CPropagationBindingDescriptor* propBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
						propBindDes->initPropagationBindingDescriptor(propVarBinding,nextDepTrackPoint);
						propBindingSet->addPropagationBinding(propBindDes,true);

					} else {
						CConceptPropagationBindingSetHash* conPropBindingSetHash = processIndi->getConceptPropagationBindingSetHash(true);
						CPropagationBindingSet* prevPropBindingSet = conPropBindingSetHash->getPropagationBindingSet(concept,false);
						CPropagationBindingSet* propBindingSet = conPropBindingSetHash->getPropagationBindingSet(bindingTriggerConcept,true);

						bool newVarBindCreated = false;
						if (!propBindingSet->getNewSepcialPropagationBindingDescriptor()) {
							STATINC(PBINDVARIABLEBINDCOUNT,calcAlgContext);
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CBINDVARIABLEDependencyNode* bindDepNode = createBINDVARIABLEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);
							CPropagationBinding* propVarBinding = CObjectAllocator<CPropagationBinding>::allocateAndConstruct(taskMemMan);
							cint64 nextPropBindingID = procDataBox->getNextBindingPropagationID(true);
							propVarBinding->initPropagationBinding(nextPropBindingID,nextDepTrackPoint,processIndi,bindingConDes,variable);
							CPropagationBindingDescriptor* propBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
							propBindDes->initPropagationBindingDescriptor(propVarBinding,nextDepTrackPoint);
							propBindingSet->addPropagationBinding(propBindDes,true);
							newVarBindCreated = true;
						}

						if (propagateFreshPropagationBindings(processIndi,conDes,propBindingSet,prevPropBindingSet,nullptr,calcAlgContext) || newVarBindCreated) {
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);;
							addConceptPreprocessedToProcessingQueue(bindingConDes,bindingDepTrackPoint,conProQueue,processIndi,true,calcAlgContext);
							if (!reapplyQueue->isEmpty()) {
								conSet = processIndi->getReapplyConceptLabelSet(true);
								CCondensedReapplyQueueIterator reapplyQueueIt(conSet->getConceptReapplyIterator(bindingConDes));
								applyReapplyQueueConcepts(processIndi,&reapplyQueueIt,calcAlgContext);
							}
						}
					}
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateInitialPropagationBindings(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CPropagationBindingSet* newPropBindingSet, CPropagationBindingSet* prevPropBindingSet, CDependency* otherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					CPropagationBindingDescriptor* newPropBindDesLinker = nullptr;
					if (prevPropBindingSet) {
						propagations |= newPropBindingSet->adoptPropagateAllFlag(prevPropBindingSet);

						newPropBindingSet->copyPropagationBindings(prevPropBindingSet->getPropagationBindingMap());
						CPropagationBindingMap* propBindMap = newPropBindingSet->getPropagationBindingMap();
						for (CPropagationBindingMap::iterator it = propBindMap->begin(), itEnd = propBindMap->end(); it != itEnd; ++it) {
							STATINC(PBINDPROPAGATEDCOUNT,calcAlgContext);
							STATINC(PBINDPROPAGATEDINITIALCOUNT,calcAlgContext);
							CPropagationBindingMapData& propBindMapData = it.value();
							propBindMapData.clearReapplyConceptDescriptor();
							CPropagationBindingDescriptor* prevPropBindDes = propBindMapData.getPropagationBindingDescriptor();
							CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);
							CDependencyTrackPoint* newDepTrackPoint = nullptr;
							CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,prevPropBindDes->getDependencyTrackPoint(),otherDependencies,calcAlgContext);
							newPropBindDes->initPropagationBindingDescriptor(prevPropBindDes->getPropagationBinding(),newDepTrackPoint);
							propBindMapData.setPropagationBindingDescriptor(newPropBindDes);
							newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);
							propagations = true;
						}
						if (newPropBindDesLinker) {
							newPropBindingSet->addPropagationBindingDescriptorLinker(newPropBindDesLinker);
						}
					}
					return propagations;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::propagateFreshPropagationBindings(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CPropagationBindingSet* newPropBindingSet, CPropagationBindingSet* prevPropBindingSet, CDependency* otherDependencies, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool propagations = false;
					if (prevPropBindingSet) {
						propagations |= newPropBindingSet->adoptPropagateAllFlag(prevPropBindingSet);
						CPropagationBindingMap* prevPropBindMap = prevPropBindingSet->getPropagationBindingMap();
						CPropagationBindingMap* newPropBindMap = newPropBindingSet->getPropagationBindingMap();

						CPropagationBindingMap::iterator itNew = newPropBindMap->begin();
						CPropagationBindingMap::const_iterator itPrev = prevPropBindMap->constBegin(), itPrevEnd = prevPropBindMap->constEnd();

						CPropagationBindingDescriptor* newPropBindDesLinker = nullptr;

						while (itPrev != itPrevEnd) {
							cint64 prevPropID = itPrev.key();
							bool doPropagation = false;
							bool updateExisting = false;
							if (itNew == newPropBindMap->end()) {
								doPropagation = true;
							} else {
								cint64 newPropID = itNew.key();
								if (newPropID < prevPropID) {
									++itNew;
								} else if (newPropID == prevPropID) {
									if (!itNew.value().hasPropagationBindingDescriptor()) {
										doPropagation = true;
										updateExisting = true;
									} else {
										++itNew;
										++itPrev;
									}
								} else {
									doPropagation = true;
								}
							}
							if (doPropagation) {
								STATINC(PBINDPROPAGATEDCOUNT,calcAlgContext);
								STATINC(PBINDPROPAGATEDFRESHCOUNT,calcAlgContext);
								const CPropagationBindingMapData& prevPropBindMapData = itPrev.value();
								CPropagationBindingDescriptor* prevPropBindDes = prevPropBindMapData.getPropagationBindingDescriptor();

								CPropagationBindingDescriptor* newPropBindDes = CObjectAllocator<CPropagationBindingDescriptor>::allocateAndConstruct(taskMemMan);

								CDependencyTrackPoint* newDepTrackPoint = nullptr;
								CPROPAGATEBINDINGDependencyNode* bindDepNode = createPROPAGATEBINDINGDependency(newDepTrackPoint,processIndi,conDes,prevPropBindDes->getDependencyTrackPoint(),otherDependencies,calcAlgContext);
								CPropagationBinding* propBinding = prevPropBindDes->getPropagationBinding();
								newPropBindDes->initPropagationBindingDescriptor(propBinding,newDepTrackPoint);

								if (updateExisting) {
									CPropagationBindingMapData& data = (*newPropBindMap)[propBinding->getPropagationID()];
									data.setPropagationBindingDescriptor(newPropBindDes);
									CPropagationBindingReapplyConceptDescriptor* reapplyDes = data.getReapplyConceptDescriptor();
									if (reapplyDes) {
										applyReapplyQueueConcepts(processIndi,reapplyDes,calcAlgContext);
									}
								} else {
									itNew = newPropBindMap->insert(propBinding->getPropagationID(),CPropagationBindingMapData(newPropBindDes));
								}
								newPropBindDesLinker = newPropBindDes->append(newPropBindDesLinker);
								propagations = true;
							}
						}
						if (newPropBindDesLinker) {
							newPropBindingSet->addPropagationBindingDescriptorLinker(newPropBindDesLinker);
						}
					}
					return propagations;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyReapplyQueueConcepts(CIndividualProcessNode*& processIndi, CPropagationBindingReapplyConceptDescriptor* reapplyDesLinker, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingRestrictionSpecification* procRest = nullptr;
					for (CPropagationBindingReapplyConceptDescriptor* reapplyDesLinkerIt = reapplyDesLinker; reapplyDesLinkerIt; reapplyDesLinkerIt = reapplyDesLinkerIt->getNext()) {
						STATINC(PBINDREAPPLICATIONCOUNT,calcAlgContext);
						CPropagationBindingReapplyConceptDescriptor* reapplyDes = reapplyDesLinkerIt;
						CConceptDescriptor* conDes = reapplyDes->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
						CIndividualProcessNode* indiNode = reapplyDes->getReapllyIndividualNode();
						CIndividualProcessNode* locIndiNode = indiNode;

						if (processIndi->getIndividualNodeID() != indiNode->getIndividualNodeID()) {
							locIndiNode = getLocalizedIndividual(indiNode,true,calcAlgContext);
						}

						CConceptProcessingQueue* conProQueue = locIndiNode->getConceptProcessingQueue(true);
						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,locIndiNode,false,nullptr,calcAlgContext);

						if (processIndi->getIndividualNodeID() != indiNode->getIndividualNodeID()) {
							addIndividualToProcessingQueue(locIndiNode,calcAlgContext);
						}
					}
				}















































































































				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATATYPERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();


					//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//QFile file(QString("debug-model.txt"));
					//if (file.open(QIODevice::WriteOnly)) {
					//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
					//	file.close();
					//}

					if (mDatatypeHandler && mConfDatatypeReasoning) {
						mDatatypeHandler->addDatatype(processIndi,concept,negate,depTrackPoint,calcAlgContext);
					}

					if (!negate || concept->getOperandCount() <= 1) {
						applyANDRule(processIndi,conProDes,negate,calcAlgContext);
					} else {
						applyORRule(processIndi,conProDes,negate,calcAlgContext);
					}
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATARESTRICTIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();


					//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//QFile file(QString("debug-model.txt"));
					//if (file.open(QIODevice::WriteOnly)) {
					//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
					//	file.close();
					//}

					if (mDatatypeHandler && mConfDatatypeReasoning) {
						mDatatypeHandler->addDataRestriction(processIndi,concept,negate,depTrackPoint,calcAlgContext);
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATALITERALRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDataLiteral* dataLiteral = concept->getDataLiteral();
					if (dataLiteral) {
						CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();


						//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						//QFile file(QString("debug-model.txt"));
						//if (file.open(QIODevice::WriteOnly)) {
						//	file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
						//	file.close();
						//}

						if (mDatatypeHandler && mConfDatatypeReasoning) {
							mDatatypeHandler->addDataLiteral(processIndi,dataLiteral,negate,depTrackPoint,calcAlgContext);
						}
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATALITERALIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDataLiteral* dataLiteral = concept->getDataLiteral();
					if (dataLiteral) {
						CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
						CConcept* triggerConcept = concept->getOperandList()->getData();
						CConceptDescriptor* triggeredConcepts = nullptr;
						if (mDatatypeHandler && mConfDatatypeReasoning) {
							mDatatypeHandler->triggerDataLiteralConcept(processIndi, dataLiteral, negate, depTrackPoint, triggerConcept, triggeredConcepts, calcAlgContext);
							if (triggeredConcepts) {
								addtriggeredValueSpaceConcepts(processIndi, triggeredConcepts, calcAlgContext);
							}
						}
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATATYPEIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDatatype* datatype = concept->getDatatype();
					if (datatype) {
						CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
						CConcept* triggerConcept = concept->getOperandList()->getData();
						CConceptDescriptor* triggeredConcepts = nullptr;
						if (mDatatypeHandler && mConfDatatypeReasoning) {
							mDatatypeHandler->triggerDatatypeConcept(processIndi, datatype, negate, depTrackPoint, triggerConcept, triggeredConcepts, calcAlgContext);
							if (triggeredConcepts) {
								addtriggeredValueSpaceConcepts(processIndi, triggeredConcepts, calcAlgContext);
							}
						}
					}
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::applyDATARESTRICTIONIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* triggerConcept = concept->getOperandList()->getData();
					CConceptDescriptor* triggeredConcepts = nullptr;
					if (mDatatypeHandler && mConfDatatypeReasoning) {
						mDatatypeHandler->triggerDataRestrictionConcept(processIndi, concept, negate, depTrackPoint, triggerConcept, triggeredConcepts, calcAlgContext);
						if (triggeredConcepts) {
							addtriggeredValueSpaceConcepts(processIndi, triggeredConcepts, calcAlgContext);
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyBOTTOMRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					++mAppliedANDRuleCount;
					STATINC(ANDRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();

					CConcept* topConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopConcept();

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					CANDDependencyNode* andDepNode = createANDDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);

					addConceptToIndividual(topConcept,true,processIndi,nextDepTrackPoint,true,false,calcAlgContext);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					++mAppliedANDRuleCount;
					STATINC(ANDRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = negate;
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					CANDDependencyNode* andDepNode = createANDDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);

					CSortedNegLinker<CConcept*>* opConLinkerIt = concept->getOperandList();

					addConceptsToIndividual(opConLinkerIt,conceptNegation,processIndi,nextDepTrackPoint,true,false,nullptr,calcAlgContext);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isGeneratingConceptSatisfiableCachedAbsorpable(CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* ancestorIndiNode = getAncestorIndividual(processIndi,calcAlgContext);
					if (ancestorIndiNode) {
						CConcept* concept = conDes->getConcept();
						CRole* role = concept->getRole();
						CSortedNegLinker<CRole*>* superRoleIt = role->getIndirectSuperRoleList();
						while (superRoleIt) {
							bool superRoleNeg = superRoleIt->isNegated();
							if (!superRoleNeg) {
								CRole* superRole = superRoleIt->getData();
								if (processIndi->hasRoleSuccessorToIndividual(superRole,ancestorIndiNode,true)) {
									if (superRole->isFunctional()) {
										return false;
									}
									// check additional for ATMOST restriction
									CReapplyRoleSuccessorHash* reapplyRoleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
									CReapplyQueueIterator reapplyQueueIt = reapplyRoleSuccHash->getRoleReapplyIterator(superRole,false);
									while (reapplyQueueIt.hasNext()) {
										CReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt.next();
										CConceptDescriptor* reapplyConDes = reapplyConceptDes->getConceptDescriptor();
										CConcept* reapplyConcept = reapplyConDes->getConcept();
										bool reapplyConNeg = reapplyConDes->getNegation();
										cint64 opCode = reapplyConcept->getOperatorCode();
										if (opCode == CCATMOST || opCode == CCATLEAST) {
											cint64 cardinality = concept->getParameter() + 1*reapplyConNeg;
											if (cardinality <= 1) {
												return false;
											}
										}
									}
								}
							}
							superRoleIt = superRoleIt->getNext();
						}
					}
					return true;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applySOMERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();



					CIndividualSaturationProcessNode* saturationNode = getCreationSuccessorSaturationNode(processIndi, conDes, calcAlgContext);

					// check whether there is already a suitable neighbour node in the cache
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)processIndi->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && backendSyncData->getAssocitaionData()) {
						cint64 neighbourVisitLimit = 1;
						if (!saturationNode || saturationNode->isCompleted() && (saturationNode->hasNominalIntegrated() || saturationNode->getIndirectStatusFlags()->hasFlags(CIndividualSaturationProcessNodeStatusFlags::INDSATFLAGINSUFFICIENT, false))) {
							neighbourVisitLimit = 5;
						}
						bool hasAppropriateNeighbourIndividual = false;
						mBackendCacheHandler->visitNeighbourIndividualIdsForRole(backendSyncData->getAssocitaionData(), role, [&](cint64 neighbourIndividualId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic)->bool {

							if (!nondeterministic) {
								CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndividualId, false, calcAlgContext);
								if (neighbourAssData) {
									bool contained = true;
									for (CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker; conceptOpLinkerIt && contained; conceptOpLinkerIt = conceptOpLinkerIt->getNext()) {
										CConcept* opConcept = conceptOpLinkerIt->getData();
										bool opConNegation = conceptOpLinkerIt->isNegated() ^ negate;
										if (!mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighbourAssData, neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConNegation, true, calcAlgContext)) {
											contained = false;
										}
									}
									if (contained) {
										hasAppropriateNeighbourIndividual = true;
									}
								}
							}

							return neighbourVisitLimit-- > 0 && !hasAppropriateNeighbourIndividual;
						}, true, calcAlgContext);

						if (hasAppropriateNeighbourIndividual) {
							markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);
							markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessingForDisjointRoles(processIndi, role, calcAlgContext);
							return;
						}
					}

					

					if (!conceptOpLinker->hasNext())  {
						if (!conceptOpLinker->isNegated()^negate || (saturationNode && saturationNode->hasNominalIntegrated())) {
							CConcept* nominalConcept = conceptOpLinker->getData();
							if (nominalConcept->getOperatorCode() == CCNOMINAL || (saturationNode && saturationNode->hasNominalIntegrated())) {
								STATINC(VALUERULEAPPLICATIONCOUNT,calcAlgContext);
								CIndividual* indi = nominalConcept->getNominalIndividual();
								bool saturationIntegrateNominal = false;
								if (nominalConcept->getOperatorCode() != CCNOMINAL && saturationNode && saturationNode->hasNominalIntegrated()) {
									indi = saturationNode->getIntegratedNominalIndividual();
									saturationIntegrateNominal = true;
								}
								markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);

								// force initialized
								CIndividualProcessNode* locNominalIndi = getLocalizedForcedBackendInitializedNominalIndividualNode(indi->getIndividualID(), calcAlgContext);
								markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(locNominalIndi, calcAlgContext);
								markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessingForDisjointRoles(processIndi, role, calcAlgContext);

								CReapplyConceptLabelSet* locNominalNodeConSet = locNominalIndi->getReapplyConceptLabelSet(true);
								CConcept* nominalConcept = indi->getIndividualNominalConcept();
								CConceptDescriptor* nominalConDes = nullptr;
								CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
								if (indi->getIndividualID() != locNominalIndi->getIndividualNodeID()) {
									locNominalNodeConSet->getConceptDescriptor(nominalConcept,nominalConDes,nominalConDepTrackPoint);
								}

								if (!hasIndividualsLink(processIndi,locNominalIndi,role,true,calcAlgContext)) {
									if (processIndi->isBlockableIndividual()) {
										STATINC(INDIBLOCKABLENODEVALUECONNECTIONCOUNT, calcAlgContext);
									}

									bool hasAppropriateNominalConnection = checkBackendCachedNominalConnection(processIndi, role, indi->getIndividualID(), depTrackPoint, calcAlgContext);
									if (!hasAppropriateNominalConnection) {
										// create dependency
										CDependencyTrackPoint* nextDepTrackPoint = nullptr;
										CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, nominalConDepTrackPoint, calcAlgContext);

										if (saturationIntegrateNominal) {
											if (!locNominalIndi->getReapplyConceptLabelSet(false)->containsConcept(conceptOpLinker->getData(), conceptOpLinker->isNegated() ^ negate)) {
												addConceptsToIndividual(conceptOpLinker, negate, locNominalIndi, nextDepTrackPoint, true, true, nullptr, calcAlgContext);
											}
										}

										// create link
										createNewIndividualsLinksReapplyed(processIndi, locNominalIndi, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, true, calcAlgContext);

										//propagateIndividualNodeNominalConnectionToAncestors(processIndi,calcAlgContext);
										if (!processIndi->isNominalIndividualNode()) {
											propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi, locNominalIndi, calcAlgContext);
										}

										propagateIndividualNodeModified(locNominalIndi, calcAlgContext);

										addIndividualToProcessingQueue(locNominalIndi, calcAlgContext);
									}

								} else {
									if (saturationIntegrateNominal) {
										if (!locNominalIndi->getReapplyConceptLabelSet(false)->containsConcept(conceptOpLinker->getData(),conceptOpLinker->isNegated()^negate)) {
											CDependencyTrackPoint* nextDepTrackPoint = nullptr;
											CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,nominalConDepTrackPoint,calcAlgContext);
											addConceptsToIndividual(conceptOpLinker,negate,locNominalIndi,nextDepTrackPoint,true,true,nullptr,calcAlgContext);
										}
									}

								}
								return;
							}
						}
					} 

					STATINC(SOMERULEAPPLICATIONCOUNT,calcAlgContext);
					CIndividualProcessNode* alreadyExistSuitableSuccessor = getRoleSuccessorWithConcepts(processIndi,role,conceptOpLinker,negate,calcAlgContext);

					if (!alreadyExistSuitableSuccessor) {
						if (mConfSatExpCachedSuccAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED | CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED)) {
							if (isGeneratingConceptSatisfiableCachedAbsorpable(processIndi,conDes,calcAlgContext)) {
								STATINC(SATCACHEDABSORBEDGENERATINGCONCEPTSCOUNT,calcAlgContext);
								return addSatisfiableCachedAbsorbedGeneratingConcept(conDes,processIndi,depTrackPoint,calcAlgContext);
							}
						}

						++mAppliedSOMERuleCount;
						STATINC(SEPARATESUCCESSORINDINODECREATIONCOUNT,calcAlgContext);

						if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForSuccessorGeneration(conProDes,processIndi)) {
							testIndividualNodeUnsatisfiableCached(processIndi,calcAlgContext);
						}


						// generate new role successor
						CIndividualProcessNode* succIndi = tryExtendFunctionalSuccessorIndividual(processIndi,conDes,role->getIndirectSuperRoleList(),role,conceptOpLinker,negate,depTrackPoint,saturationNode,calcAlgContext);
						if (!succIndi) {
							succIndi = createSuccessorIndividual(processIndi,conDes,role->getIndirectSuperRoleList(),role,conceptOpLinker,negate,depTrackPoint,saturationNode,calcAlgContext);
							if (processIndi->isNominalIndividualNode() && processIndi->getIndividualNominalLevel() <= 0) {
								succIndi->setExtendedQueueProcessing(true);
							}
						}
						// check for backward dependencies
						if (processIndi->isIndividualAncestor(succIndi)) {
							if (mConfSatExpCachedSuccAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED | CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED)) {
								reapplySatisfiableCachedAbsorbedGeneratingConcepts(processIndi,calcAlgContext);
							}

							CXLinker<CIndividualProcessNode*>* newBackwardDepLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
							newBackwardDepLinker->initLinker(processIndi);
							succIndi->addSuccessorIndividualNodeBackwardDependencyLinker(newBackwardDepLinker);
							processIndi->setBackwardDependencyToAncestorIndividualNode(true);
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
								//propagateIndividualNodeNominalConnectionToAncestors(processIndi,calcAlgContext);
								if (!processIndi->isNominalIndividualNode()) {
									propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi,succIndi,calcAlgContext);
								}
							}
						}

						addIndividualToProcessingQueue(succIndi,calcAlgContext);

						if (mConfAnywhereBlockingSomeInitializationHashing) {
							addIndividualNodeCandidateForConcept(succIndi,conceptOpLinker,negate,calcAlgContext);
						}
					} else {
						// check for backward dependencies
						if (processIndi->isIndividualAncestor(alreadyExistSuitableSuccessor)) {
							CIndividualProcessNode* locAncestorIndiNode = getLocalizedIndividual(alreadyExistSuitableSuccessor,false,calcAlgContext);
							CXLinker<CIndividualProcessNode*>* newBackwardDepLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
							newBackwardDepLinker->initLinker(processIndi);
							locAncestorIndiNode->addSuccessorIndividualNodeBackwardDependencyLinker(newBackwardDepLinker);
							processIndi->setBackwardDependencyToAncestorIndividualNode(true);
							if (locAncestorIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
								//propagateIndividualNodeNominalConnectionToAncestors(processIndi,calcAlgContext);
								if (!processIndi->isNominalIndividualNode()) {
									propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi,locAncestorIndiNode,calcAlgContext);
								}
							}
						}
					}
				}







				void CCalculationTableauCompletionTaskHandleAlgorithm::addReverseRoleAssertion(CIndividualProcessNode*& processIndi, CReverseRoleAssertionLinker* reverseRoleAssertionLinker, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(REVERSEROLEASSERTIONCOUNT,calcAlgContext);
					CRole* role = reverseRoleAssertionLinker->getRole();
					CIndividual* indi = reverseRoleAssertionLinker->getIndividual();
					markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);

					if (indi) {
						if (!mOptIncrementalCompatibleExpansion || isNominalIndividualNodeAvailable(-indi->getIndividualID(),calcAlgContext)) {
							CIndividualProcessNode* nominalIndi = getCorrectedNominalIndividualNode(-indi->getIndividualID(),calcAlgContext);
							if (nominalIndi && (!nominalIndi->hasRoleAssertionsInitialized() || processIndi->getRoleAssertionCreationID() > nominalIndi->getRoleAssertionCreationID())) {

								CIndividualProcessNode* locNominalIndi = getLocalizedForcedBackendInitializedNominalIndividualNode(nominalIndi, calcAlgContext);
								markIndividualNodeBackendNonConceptSetRelatedProcessing(locNominalIndi, calcAlgContext);

								CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
								if (-indi->getIndividualID() != locNominalIndi->getIndividualNodeID()) {
									nominalConDepTrackPoint = locNominalIndi->getIndividualMergingHash(false)->value(indi->getIndividualID()).getDependencyTrackPoint();
								}


								if (!hasIndividualsLink(locNominalIndi,processIndi,role,true,calcAlgContext)) {
									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CROLEASSERTIONDependencyNode* roleAssDepNode = createROLEASSERTIONDependency(nextDepTrackPoint, processIndi,depTrackPoint,nominalConDepTrackPoint, role, indi, calcAlgContext);

									// create link
									createNewIndividualsLinksReapplyed(locNominalIndi,processIndi,role->getIndirectSuperRoleList(),role,nextDepTrackPoint,true,calcAlgContext);

									propagateIndividualNodeModified(locNominalIndi,calcAlgContext);
									addIndividualToProcessingQueue(locNominalIndi,calcAlgContext);
								}
							}
						} else if (mOptIncrementalCompatibleExpansion) {

							for (CSortedNegLinker<CRole*>* roleLinkerIt = role->getIndirectSuperRoleList(); roleLinkerIt; roleLinkerIt = roleLinkerIt->getNext()) {
								CRole* role = roleLinkerIt->getData();
								bool invRole = roleLinkerIt->isNegated();
								CSortedNegLinker<CConcept*>* domainConLinkerIt = role->getDomainRangeConceptList(!invRole);
								if (domainConLinkerIt) {
									addConceptsToIndividual(domainConLinkerIt,false,processIndi,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
							}

						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::addDataAssertion(CIndividualProcessNode*& processIndi, CDataAssertionLinker* dataAssertionLinker, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CRole* role = dataAssertionLinker->getRole();
					CDataLiteral* dataLiteral = dataAssertionLinker->getDataLiteral();
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					CDATAASSERTIONDependencyNode* dataAssDepNode = createDATAASSERTIONDependency(nextDepTrackPoint, processIndi, depTrackPoint, calcAlgContext);

					// generate new data role successor
					CIndividualProcessNode* succIndi = createNewIndividual(nextDepTrackPoint, true, calcAlgContext);

					CIndividualLinkEdge* ancLink = createNewIndividualsLinksReapplyed(processIndi, succIndi, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, false, calcAlgContext);
					succIndi->setAncestorLink(ancLink);
					succIndi->setIndividualAncestorDepth(processIndi->getIndividualAncestorDepth() + 1);

					CProcessAssertedDataLiteralLinker* additionalDataLitLinker = CObjectAllocator< CProcessAssertedDataLiteralLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
					additionalDataLitLinker->initProcessDataLiteralLinker(dataLiteral, depTrackPoint);
					succIndi->addAssertedDataLiteralLinker(additionalDataLitLinker);
					succIndi->setLastAssertedDataLiteralLinker(succIndi->getAssertedDataLiteralLinker());

					if (processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
					}
					if (processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);
					}
					if (processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
					}

					if (mDatatypeHandler && mConfDatatypeReasoning) {
						mDatatypeHandler->addDataLiteral(succIndi, dataLiteral, false, nextDepTrackPoint, calcAlgContext);
						CDatatype* datatype = dataLiteral->getDatatype();
						if (datatype && datatype->getDatatypeConcept()) {
							addConceptToIndividual(datatype->getDatatypeConcept(), false, succIndi, nextDepTrackPoint, true, false, calcAlgContext);
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addRoleAssertion(CIndividualProcessNode*& processIndi, CRoleAssertionLinker* roleAssertionLinker, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(ROLEASSERTIONCOUNT,calcAlgContext);
					CRole* role = roleAssertionLinker->getRole();
					CIndividual* indi = roleAssertionLinker->getIndividual();
					markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);

					if (indi) {
						if (!mOptIncrementalCompatibleExpansion || isNominalIndividualNodeAvailable(-indi->getIndividualID(),calcAlgContext)) {
							CIndividualProcessNode* nominalIndi = getCorrectedNominalIndividualNode(-indi->getIndividualID(),calcAlgContext);
							if (nominalIndi && (!nominalIndi->hasReverseRoleAssertionsInitialized() || processIndi->getRoleAssertionCreationID() > nominalIndi->getRoleAssertionCreationID())) {


								CIndividualProcessNode* locNominalIndi = getLocalizedForcedBackendInitializedNominalIndividualNode(nominalIndi, calcAlgContext);
								markIndividualNodeBackendNonConceptSetRelatedProcessing(locNominalIndi, calcAlgContext);

								CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
								if (-indi->getIndividualID() != locNominalIndi->getIndividualNodeID() && locNominalIndi->getIndividualMergingHash(false)) {
									nominalConDepTrackPoint = locNominalIndi->getIndividualMergingHash(false)->value(indi->getIndividualID()).getDependencyTrackPoint();
								}

								if (!hasIndividualsLink(processIndi,locNominalIndi,role,true,calcAlgContext)) {
									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CROLEASSERTIONDependencyNode* roleAssDepNode = createROLEASSERTIONDependency(nextDepTrackPoint,processIndi,depTrackPoint,nominalConDepTrackPoint, role, processIndi->getNominalIndividual(), calcAlgContext);

									// create link
									createNewIndividualsLinksReapplyed(processIndi,locNominalIndi,role->getIndirectSuperRoleList(),role,nextDepTrackPoint,true,calcAlgContext);

									propagateIndividualNodeModified(locNominalIndi,calcAlgContext);
									addIndividualToProcessingQueue(locNominalIndi,calcAlgContext);
								}
							}
						} else if (mOptIncrementalCompatibleExpansion) {

							for (CSortedNegLinker<CRole*>* roleLinkerIt = role->getIndirectSuperRoleList(); roleLinkerIt; roleLinkerIt = roleLinkerIt->getNext()) {
								CRole* role = roleLinkerIt->getData();
								bool invRole = roleLinkerIt->isNegated();
								CSortedNegLinker<CConcept*>* domainConLinkerIt = role->getDomainRangeConceptList(invRole);
								if (domainConLinkerIt) {
									addConceptsToIndividual(domainConLinkerIt,false,processIndi,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
							}

						}
					}
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::checkBackendCachedNominalConnection(CIndividualProcessNode*& processIndi, CRole* role, cint64 nominalId, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool hasAppropriateNominalConnection = false;
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)processIndi->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && backendSyncData->getAssocitaionData()) {

						CBackendRepresentativeMemoryCacheIndividualAssociationData* assData = backendSyncData->getAssocitaionData();
						CBackendRepresentativeMemoryCacheIndividualAssociationData* nomAssData = nullptr;
						CBackendRepresentativeMemoryLabelCacheItem* nomConLabelItem = nullptr;
						if (assData) {
							CBackendRepresentativeMemoryCacheIndividualNeighbourRoleSetHash* neighbourRoleSetHash = assData->getNeighbourRoleSetHash();
							if (neighbourRoleSetHash) {
								CBackendRepresentativeMemoryLabelCacheItem* roleSetLabelItem = neighbourRoleSetHash->getNeighbourRoleSetLabel(nominalId);
								if (roleSetLabelItem) {

									if (mBackendCacheHandler->hasRoleInAssociatedNeigbourRoleSetLabel(assData, roleSetLabelItem, role, false, false)) {
										hasAppropriateNominalConnection = assData->isCompletelyHandled() && assData->isCompletelyPropagated();


										for (CSortedNegLinker<CRole*>* superRoleIt = role->getIndirectSuperRoleList(); superRoleIt && hasAppropriateNominalConnection; superRoleIt = superRoleIt->getNext()) {
											CRole* superRole = superRoleIt->getData();
											bool superRoleInversion = superRoleIt->isNegated();
											CSortedNegLinker<CConcept*>* rangeConLinker = superRole->getDomainRangeConceptList(!superRoleInversion);
											for (CSortedNegLinker<CConcept*>* conLinkerIt = rangeConLinker; conLinkerIt && hasAppropriateNominalConnection; conLinkerIt = conLinkerIt->getNext()) {
												CConcept* con = conLinkerIt->getData();
												bool conNeg = conLinkerIt->isNegated();
												if (!nomAssData) {
													nomAssData = mBackendCacheHandler->getIndividualAssociationData(nominalId, false, calcAlgContext);
													if (nomAssData) {
														nomConLabelItem = nomAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
													}
												}
												if (!mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(nomAssData, nomConLabelItem, con, conNeg, true, calcAlgContext)) {
													hasAppropriateNominalConnection = false;
												}
											}

											CSortedNegLinker<CConcept*>* domainConLinker = superRole->getDomainRangeConceptList(superRoleInversion);
											for (CSortedNegLinker<CConcept*>* conLinkerIt = domainConLinker; conLinkerIt && hasAppropriateNominalConnection; conLinkerIt = conLinkerIt->getNext()) {
												CConcept* con = conLinkerIt->getData();
												bool conNeg = conLinkerIt->isNegated();
												if (!processIndi->getReapplyConceptLabelSet(false)->hasConcept(con, conNeg)) {
													addConceptToIndividual(con, conNeg, processIndi, depTrackPoint, false, false, calcAlgContext);
												}												
											}
										}

										if (!hasAppropriateNominalConnection) {
											expandIndividualNeighbourNodeFromBackendCache(processIndi, nominalId, calcAlgContext);
										}

									} else {
										// build link in completion graph since it could have a clash/interaction with the new connection
										// (it is also necessary for the backend handler to correctly update the instantiated roles to this individual)
										expandIndividualNeighbourNodeFromBackendCache(processIndi, nominalId, calcAlgContext);
									}
								}
							}
						}
					}
					return hasAppropriateNominalConnection;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyVALUERule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(VALUERULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CIndividual* indi = concept->getNominalIndividual();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();



					if (indi) {
						// check whether there is already a suitable neighbour node in the cache
						bool hasAppropriateNominalConnection = checkBackendCachedNominalConnection(processIndi, role, indi->getIndividualID(), depTrackPoint, calcAlgContext);

						if (hasAppropriateNominalConnection && !negate) {
							markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);
							markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessingForDisjointRoles(processIndi, role, calcAlgContext);
							return;
						}
					}




					if (indi) {
						markIndividualNodeBackendNonConceptSetRelatedProcessing(processIndi, calcAlgContext);

						// force initialized
						CIndividualProcessNode* locNominalIndi = getLocalizedForcedBackendInitializedNominalIndividualNode(indi->getIndividualID(), calcAlgContext);
						markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(locNominalIndi, calcAlgContext);
						markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessingForDisjointRoles(processIndi, role, calcAlgContext);


						CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
						if (-indi->getIndividualID() != locNominalIndi->getIndividualNodeID() && locNominalIndi->getIndividualMergingHash(false)) {
							nominalConDepTrackPoint = locNominalIndi->getIndividualMergingHash(false)->value(indi->getIndividualID()).getDependencyTrackPoint();
						}


						if (!negate) {

							if (!hasIndividualsLink(processIndi,locNominalIndi,role,true,calcAlgContext)) {
								if (processIndi->isBlockableIndividual()) {
									STATINC(INDIBLOCKABLENODEVALUECONNECTIONCOUNT, calcAlgContext);
								}


								// create dependency
								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,nominalConDepTrackPoint,calcAlgContext);

								// create link
								createNewIndividualsLinksReapplyed(processIndi,locNominalIndi,role->getIndirectSuperRoleList(),role,nextDepTrackPoint,true,calcAlgContext);
								//propagateIndividualNodeNominalConnectionToAncestors(processIndi,calcAlgContext);
								if (!processIndi->isNominalIndividualNode()) {
									propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi,locNominalIndi,calcAlgContext);
								}

								propagateIndividualNodeModified(locNominalIndi,calcAlgContext);
								addIndividualToProcessingQueue(locNominalIndi,calcAlgContext);
							}
						} else {

							// create dependency
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CNEGVALUEDependencyNode* negValueDepNode = createNEGVALUEDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,nominalConDepTrackPoint,calcAlgContext);

							// create negation/disjoint link
							createIndividualNodeNegationLink(processIndi,locNominalIndi,role,nextDepTrackPoint,calcAlgContext);
							//propagateIndividualNodeNominalConnectionToAncestors(processIndi,calcAlgContext);
							if (!processIndi->isNominalIndividualNode()) {
								propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi,locNominalIndi,calcAlgContext);
							}

							addIndividualToProcessingQueue(locNominalIndi,calcAlgContext);
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyFUNCTIONALRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(FUNCTIONALRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();
					bool reapplied = conProDes->isConceptReapplied();

					CRoleSuccessorLinkIterator baseRoleSuccIt(processIndi->getRoleSuccessorLinkIterator(role));
					CRoleSuccessorLinkIterator roleSuccIt(baseRoleSuccIt);
					CIndividualProcessNode* firstSuccNode = nullptr;
					CIndividualLinkEdge* firstLink = nullptr;
					CDependencyTrackPoint* nnRequireDepTrackPoint = nullptr;
					bool nominalNode = processIndi->isNominalIndividualNode();
					bool requiresNNRule = false;
					bool hasAlreadyMergingNominal = false;
					if (nominalNode && roleSuccIt.hasNext()) {
						// has to apply NN-rule?
						CRoleSuccessorLinkIterator checkNNRoleSuccIt(roleSuccIt);
						while (!hasAlreadyMergingNominal && checkNNRoleSuccIt.hasNext()) {
							CIndividualLinkEdge* link = checkNNRoleSuccIt.next();
							if (!requiresNNRule) {
								if (link->getCreatorIndividualID() != processIndi->getIndividualNodeID()) {
									requiresNNRule = true;
									nnRequireDepTrackPoint = link->getDependencyTrackPoint();
								}
							}
							if (!hasAlreadyMergingNominal) {
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
								if (succIndi->isNominalIndividualNode()) {
									hasAlreadyMergingNominal = true;
									firstSuccNode = succIndi;
									firstLink = link;
								}
							}
						}
					}
					if (!hasAlreadyMergingNominal) {
						if (requiresNNRule) {

							createNominalsSuccessorIndividuals(processIndi,role->getIndirectSuperRoleList(),role,conceptOpLinkerIt,false,nnRequireDepTrackPoint,1,calcAlgContext);
							CRoleSuccessorLinkIterator lastRoleSuccIt = processIndi->getRoleSuccessorHistoryLinkIterator(role,nullptr);
							if (lastRoleSuccIt.hasNext()) {
								CIndividualLinkEdge* link = lastRoleSuccIt.next();
								CIndividualProcessNode* nominalSuccIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
								firstSuccNode = nominalSuccIndi;
								firstLink = link;
							}

						} else {
							while (!firstSuccNode && roleSuccIt.hasNext()) {
								firstLink = roleSuccIt.next();
								if (roleSuccIt.hasNext()) {
									CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,firstLink,calcAlgContext);
									firstSuccNode = succIndi;
								}
							}
						}
					}
					if (firstSuccNode) {

						cint64 minIndiId = firstSuccNode->getIndividualNodeID();
						cint64 prevMinIndiId = minIndiId;
						CRoleSuccessorLinkIterator minSuccSearchRoleSuccIt = roleSuccIt;
						while (minSuccSearchRoleSuccIt.hasNext()) {
							CIndividualLinkEdge* link = minSuccSearchRoleSuccIt.next();
							CIndividualProcessNode* succIndi = link->getOppositeIndividual(processIndi);
							cint64 succIndiId = succIndi->getIndividualNodeID();
							if (minIndiId < 0 && succIndiId < 0 && succIndiId > minIndiId) {
								firstSuccNode = succIndi;
								minIndiId = succIndiId;
								firstLink = link;
							} else if (minIndiId > 0 && succIndiId < minIndiId) {
								firstSuccNode = succIndi;
								minIndiId = succIndiId;
								firstLink = link;
							}
						}
						if (minIndiId != prevMinIndiId) {
							roleSuccIt = baseRoleSuccIt;
						}

						CIndividualProcessNode* locFirstSuccNode = nullptr;
						while (roleSuccIt.hasNext() && !processIndi->hasPurgedBlockedProcessingRestrictionFlags()) {
							CIndividualLinkEdge* link = roleSuccIt.next();
							if (link != firstLink && processIndi->hasRoleSuccessorToIndividual(role, link->getOppositeIndividual(processIndi), true)) {
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
								CClashedDependencyDescriptor* clashDescriptors = nullptr;
								if (isIndividualNodesMergeable(firstSuccNode,succIndi,clashDescriptors,calcAlgContext)) {
									setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
									if (!locFirstSuccNode) {
										locFirstSuccNode = getLocalizedIndividual(firstSuccNode,link,calcAlgContext);
										firstSuccNode = locFirstSuccNode;
									}
									CIndividualProcessNode* locSuccIndiNode = getLocalizedIndividual(succIndi,false,calcAlgContext);

									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CFUNCTIONALDependencyNode* funcDepNode = createFUNCTIONALDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,firstLink->getDependencyTrackPoint(),link->getDependencyTrackPoint(),calcAlgContext);

									// merge to first successor
									locFirstSuccNode = getMergedIndividualNodes(locFirstSuccNode,locSuccIndiNode,nextDepTrackPoint,calcAlgContext);
									firstSuccNode = locFirstSuccNode;
									if (locFirstSuccNode == locSuccIndiNode) {
										firstLink = link;
									}

									roleSuccIt = processIndi->getRoleSuccessorLinkIterator(role);

									if (mConfSatExpCachedSuccAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED | CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED)) {
										if (locFirstSuccNode == getAncestorIndividual(processIndi,calcAlgContext)) {
											reapplySatisfiableCachedAbsorbedGeneratingConcepts(processIndi,calcAlgContext);
										}
									}

								} else {

									// clash
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors,processIndi,conDes,depTrackPoint,calcAlgContext);
									clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,firstSuccNode,firstLink,nullptr,calcAlgContext);
									clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,succIndi,link,nullptr,calcAlgContext);
									throw CCalculationClashProcessingException(clashDescriptors);
								}
							}
						}
					}
					if (!reapplied) {
						CDependencyTrackPoint* contDepTrackPoint = depTrackPoint;
						addConceptToReapplyQueue(conDes,role,processIndi,true,contDepTrackPoint,calcAlgContext);
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasIdenticalConceptOperands(CSortedNegLinker<CConcept*>* opConLinker1, CSortedNegLinker<CConcept*>* opConLinker2) {
					if (opConLinker1->getCount() != opConLinker2->getCount()) {
						return false;
					}
					for (CSortedNegLinker<CConcept*>* opConLinker1It = opConLinker1; opConLinker1It; opConLinker1It = opConLinker1It->getNext()) {
						CConcept* con1 = opConLinker1It->getData();
						bool neg1 = opConLinker1It->isNegated();
						bool foundOperand = false;
						for (CSortedNegLinker<CConcept*>* opConLinker2It = opConLinker2; opConLinker2It && !foundOperand; opConLinker2It = opConLinker2It->getNext()) {
							CConcept* con2 = opConLinker2It->getData();
							bool neg2 = opConLinker2It->isNegated();
							if (con1 == con2 && neg1 == neg2) {
								foundOperand = true;
							}
						}
						if (!foundOperand) {
							return false;
						}
					}
					for (CSortedNegLinker<CConcept*>* opConLinker2It = opConLinker2; opConLinker2It; opConLinker2It = opConLinker2It->getNext()) {
						CConcept* con1 = opConLinker2It->getData();
						bool neg1 = opConLinker2It->isNegated();
						bool foundOperand = false;
						for (CSortedNegLinker<CConcept*>* opConLinker1It = opConLinker1; opConLinker1It && !foundOperand; opConLinker1It = opConLinker1It->getNext()) {
							CConcept* con2 = opConLinker1It->getData();
							bool neg2 = opConLinker1It->isNegated();
							if (con1 == con2 && neg1 == neg2) {
								foundOperand = true;
							}
						}
						if (!foundOperand) {
							return false;
						}
					}
					return true;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyATMOSTRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(ATMOSTRULEAPPLICATIONCOUNT,calcAlgContext);
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();
					CProcessingRestrictionSpecification* procRest = conProDes->getProcessingRestrictionSpecification();

					cint64 cardinality = concept->getParameter() - 1*negate;

					bool installReapplication = false;
					if (cardinality < 0) {
						// clash
						CClashedDependencyDescriptor* clashConDesLinker = nullptr;
						clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
						throw CCalculationClashProcessingException(clashConDesLinker);
					}
					if (cardinality == 1 && !conceptOpLinkerIt) {
						return applyFUNCTIONALRule(processIndi,conProDes,negate,calcAlgContext);
					}


					if (mConfSatExpCachedMergAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
						STATINC(SATCACHEDABSORBEDMERGINGCONCEPTSCOUNT,calcAlgContext);
						return addSatisfiableCachedAbsorbedDisjunctionConcept(conDes,processIndi,procRest,depTrackPoint,calcAlgContext);
					}

					CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest = nullptr;
					CRoleSuccessorLinkIterator roleSuccIt;
					CIndividualLinkEdge* usingLastLink = nullptr;
					cint64 linkCount = 0;
					if (!procRest) {
						if (roleSuccHash) {
							roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role,&linkCount,usingLastLink);
						}
						if (!roleSuccIt.hasNext()) {
							// no need for merging
						} else if (cardinality <= 0 && !conceptOpLinkerIt) {
							// clash
							CClashedDependencyDescriptor* clashConDesLinker = nullptr;
							clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
							CIndividualLinkEdge* link = roleSuccIt.next(false);
							clashConDesLinker = createClashedIndividualLinkDescriptor(clashConDesLinker,link,link->getDependencyTrackPoint(),calcAlgContext);
							throw CCalculationClashProcessingException(clashConDesLinker);
						}


						if (mConfAtleastAtmostFastClashCheck) {
							CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
							if (conSet) {
								CConceptDescriptor* conDesIt = conSet->getAddingSortedConceptDescriptionLinker();
								while (conDesIt) {
									CConcept* atleastConcept = conDesIt->getData();
									bool conNegated = conDesIt->isNegated();
									cint64 opCode = atleastConcept->getOperatorCode();
									if (!conNegated && (opCode == CCATLEAST) || conNegated && (opCode == CCATMOST)) {
										cint64 param = atleastConcept->getParameter();
										cint64 atleastCardinality = param + 1*conNegated;

										if (atleastCardinality > cardinality && (hasIdenticalConceptOperands(atleastConcept->getOperandList(),conceptOpLinkerIt) || !conceptOpLinkerIt)) {
											CRole* atmostRole = role;
											CRole* atleastRole = atleastConcept->getRole();


											CSortedNegLinker<CRole*>* superRoleIt = atleastRole->getIndirectSuperRoleList();
											while (superRoleIt) {
												if (!superRoleIt->isNegated()) {
													if (superRoleIt->getData() == atmostRole) {
														CClashedDependencyDescriptor* clashConDesLinker = nullptr;
														clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
														clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDesIt,conDesIt->getDependencyTrackPoint(),calcAlgContext);
														throw CCalculationClashProcessingException(clashConDesLinker);
													}
												}
												superRoleIt = superRoleIt->getNext();
											}
										}
									}
									conDesIt = conDesIt->getNext();
								}
							}
						}

						// create basis dependency
						CATMOSTDependencyNode* atMostDepNode = createATMOSTDependency(processIndi,conDes,depTrackPoint,calcAlgContext);
						CNonDeterministicDependencyTrackPoint* atMostNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(atMostDepNode,true,calcAlgContext);

						// initialize qualifying and merging
						branchingMergingProcRest = CObjectParameterizingAllocator< CBranchingMergingProcessingRestrictionSpecification,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);
						branchingMergingProcRest->initBranchingMergingProcessingRestriction();
						branchingMergingProcRest->initDependencyTracker(atMostNonDetDepTrackPoint);
						branchingMergingProcRest->initMergingDependencyNode(atMostDepNode);

						if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForMergingInitialization(conProDes,processIndi)) {
							testIndividualNodeUnsatisfiableCached(processIndi,calcAlgContext);
						}

					} else {
						CBranchingMergingProcessingRestrictionSpecification* prevBranchingMergingProcRest = (CBranchingMergingProcessingRestrictionSpecification*)procRest;

						roleSuccIt = roleSuccHash->getRoleSuccessorHistoryLinkIterator(role,prevBranchingMergingProcRest->getLastIndividualLink(),&linkCount);

						if (cardinality <= 0 && linkCount > 0 && !conceptOpLinkerIt) {
							// clash
							CClashedDependencyDescriptor* clashConDesLinker = nullptr;
							clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
							CIndividualLinkEdge* link = roleSuccIt.next(false);
							clashConDesLinker = createClashedIndividualLinkDescriptor(clashConDesLinker,link,link->getDependencyTrackPoint(),calcAlgContext);
							throw CCalculationClashProcessingException(clashConDesLinker);
						}

						CBranchingMergingProcessingRestrictionSpecification* newBranchingMergingProcRest = CObjectParameterizingAllocator< CBranchingMergingProcessingRestrictionSpecification,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);
						newBranchingMergingProcRest->initBranchingMergingProcessingRestriction(prevBranchingMergingProcRest);

						branchingMergingProcRest = newBranchingMergingProcRest;
					}

					//lastBranchingMergingProcRest = branchingMergingProcRest;


					//CIndividual* nominalIndividual = processIndi->getNominalIndividual();
					//if (nominalIndividual && cardinality == 2) {
					//	if (CIRIName::getRecentIRIName(nominalIndividual->getIndividualNameLinker()) == "http://www.cs.man.ac.uk/~stevensr/ontology/fhkb.owl#richard_john_bright_1962") {
					//		bool bug = true;
					//	}
					//}

					
					initializeMergingIndividualNodes(processIndi,conProDes,&roleSuccIt,usingLastLink,conceptOpLinkerIt,branchingMergingProcRest,calcAlgContext);
					qualifyMergingIndividualNodes(processIndi,conProDes,branchingMergingProcRest,calcAlgContext);
					if (mConfPairwiseMerging) {
						mergeMergingIndividualNodesPairwise(processIndi,conProDes,linkCount,cardinality,branchingMergingProcRest,calcAlgContext);
					} else {
						mergeMergingIndividualNodes(processIndi,conProDes,linkCount,cardinality,branchingMergingProcRest,calcAlgContext);
					}

					installReapplication = true;
					if (installReapplication) {
						CDependencyTrackPoint* contDepTrackPoint = depTrackPoint;
						addConceptToReapplyQueue(conDes,role,processIndi,branchingMergingProcRest,contDepTrackPoint,calcAlgContext);
					}
				}


				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugMergingQueueString(CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					QString mergingString;
					CBranchingMergingIndividualNodeCandidateLinker* mergCandLinker = branchingMergingProcRest->getMergingCandidateNodeLinker();
					while (mergCandLinker) {
						CIndividualProcessNode* indiNode = mergCandLinker->getMergingIndividualNodeCandidate();

						QString indiString = QString("[ %1 ] = ").arg(indiNode->getIndividualNodeID());
						QString conSetString;
						CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
						CReapplyConceptLabelSetIterator conSetIt = conSet->getConceptLabelSetIterator(false,false,false);
						while (conSetIt.hasNext()) {
							CConceptDescriptor* conDes = conSetIt.next();
							CConcept* concept = conDes->getConcept();
							cint64 conTag = conDes->getConceptTag();
							if (conTag != 1) {
								QString conString = QString("%1%2").arg((conDes->isNegated())?"-":"").arg(conTag);
								if (concept->hasClassName()) {
									conString += CIRIName::getRecentIRIName(concept->getClassNameLinker());
								}
								if (!conSetString.isEmpty()) {
									conSetString += QString(", ");
								}
								conSetString += conString;
							}
						}
						indiString += QString("{%1} \n").arg(conSetString);
						mergingString += indiString;

						mergCandLinker = mergCandLinker->getNext();
					}
					return mergingString;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::mergeMergingIndividualNodesPairwise(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, cint64 linkCount, cint64 cardinality, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();
					CDependencyTrackPoint* baseDepTrackPoint = branchingMergingProcRest->getDependencyTrackPoint();
					cint64 indiCount = processIndi->getRoleSuccessorCount(role);
					if (indiCount > cardinality) {
						CSatisfiableCalculationTask* newTaskList = nullptr;

						CMERGEDependencyNode* mergeDependencyNode = createMERGEDependency(processIndi,nullptr,baseDepTrackPoint,calcAlgContext);
						CClashedDependencyDescriptor* clashDescriptors = nullptr;

						CRoleSuccessorLinkIterator roleSuccIt1 = processIndi->getRoleSuccessorLinkIterator(role);
						while (roleSuccIt1.hasNext()) {
							CIndividualLinkEdge* link1 = roleSuccIt1.next();
							CIndividualProcessNode* succNode1 = getSuccessorIndividual(processIndi,link1,calcAlgContext);

							clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,succNode1,link1,conceptOpLinkerIt,calcAlgContext);

							CRoleSuccessorLinkIterator roleSuccIt2 = roleSuccIt1;
							while (roleSuccIt2.hasNext()) {
								CIndividualLinkEdge* link2 = roleSuccIt2.next();
								CIndividualProcessNode* succNode2 = getSuccessorIndividual(processIndi,link2,calcAlgContext);

								clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,succNode2,link2,conceptOpLinkerIt,calcAlgContext);

								if (isIndividualNodesMergeable(succNode1,succNode2,clashDescriptors,calcAlgContext)) {
									CSatisfiableCalculationTask* newTask = createMergeBranchingTask(processIndi,conProDes,succNode1,succNode2,mergeDependencyNode,branchingMergingProcRest,calcAlgContext);
									newTaskList = (CSatisfiableCalculationTask*)newTask->append(newTaskList);
								}
							}
						}

						if (mergeDependencyNode) {
							mergeDependencyNode->addBranchClashes(clashDescriptors);
						}

						if (newTaskList) {
							CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
							processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);
						} else {
							clashDescriptors = createClashedConceptDescriptor(clashDescriptors,processIndi,nullptr,baseDepTrackPoint,calcAlgContext);
							throw CCalculationClashProcessingException(clashDescriptors);
						}

						throw CCalculationStopProcessingException(true);
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::mergeMergingIndividualNodes(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, cint64 linkCount, cint64 cardinality, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();
					CPROCESSSET<cint64>* distinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(false);
					CPROCESSSET<cint64>* locDistinctMergedSet = nullptr;

					cint64 deterministicMergingAttempt = 0;
					cint64 deterministicMergingStep = 0;

					cint64 distinctCount = 0;
					if (distinctMergedSet) {
						distinctCount = distinctMergedSet->count();
					}
					cint64 linkAndCandidateCount = branchingMergingProcRest->getRemainingLinkerMergingCandidateIndividualNodeCount() + distinctCount;
					if (linkCount != linkAndCandidateCount) {
						// update 
						branchingMergingProcRest->setRemainingValidMergingCandidateIndividualNodeCount(linkCount-distinctCount);
					}

					CDependencyTrackPoint* baseDepTrackPoint = branchingMergingProcRest->getDependencyTrackPoint();

					CDependencyTrackPoint* nextDepTrackPoint = nullptr;

					cint64 tmpCardinality = cardinality;


					if (cardinality <= 0 && branchingMergingProcRest->getRemainingLinkerMergingCandidateIndividualNodeCount() > 0) {
						// clash
						CBranchingMergingIndividualNodeCandidateLinker* mergeCandLinker = branchingMergingProcRest->takeNextMergingCandidateNodeLinker();
						while (mergeCandLinker) {
							CIndividualProcessNode* mergeCandIndiNode = mergeCandLinker->getMergingIndividualNodeCandidate();
							if (branchingMergingProcRest->hasValidRemainingMergingCandidates() || processIndi->hasRoleSuccessorToIndividual(role,mergeCandIndiNode,true)) {

								CClashedDependencyDescriptor* clashDescriptors = nullptr;

								CIndividualProcessNode* mergingIndiNode = getUpToDateIndividual(mergeCandIndiNode,calcAlgContext);
								clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,mergingIndiNode,mergeCandLinker->getMergingIndividualLink(),conceptOpLinkerIt,calcAlgContext);
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors,processIndi,nullptr,baseDepTrackPoint,calcAlgContext);
								throw CCalculationClashProcessingException(clashDescriptors);

							} else {
								// invalid link
								branchingMergingProcRest->incRemainingValidMergingCandidateIndividualNodeCount();
							}
							mergeCandLinker = branchingMergingProcRest->takeNextMergingCandidateNodeLinker();
						}
					}



					bool fixedNominalMerging = processIndi->isNominalIndividualNode() && branchingMergingProcRest->hasAddedBlockablePredecessorMergingNodeCandidate();
					bool requiresNNOperating = false;
					if (fixedNominalMerging) {
						cint64 fixDisCount = distinctCount + branchingMergingProcRest->getRemainingNominalCreationCount();
						if (fixDisCount > 0) {
							tmpCardinality = distinctCount;
							if (branchingMergingProcRest->hasRemainingMergingCandidates()) {
								requiresNNOperating = true;
							}
						} else if (linkAndCandidateCount > 0) {
							requiresNNOperating = true;
						}
					}

					CClashedDependencyDescriptor* initClashDescriptors = nullptr;

					if (linkAndCandidateCount > tmpCardinality || requiresNNOperating) {
						// needs merging
						if (fixedNominalMerging) {
							bool requiresNNInitialization = fixedNominalMerging && !branchingMergingProcRest->isDistinctSetFixed();
							if (requiresNNInitialization) {
								STATINC(INDINODEMERGENEWNOMINALINITCOUNT,calcAlgContext);

								if (!locDistinctMergedSet) {
									locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
									distinctMergedSet = locDistinctMergedSet;
									locDistinctMergedSet->clear();
									distinctCount = 0;
								}

								if (mConfLazyNewNominalGeneration) {
									branchingMergingProcRest->setRemainingNominalCreationCount(tmpCardinality);
									tmpCardinality = 0;
								} else {
									// generate new nominal successor nodes
									createNominalsSuccessorIndividuals(processIndi,role->getIndirectSuperRoleList(),role,conceptOpLinkerIt,false,branchingMergingProcRest->getAddedBlockablePredecessorDependencyTrackPoint(),tmpCardinality,calcAlgContext);
									distinctCount = tmpCardinality;

									cint64 disIndiIdx = 0;

									CIndividualLinkEdge* newLastLink = nullptr;
									CRoleSuccessorLinkIterator roleSuccIt(processIndi->getRoleSuccessorHistoryLinkIterator(role,branchingMergingProcRest->getLastIndividualLink()));
									while (roleSuccIt.hasNext()) {
										CIndividualLinkEdge* link = roleSuccIt.next();
										if (!newLastLink) {
											newLastLink = link;
										}
										CIndividualProcessNode* nominalSuccIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
										distinctMergedSet->insert(nominalSuccIndi->getIndividualNodeID());
										++disIndiIdx;
									}
									branchingMergingProcRest->setLastIndividualLink(newLastLink);
								}
								branchingMergingProcRest->setDistinctSetFixed(true);
							}

						} else {
							while (distinctCount <= 0) {
								if (!locDistinctMergedSet) {
									locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
									distinctMergedSet = locDistinctMergedSet;
								}
								initClashDescriptors = branchingMergingProcRest->getMultipleMergingNodesInitializationClashesDescriptors();
								CBranchingMergingIndividualNodeCandidateLinker* mergeCandLinker = branchingMergingProcRest->takeNextMergingCandidateNodeLinker();
								while (mergeCandLinker) {
									CIndividualProcessNode* mergeCandIndiNode = mergeCandLinker->getMergingIndividualNodeCandidate();

									if (!branchingMergingProcRest->hasValidRemainingMergingCandidates()) {
										mergeCandIndiNode = getCorrectedNominalIndividualNode(mergeCandIndiNode->getIndividualNodeID(),calcAlgContext);
									}

									CIndividualProcessNode* mergingIndiNode = getUpToDateIndividual(mergeCandIndiNode,calcAlgContext);
									initClashDescriptors = createIndividualMergeCausingDescriptors(initClashDescriptors,mergingIndiNode,mergeCandLinker->getMergingIndividualLink(),conceptOpLinkerIt,calcAlgContext);


									distinctMergedSet->insert(mergeCandIndiNode->getIndividualNodeID());

									++distinctCount;
									if (distinctCount > tmpCardinality) {
										// clash, not able to merge 
										if (!initClashDescriptors) {
											initClashDescriptors = branchingMergingProcRest->getMergingNodesInitializationClashesDescriptors();
										}
										initClashDescriptors = createClashedConceptDescriptor(initClashDescriptors,processIndi,nullptr,baseDepTrackPoint,calcAlgContext);
										throw CCalculationClashProcessingException(initClashDescriptors);
									}
									mergeCandLinker = branchingMergingProcRest->takeNextMergingInitializationCandidateNodeLinker();
								}
							}
						}


						if (!branchingMergingProcRest->hasValidRemainingMergingCandidates()) {
							// update distinct hash
							if (!distinctMergedSet) {
								locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
								distinctMergedSet = locDistinctMergedSet;
							}
							bool relocated = false;

							for (CPROCESSSET<cint64>::const_iterator disIt = distinctMergedSet->constBegin(), disItEnd = distinctMergedSet->constEnd(); disIt != disItEnd; ++disIt) {
								cint64 distinctIndiID = *disIt;

								CIndividualLinkEdge* disIndiLink = processIndi->getRoleSuccessorToIndividualLink(role,distinctIndiID,true);
								if (!disIndiLink) {
									CIndividualProcessNode* mergedIntoNode = getCorrectedNominalIndividualNode(distinctIndiID,calcAlgContext);
									if (!locDistinctMergedSet) {
										locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
										distinctMergedSet = locDistinctMergedSet;
									}
									locDistinctMergedSet->remove(distinctIndiID);
									relocated = true;
									if (locDistinctMergedSet->contains(mergedIntoNode->getIndividualNodeID())) {
										--distinctCount;
										if (fixedNominalMerging) {
											tmpCardinality = distinctCount;
										}
									}
									locDistinctMergedSet->insert(mergedIntoNode->getIndividualNodeID());
								} else if (locDistinctMergedSet) {
									locDistinctMergedSet->insert(distinctIndiID);
								}
							}

							if (relocated) {
								branchingMergingProcRest->setDistinctSetNodeRelocated(true);
							}
						}



						while (branchingMergingProcRest->hasRemainingMergingCandidates()) {

							++deterministicMergingAttempt;
							bool createNewNodesAsNominals = false;

							if (mConfLazyNewNominalGeneration) {
								cint64 remainingNewNominalCreationCount = branchingMergingProcRest->getRemainingNominalCreationCount();
								if (remainingNewNominalCreationCount > 0) {
									// generate new nominal

									//createNominalsSuccessorIndividuals(processIndi,role->getIndirectSuperRoleList(),role,conceptOpLinkerIt,false,branchingMergingProcRest->getAddedBlockablePredecessorDependencyTrackPoint(),1,calcAlgContext);
									//if (!locDistinctMergedSet) {
									//	locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
									//	distinctMergedSet = locDistinctMergedSet;
									//}
									//++distinctCount;
									++tmpCardinality;
									createNewNodesAsNominals = true;
									//CRoleSuccessorLinkIterator roleSuccIt(processIndi->getRoleSuccessorHistoryLinkIterator(role,branchingMergingProcRest->getLastIndividualLink()));
									//if (roleSuccIt.hasNext()) {
									//	CIndividualLinkEdge* link = roleSuccIt.next();
									//	branchingMergingProcRest->setLastIndividualLink(link);
									//	CIndividualProcessNode* nominalSuccIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
									//	distinctMergedSet->insert(nominalSuccIndi->getIndividualID());
									//}

									//branchingMergingProcRest->setRemainingNominalCreationCount(remainingNewNominalCreationCount-1);
								}
							}

							CBranchingMergingIndividualNodeCandidateLinker* mergeCandLinker = branchingMergingProcRest->takeNextMergingCandidateNodeLinker();
							CIndividualProcessNode* mergeCandIndiNode = mergeCandLinker->getMergingIndividualNodeCandidate();

							KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

							if (((branchingMergingProcRest->hasValidRemainingMergingCandidates() && branchingMergingProcRest->getRemainingValidMergingCandidateIndividualNodeCount() > 0) || processIndi->hasRoleSuccessorToIndividual(role,mergeCandIndiNode,true)) && !distinctMergedSet->contains(mergeCandIndiNode->getIndividualNodeID())) {
								++deterministicMergingStep;

								CIndividualProcessNode* mergingIndiNode = getUpToDateIndividual(mergeCandIndiNode,calcAlgContext);

								// TODO: collect clashes and update distinct node set
								CClashedDependencyDescriptor* clashDescriptors = initClashDescriptors;
								initClashDescriptors = nullptr;
								clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,mergingIndiNode,mergeCandLinker->getMergingIndividualLink(),conceptOpLinkerIt,calcAlgContext);

								CPROCESSSET<cint64>* itDistinctMergedSet = distinctMergedSet;
								CPROCESSSET<cint64>::const_iterator disItEnd = distinctMergedSet->constEnd();
								CPROCESSSET<cint64>::const_iterator firstMergeableIt = disItEnd;
								CPROCESSSET<cint64>::const_iterator secondMergeableIt = disItEnd;

								cint64 firstContIndex = 0;
								cint64 secondContIndex = 0;


								cint64 contIndex = 0;
								for (CPROCESSSET<cint64>::const_iterator disIt = distinctMergedSet->constBegin(); disIt != disItEnd;) {
									++contIndex;
									cint64 distinctIndiID = *disIt;

									CIndividualLinkEdge* disIndiLink = processIndi->getRoleSuccessorToIndividualLink(role,distinctIndiID,true);
									//if (!disIndiLink) {
									//	mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
									//	QFile file(QString("./Debugging/CompletionTasks/task-root-clashed.txt"));
									//	if (file.open(QIODevice::WriteOnly)) {
									//		file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
									//		file.close();
									//	}
									//	bool bug = true;

									//}
									KONCLUDE_ASSERT_X(disIndiLink,"merging individual nodes","individual node link for distinct hashed individual node not found");
									if (disIndiLink) {
										CIndividualProcessNode* disIndiNode = getSuccessorIndividual(processIndi,disIndiLink,calcAlgContext);

										clashDescriptors = createIndividualMergeCausingDescriptors(clashDescriptors,disIndiNode,disIndiLink,conceptOpLinkerIt,calcAlgContext);

										if (isIndividualNodesMergeable(disIndiNode,mergingIndiNode,clashDescriptors,calcAlgContext)) {
											if (firstMergeableIt == disItEnd) {
												firstMergeableIt = disIt;
												firstContIndex = contIndex;
											} else {
												secondMergeableIt = disIt;
												secondContIndex = contIndex;
												break;
											}
										} 
										++disIt;
									} 							
								}

								//KONCLUCE_TASK_ALGORITHM_CLASH_STRING_INSTRUCTION(mMergingClashString = generateDebugTrackedClashedDescriptorString(createTrackedClashesDescriptors(clashDescriptors,calcAlgContext),calcAlgContext));

								CMERGEDependencyNode* mergeDependencyNode = createMERGEDependency(processIndi,nullptr,baseDepTrackPoint,calcAlgContext);
								if (mergeDependencyNode) {
									mergeDependencyNode->addBranchClashes(clashDescriptors);
								}


								//KONCLUCE_TASK_ALGORITHM_BRANCH_STRING_INSTRUCTION(mergeDependencyNode->getBranchNode()->setBranchString(new QString(QString("%1").arg(mergingIndiNode->getIndividualID()))));


								if (firstMergeableIt == disItEnd) {
									if (distinctCount < tmpCardinality) {
										++mAppliedATMOSTRuleCount;

										// add individual to distinct set
										if (!locDistinctMergedSet) {
											locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
											distinctMergedSet = locDistinctMergedSet;
										}
										CNonDeterministicDependencyTrackPoint* mergeNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(mergeDependencyNode,true,calcAlgContext);
										if ((!mConfMinimizeMerging && !createNewNodesAsNominals) || mergingIndiNode->isNominalIndividualNode()) {
											distinctMergedSet->insert(mergingIndiNode->getIndividualNodeID());

											if (createNewNodesAsNominals) {
												branchingMergingProcRest->decRemainingNominalCreationCount();
											}

											branchingMergingProcRest->initMergingDependencyNode(mergeDependencyNode);
											branchingMergingProcRest->initDependencyTracker(mergeNonDetDepTrackPoint);
											baseDepTrackPoint = mergeNonDetDepTrackPoint;
										} else {
											CIndividualProcessNode* locMergingIndiNode = getLocalizedIndividual(mergingIndiNode,false,calcAlgContext);

											if (createNewNodesAsNominals) {
												branchingMergingProcRest->decRemainingNominalCreationCount();
											}

											CIndividualProcessNode* mergedIntoEmptyIndiNode = getIntoEmptyMergedIndividualNode(locMergingIndiNode,createNewNodesAsNominals,processIndi,mergeNonDetDepTrackPoint,calcAlgContext);
											distinctMergedSet->insert(mergedIntoEmptyIndiNode->getIndividualNodeID());

											CRoleSuccessorLinkIterator roleSuccIt(processIndi->getRoleSuccessorHistoryLinkIterator(role,branchingMergingProcRest->getLastIndividualLink()));
											if (roleSuccIt.hasNext()) {
												CIndividualLinkEdge* link = roleSuccIt.next();
												branchingMergingProcRest->setLastIndividualLink(link);
											}
											addIndividualToProcessingQueue(mergedIntoEmptyIndiNode,calcAlgContext);

											KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

										}


										++distinctCount;
									} else {
										// clash, not able to merge 
										clashDescriptors = createClashedConceptDescriptor(clashDescriptors,processIndi,nullptr,baseDepTrackPoint,calcAlgContext);

										throw CCalculationClashProcessingException(clashDescriptors);
									}
								} else if (secondMergeableIt == disItEnd && distinctCount >= tmpCardinality) {
									++mAppliedATMOSTRuleCount;
									// only one possibility to merge
									setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
									CIndividualProcessNode* locDisIndiNode = getLocalizedIndividual(*firstMergeableIt,calcAlgContext);
									CIndividualProcessNode* locMergingIndiNode = getLocalizedIndividual(mergingIndiNode,false,calcAlgContext);

									CNonDeterministicDependencyTrackPoint* mergeNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(mergeDependencyNode,true,calcAlgContext);

									if (branchingMergingProcRest->isDistinctSetNodeRelocated()) {
										branchingMergingProcRest->setDistinctSetNodeRelocated(false);
										branchingMergingProcRest->initMergingDependencyNode(mergeDependencyNode);
										branchingMergingProcRest->initDependencyTracker(mergeNonDetDepTrackPoint);
									}

									CIndividualProcessNode* locMergedIndiNode = getMergedIndividualNodes(locDisIndiNode,locMergingIndiNode,mergeNonDetDepTrackPoint,calcAlgContext);
									if (locMergedIndiNode->getIndividualNodeID() != locDisIndiNode->getIndividualNodeID()) {
										if (!locDistinctMergedSet) {
											locDistinctMergedSet = branchingMergingProcRest->getDistinctMergedNodesSet(true);
											distinctMergedSet = locDistinctMergedSet;
										}
										distinctMergedSet->remove(locDisIndiNode->getIndividualNodeID());
										distinctMergedSet->insert(locMergedIndiNode->getIndividualNodeID());
										branchingMergingProcRest->setDistinctSetNodeRelocated(true);
									}

									if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForMergedIndividualNodes(conProDes,processIndi,locMergedIndiNode)) {
										testIndividualNodeUnsatisfiableCached(locMergedIndiNode,calcAlgContext);
									}


									CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
									CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorHistoryLinkIterator(role,branchingMergingProcRest->getLastIndividualLink(),&linkCount);
									if (roleSuccIt.hasNext()) {
										initializeMergingIndividualNodes(processIndi,conProDes,&roleSuccIt,nullptr,conceptOpLinkerIt,branchingMergingProcRest,calcAlgContext);
										qualifyMergingIndividualNodes(processIndi,conProDes,branchingMergingProcRest,calcAlgContext);
									}

								} else {
									++mAppliedATMOSTRuleCount;
									CSatisfiableCalculationTask* newTaskList = nullptr;

									setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
									if (firstMergeableIt != disItEnd) {
										CIndividualProcessNode* firstDistinctIndiNode = getUpToDateIndividual(*firstMergeableIt,calcAlgContext);
										CSatisfiableCalculationTask* newTask = createMergeBranchingTask(processIndi,conProDes,firstDistinctIndiNode,mergingIndiNode,mergeDependencyNode,branchingMergingProcRest,calcAlgContext);
										newTaskList = (CSatisfiableCalculationTask*)newTask->append(newTaskList);
									}
									if (secondMergeableIt != disItEnd) {
										CIndividualProcessNode* secondDistinctIndiNode = getUpToDateIndividual(*secondMergeableIt,calcAlgContext);
										CSatisfiableCalculationTask* newTask = createMergeBranchingTask(processIndi,conProDes,secondDistinctIndiNode,mergingIndiNode,mergeDependencyNode,branchingMergingProcRest,calcAlgContext);
										newTaskList = (CSatisfiableCalculationTask*)newTask->append(newTaskList);

										CPROCESSSET<cint64>::const_iterator mergeableIt = secondMergeableIt;
										while (++mergeableIt != disItEnd) {
											cint64 distinctIndiID = *mergeableIt;

											CIndividualLinkEdge* disIndiLink = processIndi->getRoleSuccessorToIndividualLink(role,distinctIndiID,true);
											KONCLUDE_ASSERT_X(disIndiLink,"merging individual nodes","individual node link for distinct hashed individual node not found");
											if (disIndiLink) {
												CIndividualProcessNode* distinctIndiNode = getSuccessorIndividual(processIndi,disIndiLink,calcAlgContext);

												CClashedDependencyDescriptor* moreClashDescriptors = createIndividualMergeCausingDescriptors(nullptr,distinctIndiNode,disIndiLink,conceptOpLinkerIt,calcAlgContext);

												if (isIndividualNodesMergeable(distinctIndiNode,mergingIndiNode,moreClashDescriptors,calcAlgContext)) {
													CSatisfiableCalculationTask* newTask = createMergeBranchingTask(processIndi,conProDes,distinctIndiNode,mergingIndiNode,mergeDependencyNode,branchingMergingProcRest,calcAlgContext);
													newTaskList = (CSatisfiableCalculationTask*)newTask->append(newTaskList);
												}

												if (mergeDependencyNode) {
													mergeDependencyNode->addBranchClashes(moreClashDescriptors);
												}
											}
										}
									}

									if (distinctCount < tmpCardinality) {
										CSatisfiableCalculationTask* newTask = createDistinctBranchingTask(processIndi,conProDes,mergingIndiNode,createNewNodesAsNominals,mergeDependencyNode,branchingMergingProcRest,calcAlgContext);
										newTaskList = (CSatisfiableCalculationTask*)newTask->append(newTaskList);
									}


									CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
									processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

									throw CCalculationStopProcessingException(true);
								}

							} else {
								// invalid link
								branchingMergingProcRest->incRemainingValidMergingCandidateIndividualNodeCount();
							}
						}

					}
					return false;
				}



				CSatisfiableCalculationTask* CCalculationTableauCompletionTaskHandleAlgorithm::createDistinctBranchingTask(CIndividualProcessNode*& processIndiNode, CConceptProcessDescriptor*& conProDes, CIndividualProcessNode*& distinctIndiNode, bool createAsNominal, CNonDeterministicDependencyNode* mergeDependencyNode, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(TASKDISTINCTMERGEBRANCHCREATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CRole* role = conDes->getConcept()->getRole();
					CSatisfiableCalculationTask* newSatCalcTask = createDependendBranchingTaskList(1,calcAlgContext);

					CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

					CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);

					CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
					CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

					CMemoryAllocationManager* newTaskMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CNonDeterministicDependencyTrackPoint* mergeNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(mergeDependencyNode,false,newCalcAlgContext);

					CBranchingMergingProcessingRestrictionSpecification* newBranchingMergingProcRest = CObjectParameterizingAllocator< CBranchingMergingProcessingRestrictionSpecification,CProcessContext* >::allocateAndConstructAndParameterize(newTaskMemMan,newProcessContext);
					newBranchingMergingProcRest->initBranchingMergingProcessingRestriction(branchingMergingProcRest);

					CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
					newProcessTagger->incBranchingTag();
					newProcessTagger->incLocalizationTag();

					CIndividualProcessNode* newLocDistinctIndiNode = getLocalizedIndividual(distinctIndiNode,false,newCalcAlgContext);

					CIndividualProcessNode* locProcessIndiNode = getLocalizedIndividual(processIndiNode,false,newCalcAlgContext);

					// make distinct to all other 
					CPROCESSSET<cint64>* locDistinctMergedSet = newBranchingMergingProcRest->getDistinctMergedNodesSet(true);


					if ((mConfMinimizeMerging || createAsNominal) && !newLocDistinctIndiNode->isNominalIndividualNode()) {
						if (createAsNominal) {
							newBranchingMergingProcRest->decRemainingNominalCreationCount();
						}

						CIndividualProcessNode* mergedIntoEmptyIndiNode = getIntoEmptyMergedIndividualNode(newLocDistinctIndiNode,createAsNominal,processIndiNode,mergeNonDetDepTrackPoint,newCalcAlgContext);
						locDistinctMergedSet->insert(mergedIntoEmptyIndiNode->getIndividualNodeID());

						CRoleSuccessorLinkIterator roleSuccIt(locProcessIndiNode->getRoleSuccessorHistoryLinkIterator(role,newBranchingMergingProcRest->getLastIndividualLink()));
						if (roleSuccIt.hasNext()) {
							CIndividualLinkEdge* link = roleSuccIt.next();
							newBranchingMergingProcRest->setLastIndividualLink(link);
						}
						addIndividualToProcessingQueue(mergedIntoEmptyIndiNode,newCalcAlgContext);

						KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mDebugIndiModelString = generateDebugIndiModelStringList(newCalcAlgContext));

					} else {
						newBranchingMergingProcRest->initMergingDependencyNode(mergeDependencyNode);
						newBranchingMergingProcRest->initDependencyTracker(mergeNonDetDepTrackPoint);

						locDistinctMergedSet->insert(newLocDistinctIndiNode->getIndividualNodeID());
					}


					if (newBranchingMergingProcRest->isDistinctSetNodeRelocated()) {
						newBranchingMergingProcRest->setDistinctSetNodeRelocated(false);
						newBranchingMergingProcRest->initMergingDependencyNode(mergeDependencyNode);
						newBranchingMergingProcRest->initDependencyTracker(mergeNonDetDepTrackPoint);
					}


					// continue merging
					CConceptProcessingQueue* conProQueu = locProcessIndiNode->getConceptProcessingQueue(true);
					addConceptRestrictedToProcessingQueue(conDes,mergeNonDetDepTrackPoint,conProQueu,locProcessIndiNode,true,newBranchingMergingProcRest,newCalcAlgContext);

					prepareBranchedTaskProcessing(locProcessIndiNode,newSatCalcTask,newCalcAlgContext);

					KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mDebugIndiModelString = generateDebugIndiModelStringList(newCalcAlgContext));

					// set new task priority
					double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskMerging(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask());
					newSatCalcTask->setTaskPriority(newTaskPriority);

					return newSatCalcTask;
				}



				CSatisfiableCalculationTask* CCalculationTableauCompletionTaskHandleAlgorithm::createMergeBranchingTask(CIndividualProcessNode*& processIndiNode, CConceptProcessDescriptor*& conProDes, CIndividualProcessNode*& distinctIndiNode, CIndividualProcessNode*& mergingIndiNode, CNonDeterministicDependencyNode* mergeDependencyNode, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(TASKINDINODEMERGEBRANCHCREATIONCOUNT,calcAlgContext);

					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CSatisfiableCalculationTask* newSatCalcTask = createDependendBranchingTaskList(1,calcAlgContext);

					CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

					CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);

					CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
					CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

					CMemoryAllocationManager* newTaskMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CNonDeterministicDependencyTrackPoint* mergeNonDetDepTrackPoint = createNonDeterministicDependencyTrackPointBranch(mergeDependencyNode,false,newCalcAlgContext);

					CBranchingMergingProcessingRestrictionSpecification* newBranchingMergingProcRest = CObjectParameterizingAllocator< CBranchingMergingProcessingRestrictionSpecification,CProcessContext* >::allocateAndConstructAndParameterize(newTaskMemMan,newProcessContext);
					newBranchingMergingProcRest->initBranchingMergingProcessingRestriction(branchingMergingProcRest);

					CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
					newProcessTagger->incBranchingTag();
					newProcessTagger->incLocalizationTag();

					CIndividualProcessNode* newLocDistinctIndiNode = getLocalizedIndividual(distinctIndiNode,false,newCalcAlgContext);
					CIndividualProcessNode* newLocMergingIndiNode = getLocalizedIndividual(mergingIndiNode,false,newCalcAlgContext);


					if (newBranchingMergingProcRest->isDistinctSetNodeRelocated()) {
						newBranchingMergingProcRest->setDistinctSetNodeRelocated(false);
						newBranchingMergingProcRest->initMergingDependencyNode(mergeDependencyNode);
						newBranchingMergingProcRest->initDependencyTracker(mergeNonDetDepTrackPoint);
					}

					CIndividualProcessNode* locMergedIndiNode = getMergedIndividualNodes(newLocDistinctIndiNode,newLocMergingIndiNode,mergeNonDetDepTrackPoint,newCalcAlgContext);
					if (locMergedIndiNode->getIndividualNodeID() != newLocDistinctIndiNode->getIndividualNodeID()) {
						CPROCESSSET<cint64>* locDistinctMergedSet = newBranchingMergingProcRest->getDistinctMergedNodesSet(true);
						locDistinctMergedSet->remove(newLocDistinctIndiNode->getIndividualNodeID());
						locDistinctMergedSet->insert(locMergedIndiNode->getIndividualNodeID());
						newBranchingMergingProcRest->setDistinctSetNodeRelocated(true);
					}


					// continue merging
					CIndividualProcessNode* locProcessIndiNode = getLocalizedIndividual(processIndiNode,true,newCalcAlgContext);
					CConceptProcessingQueue* conProQueu = locProcessIndiNode->getConceptProcessingQueue(true);
					addConceptRestrictedToProcessingQueue(conDes,mergeNonDetDepTrackPoint,conProQueu,locProcessIndiNode,true,newBranchingMergingProcRest,newCalcAlgContext);


					if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForMergedIndividualNodes(conProDes,locProcessIndiNode,locMergedIndiNode)) {
						addIndividualNodeForCacheUnsatisfiableRetrieval(locMergedIndiNode,newCalcAlgContext);
					}

					prepareBranchedTaskProcessing(locProcessIndiNode,newSatCalcTask,newCalcAlgContext);

					KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mDebugIndiModelString = generateDebugIndiModelStringList(newCalcAlgContext));

					// set new task priority
					double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskMerging(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask());
					newSatCalcTask->setTaskPriority(newTaskPriority);

					return newSatCalcTask;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::qualifyMergingIndividualNodes(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					cint64 cardinality = concept->getParameter() - 1*conDes->isNegated();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();

					bool qualifing = false;

					CBranchingMergingIndividualNodeCandidateLinker* qualifyPosNegCandLinker = branchingMergingProcRest->getBothQualifyCandidateNodeLinker();
					while (qualifyPosNegCandLinker) {

						CIndividualProcessNode* qualifyIndiNode = qualifyPosNegCandLinker->getMergingIndividualNodeCandidate();

						// check still valid
						CIndividualLinkEdge* link = processIndi->getRoleSuccessorToIndividualLink(role,qualifyIndiNode,true);
						if (link) {
							CIndividualProcessNode* upQualifyIndiNode = getUpToDateIndividual(qualifyIndiNode,calcAlgContext);
							bool negated = false;
							if (containsIndividualNodeConcepts(upQualifyIndiNode,conceptOpLinkerIt,&negated,calcAlgContext)) {
								if (!negated) {
									if (cardinality <= 0) {
										// clash
									}
									CBranchingMergingIndividualNodeCandidateLinker* qualifiedMovedCandLinker = CObjectParameterizingAllocator< CBranchingMergingIndividualNodeCandidateLinker,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
									qualifiedMovedCandLinker->initBranchingMergingIndividualNodeCandidate(qualifyPosNegCandLinker);
									branchingMergingProcRest->addMergingCandidateNodeLinker(qualifiedMovedCandLinker);
								}

							} else {
								setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
								CClashedDependencyDescriptor* clashDes = createClashedIndividualLinkDescriptor(nullptr,link,link->getDependencyTrackPoint(),calcAlgContext);

								// create dependency
								CQUALIFYDependencyNode* qualifyDepNode = createQUALIFYDependency(processIndi,nullptr,branchingMergingProcRest->getDependencyTrackPoint(),calcAlgContext);
								if (qualifyDepNode) {
									qualifyDepNode->addBranchClashes(clashDes);
								}
								branchingMergingProcRest->setBothQualifyCandidateNodeLinker(qualifyPosNegCandLinker->getNext());


								if (cardinality <= 0) {
									++mAppliedATMOSTRuleCount;
									STATINC(INDINODEQUALIFYCHOOCECOUNT,calcAlgContext);
									CDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(qualifyDepNode,true,calcAlgContext);

									CIndividualProcessNode* locQualifyIndiNode =  getLocalizedIndividual(upQualifyIndiNode,false,calcAlgContext);
									// qualify only negated
									addConceptsToIndividual(conceptOpLinkerIt,true,locQualifyIndiNode,newDependencyTrackPoint,false,true,nullptr,calcAlgContext);
									addIndividualToProcessingQueue(locQualifyIndiNode,calcAlgContext);

									if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForQualifiedIndividualNodes(conProDes,processIndi,locQualifyIndiNode)) {
										addIndividualNodeForCacheUnsatisfiableRetrieval(locQualifyIndiNode,calcAlgContext);
									}


								} else {
									++mAppliedATMOSTRuleCount;
									STATINC(INDINODEQUALIFYCHOOCECOUNT,calcAlgContext);

									qualifing = true;


									CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(2,calcAlgContext);
									CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

									CSatisfiableCalculationTask* newTaskIt = newTaskList;
									cint64 branchNumber = 1;
									bool qualNeg = true;
									while (newTaskIt) {
										STATINC(TASKQUALIFYCHOOSEBRANCHCREATIONCOUNT,calcAlgContext);

										CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;
										CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);

										CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
										CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

										CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
										newProcessTagger->incBranchingTag();
										newProcessTagger->incLocalizationTag();

										CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(processIndi,false,newCalcAlgContext);
										CConceptProcessingQueue* newConProcQueue = newLocIndiNode->getConceptProcessingQueue(true);


										CIndividualProcessNode* newLocQualifyIndiNode =  getLocalizedIndividual(upQualifyIndiNode,false,newCalcAlgContext);


										// create dependency track point
										CDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(qualifyDepNode,false,newCalcAlgContext);

										if (!qualNeg) {
											CMemoryAllocationManager* newTaskMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();
											CBranchingMergingProcessingRestrictionSpecification* newBranchingMergingProcRest = CObjectParameterizingAllocator< CBranchingMergingProcessingRestrictionSpecification,CProcessContext* >::allocateAndConstructAndParameterize(newTaskMemMan,newProcessContext);
											newBranchingMergingProcRest->initBranchingMergingProcessingRestriction(branchingMergingProcRest);
											CBranchingMergingIndividualNodeCandidateLinker* qualifiedMovedCandLinker = CObjectParameterizingAllocator< CBranchingMergingIndividualNodeCandidateLinker,CProcessContext* >::allocateAndConstructAndParameterize(newTaskMemMan,newProcessContext);
											qualifiedMovedCandLinker->initBranchingMergingIndividualNodeCandidate(qualifyPosNegCandLinker);
											newBranchingMergingProcRest->addMergingCandidateNodeLinker(qualifiedMovedCandLinker);

											branchingMergingProcRest = newBranchingMergingProcRest;
										}

										// ATMOST reapplication in new tasks
										addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,newConProcQueue,newLocIndiNode,true,branchingMergingProcRest,newCalcAlgContext);

										// qualify
										addConceptsToIndividual(conceptOpLinkerIt,qualNeg,newLocQualifyIndiNode,newDependencyTrackPoint,false,true,nullptr,newCalcAlgContext);
										addIndividualToProcessingQueue(newLocQualifyIndiNode,newCalcAlgContext);

										if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForQualifiedIndividualNodes(conProDes,newLocIndiNode,newLocQualifyIndiNode)) {
											addIndividualNodeForCacheUnsatisfiableRetrieval(newLocQualifyIndiNode,newCalcAlgContext);
										}

										prepareBranchedTaskProcessing(newLocIndiNode,newTaskIt,newCalcAlgContext);

										// set new task priority
										double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskQualifing(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask(),qualNeg);
										newSatCalcTask->setTaskPriority(newTaskPriority);

										++branchNumber;
										qualNeg = !qualNeg;
										newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();
									}

									processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

									throw CCalculationStopProcessingException(true);
								}
							}
						}

						qualifyPosNegCandLinker = qualifyPosNegCandLinker->getNext();
					}
					branchingMergingProcRest->setBothQualifyCandidateNodeLinker(nullptr);
					return qualifing;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::initializeMergingIndividualNodes(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, CRoleSuccessorLinkIterator* roleSuccIt, CIndividualLinkEdge* usingLastLink, CSortedNegLinker<CConcept*>* conceptOpLinkerIt, CBranchingMergingProcessingRestrictionSpecification* branchingMergingProcRest, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CProcessContext* processContext = calcAlgContext->getUsedProcessContext();


					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					bool negate = conDes->getNegation();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CConcept* concept = conDes->getConcept();

					cint64 cardinality = concept->getParameter() - 1*negate;

					CConceptRoleBranchingTrigger* chooseTriggerLinker = nullptr;
					CConceptProcessData* conProData = (CConceptProcessData*)concept->getConceptData();
					if (conProData) {
						chooseTriggerLinker = conProData->getConceptRoleBranchTrigger();
					}


					CIndividualLinkEdge* firstLink = usingLastLink;
					CBranchingMergingIndividualNodeCandidateLinker* disIndiNodeCandLinker = nullptr;
					CBranchingMergingIndividualNodeCandidateLinker* maxDisIndiNodeCandLinker = nullptr;
					cint64 maxDisIndiNodeCandCount = 0;
					cint64 disIndiNodeCandCount = 0;
					bool collectMaxDistinctMergingNodes = true;
					bool canInitMerging = !branchingMergingProcRest->hasMergingInitializationCandidates();


					CXLinker<CIndividualLinkEdge*>* lastCheckedTriggeredSuccLinker = nullptr;
					CXLinker<CIndividualLinkEdge*>* newTriggeredSuccLinker = nullptr;

					if (branchingMergingProcRest->hasSuccessorChoiceTriggeringInstalled()) {
						if (branchingMergingProcRest->getSuccessorChoiceTriggeringInstalledCount() > 0) {
							CSuccessorIndividualATMOSTReactivationData* succIndiATMOSTReactivationData = processIndi->getSuccessorIndividualATMOSTReactivationData(false);
							lastCheckedTriggeredSuccLinker = branchingMergingProcRest->getLastCheckedSuccessorChoiceTriggerLinker();
							newTriggeredSuccLinker = succIndiATMOSTReactivationData->getReactivationSuccessorIndividualLinkLinker(conDes);
							if (lastCheckedTriggeredSuccLinker != newTriggeredSuccLinker) {
								branchingMergingProcRest->setLastCheckedSuccessorChoiceTriggerLinker(newTriggeredSuccLinker);
							}
						}
					}

					while (roleSuccIt->hasNext() || newTriggeredSuccLinker != lastCheckedTriggeredSuccLinker) {
						STATINC(INDINODEMERGEINITCOUNT,calcAlgContext);

						CIndividualLinkEdge* link = nullptr;
						CIndividualProcessNode* succIndi = nullptr;

						if (roleSuccIt->hasNext()) {
							link = roleSuccIt->next();
						} else if (newTriggeredSuccLinker != lastCheckedTriggeredSuccLinker) {
							link = newTriggeredSuccLinker->getData();
							branchingMergingProcRest->decSuccessorChoiceTriggeringInstalledCount();
							newTriggeredSuccLinker = newTriggeredSuccLinker->getNext();
						}
						succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);


						bool containsNegation = false;
						if (containsIndividualNodeConcepts(succIndi,conceptOpLinkerIt,&containsNegation,calcAlgContext)) {


							CBranchingMergingIndividualNodeCandidateLinker* mergeIndiNodeCandLinker = CObjectParameterizingAllocator< CBranchingMergingIndividualNodeCandidateLinker,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);
							mergeIndiNodeCandLinker->initBranchingMergingIndividualNodeCandidate(succIndi,link);


							if (!containsNegation) {
								bool delayedCandAdded = false;
								CDistinctHash* disHash = succIndi->getDistinctHash(false);
								if (collectMaxDistinctMergingNodes && disHash) {
									if (disIndiNodeCandLinker) {
										bool distinctToAllPrev = true;
										CBranchingMergingIndividualNodeCandidateLinker* disIndiNodeCandLinkerIt = disIndiNodeCandLinker;
										while (disIndiNodeCandLinkerIt) {
											if (!disHash->isIndividualDistinct(disIndiNodeCandLinkerIt->getMergingIndividualNodeCandidate()->getIndividualNodeID())) {
												distinctToAllPrev = false;
												break;
											}
											disIndiNodeCandLinkerIt = disIndiNodeCandLinkerIt->getNext();
										}
										if (distinctToAllPrev) {
											disIndiNodeCandLinker = mergeIndiNodeCandLinker->append(disIndiNodeCandLinker);
											++disIndiNodeCandCount;
											delayedCandAdded = true;
										} else {
											if (disIndiNodeCandCount > maxDisIndiNodeCandCount) {
												maxDisIndiNodeCandCount = disIndiNodeCandCount;
												branchingMergingProcRest->addMergingCandidateNodeLinker(maxDisIndiNodeCandLinker);
												maxDisIndiNodeCandLinker = disIndiNodeCandLinker;
											} else {
												branchingMergingProcRest->addMergingCandidateNodeLinker(disIndiNodeCandLinker);
											}
											disIndiNodeCandCount = 0;
											disIndiNodeCandLinker = nullptr;
										}
									}


									if (!disIndiNodeCandLinker) {
										if (disHash->getDistinctCount() >= maxDisIndiNodeCandCount) {
											disIndiNodeCandLinker = mergeIndiNodeCandLinker;
											disIndiNodeCandCount = 1;
											delayedCandAdded = true;
										}
									}
								}
								if (!delayedCandAdded) {
									branchingMergingProcRest->addMergingCandidateNodeLinker(mergeIndiNodeCandLinker);
								}
							}

						} else {

							bool installedChoiseTriggering = false;
							CConcept* triggeringConcept = nullptr;
							bool triggerNegation = false;
							for (CConceptRoleBranchingTrigger* chooseTriggerIt = chooseTriggerLinker; !installedChoiseTriggering && chooseTriggerIt; chooseTriggerIt = chooseTriggerIt->getNext()) {
								if (chooseTriggerIt->isConceptTrigger()) {
									bool containedNegation = false;
									if (containsIndividualNodeConcept(succIndi,chooseTriggerIt->getTriggerConcept(),&containedNegation,calcAlgContext)) {
										if (chooseTriggerIt->getTriggerNegation() == containedNegation) {
											installedChoiseTriggering = true;
											triggeringConcept = chooseTriggerIt->getTriggerConcept();
											triggerNegation = chooseTriggerIt->getTriggerNegation();
										}
									}
								}
							}

							if (installedChoiseTriggering) {
								branchingMergingProcRest->setSuccessorChoiceTriggeringInstalled(true);
								branchingMergingProcRest->incSuccessorChoiceTriggeringInstalledCount();

								STATINC(INSERTCONCEPTREAPPLICATIONSCOUNT,calcAlgContext);
								CCondensedReapplyQueue* reapplyQueue = processIndi->getConceptReapplyQueue(triggeringConcept,triggerNegation,true);
								CExtendedCondensedReapplyConceptDescriptorATMOSTReactivation* reapplyATMOSTConDes = CObjectAllocator<CExtendedCondensedReapplyConceptDescriptorATMOSTReactivation>::allocateAndConstruct(taskMemMan);
								reapplyATMOSTConDes->initAtmostExtendedReapllyDescriptor(conDes,depTrackPoint,!triggerNegation,branchingMergingProcRest,processIndi,link);
								reapplyQueue->addReapplyConceptDescriptor(reapplyATMOSTConDes);
								
							} else {

								CBranchingMergingIndividualNodeCandidateLinker* mergeIndiNodeCandLinker = CObjectParameterizingAllocator< CBranchingMergingIndividualNodeCandidateLinker,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,processContext);
								mergeIndiNodeCandLinker->initBranchingMergingIndividualNodeCandidate(succIndi,link);

								// TODO: check cache, add to only pos or neg qualify candidate node linker
								branchingMergingProcRest->addBothQualifyCandidateNodeLinker(mergeIndiNodeCandLinker);
							}
						}
						if (!firstLink) {
							firstLink = link;
						}
					}
					if (disIndiNodeCandLinker) {
						if (disIndiNodeCandCount > maxDisIndiNodeCandCount) {
							maxDisIndiNodeCandCount = disIndiNodeCandCount;
							branchingMergingProcRest->addMergingCandidateNodeLinker(maxDisIndiNodeCandLinker);
							maxDisIndiNodeCandLinker = disIndiNodeCandLinker;
						} else {
							branchingMergingProcRest->addMergingCandidateNodeLinker(disIndiNodeCandLinker);
						}
					}
					if (maxDisIndiNodeCandLinker) {
						cint64 disIndiCollCount = 0;
						if (canInitMerging || maxDisIndiNodeCandCount > cardinality) {
							CPROCESSINGSET<CDependencyTrackPoint*> distinctInitDepTrackPointSet(calcAlgContext->getUsedTaskProcessorContext());
							bool multipleDistinctInitClashes = false;
							CClashedDependencyDescriptor* distinctInitClashes = nullptr;
							CBranchingMergingIndividualNodeCandidateLinker* initMergingIndiNodeCandIt = maxDisIndiNodeCandLinker;
							while (initMergingIndiNodeCandIt && disIndiCollCount <= cardinality) {
								CIndividualProcessNode* indiNodeMergeCand = initMergingIndiNodeCandIt->getMergingIndividualNodeCandidate();

								CBranchingMergingIndividualNodeCandidateLinker* initMergingIndiNodeCandIt2 = initMergingIndiNodeCandIt->getNext();
								while (initMergingIndiNodeCandIt2) {
									CIndividualProcessNode* otherIndiNodeMergeCand = initMergingIndiNodeCandIt2->getMergingIndividualNodeCandidate();
									CDistinctEdge* disEdge = indiNodeMergeCand->getDistinctHash(false)->getIndividualDistinctEdge(otherIndiNodeMergeCand->getIndividualNodeID());
									CDependencyTrackPoint* disEdgeDepTrackPoint = disEdge->getDependencyTrackPoint();
									if (!distinctInitDepTrackPointSet.contains(disEdgeDepTrackPoint)) {
										distinctInitDepTrackPointSet.insert(disEdgeDepTrackPoint);
										if (distinctInitClashes) {
											multipleDistinctInitClashes = true;
										}
										distinctInitClashes = createClashedIndividualDistinctDescriptor(distinctInitClashes,disEdge,disEdgeDepTrackPoint,calcAlgContext);
									}
									initMergingIndiNodeCandIt2 = initMergingIndiNodeCandIt2->getNext();
								}

								distinctInitClashes = createIndividualMergeCausingDescriptors(distinctInitClashes,indiNodeMergeCand,initMergingIndiNodeCandIt->getMergingIndividualLink(),conceptOpLinkerIt,calcAlgContext);
								++disIndiCollCount;

								initMergingIndiNodeCandIt = initMergingIndiNodeCandIt->getNext();
							}

							if (maxDisIndiNodeCandCount > cardinality) {
								distinctInitClashes = createClashedConceptDescriptor(distinctInitClashes,processIndi,conDes,depTrackPoint,calcAlgContext);
								throw CCalculationClashProcessingException(distinctInitClashes);
							}

							if (multipleDistinctInitClashes) {
								branchingMergingProcRest->setMultipleMergingNodesInitializationClashesDescriptors(distinctInitClashes);
							} else {
								branchingMergingProcRest->setMergingNodesInitializationClashesDescriptors(distinctInitClashes);
							}

							branchingMergingProcRest->addMergingInitializationCandidateNodeLinker(maxDisIndiNodeCandLinker);
						} else {
							branchingMergingProcRest->addMergingCandidateNodeLinker(maxDisIndiNodeCandLinker);
						}
					}



					if (firstLink) {
						branchingMergingProcRest->setLastIndividualLink(firstLink);

						//KONCLUCE_TASK_ALGORITHM_BRANCH_STRING_INSTRUCTION(mMergingQueueString = generateDebugMergingQueueString(branchingMergingProcRest,calcAlgContext));
					}

					for (cint64 i = 0; i < 2; ++i) {
						bool qualPosNeg = false;
						CBranchingMergingIndividualNodeCandidateLinker* qualifyPosNegCandLinker = nullptr;
						if (i == 0) {
							qualPosNeg = false;
							qualifyPosNegCandLinker = branchingMergingProcRest->getOnlyPosQualifyCandidateNodeLinker();
						} else {
							qualPosNeg = true;
							qualifyPosNegCandLinker = branchingMergingProcRest->getOnlyNegQualifyCandidateNodeLinker();
						}
						while (qualifyPosNegCandLinker) {
							STATINC(INDINODEQUALIFYCHOOCECOUNT,calcAlgContext);
							CIndividualProcessNode* qualifyIndiNode = qualifyPosNegCandLinker->getMergingIndividualNodeCandidate();
							CIndividualProcessNode* locQualifyIndiNode = getLocalizedIndividual(qualifyIndiNode,true,calcAlgContext);
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							addConceptsToIndividual(conceptOpLinkerIt,qualPosNeg,locQualifyIndiNode,nextDepTrackPoint,true,true,nullptr,calcAlgContext);
							addIndividualToProcessingQueue(locQualifyIndiNode,calcAlgContext);
							if (!qualPosNeg) {
								branchingMergingProcRest->addMergingCandidateNodeLinker(qualifyPosNegCandLinker);
							}
							qualifyPosNegCandLinker = qualifyPosNegCandLinker->getNext();
						}
					}
					branchingMergingProcRest->clearOnlyNegQualifyCandidateNodeLinker();
					branchingMergingProcRest->clearOnlyPosQualifyCandidateNodeLinker();

				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyATLEASTRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(ATLEASTRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinkerIt = concept->getOperandList();

					cint64 cardinality = concept->getParameter() + 1*negate;


					if (cardinality <= 0) {
						return;
					} else if (cardinality == 1) {
						applySOMERule(processIndi,conProDes,false,calcAlgContext);
					}


					if (mConfSatExpCachedSuccAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED | CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED)) {
						STATINC(SATCACHEDABSORBEDGENERATINGCONCEPTSCOUNT,calcAlgContext);
						return addSatisfiableCachedAbsorbedGeneratingConcept(conDes,processIndi,depTrackPoint,calcAlgContext);
					}



					bool alreadyExistSuitableSuccessors = hasDistinctRoleSuccessorConcepts(processIndi,role,conceptOpLinkerIt,false,cardinality,calcAlgContext);
					if (!alreadyExistSuitableSuccessors) {

						if (mConfAtleastAtmostFastClashCheck) {
							CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
							if (conSet) {
								CConceptDescriptor* conDesIt = conSet->getAddingSortedConceptDescriptionLinker();
								while (conDesIt) {
									CConcept* atmostConcept = conDesIt->getData();
									bool conNegated = conDesIt->isNegated();
									cint64 opCode = atmostConcept->getOperatorCode();
									if (!conNegated && (opCode == CCATMOST) || conNegated && (opCode == CCATLEAST)) {
										cint64 param = atmostConcept->getParameter();
										cint64 atmostCardinality = param - 1*conNegated;

										if (atmostCardinality < cardinality && (hasIdenticalConceptOperands(atmostConcept->getOperandList(),conceptOpLinkerIt) || !atmostConcept->getOperandList())) {
											CRole* atmostRole = atmostConcept->getRole();


											CSortedNegLinker<CRole*>* superRoleIt = role->getIndirectSuperRoleList();
											while (superRoleIt) {
												if (!superRoleIt->isNegated()) {
													if (superRoleIt->getData() == atmostRole) {
														CClashedDependencyDescriptor* clashConDesLinker = nullptr;
														clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
														clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDesIt,conDesIt->getDependencyTrackPoint(),calcAlgContext);
														throw CCalculationClashProcessingException(clashConDesLinker);
													}
												}
												superRoleIt = superRoleIt->getNext();
											}
										}
									}
									conDesIt = conDesIt->getNext();
								}
							}
						}

						if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForSuccessorGeneration(conProDes,processIndi)) {
							testIndividualNodeUnsatisfiableCached(processIndi,calcAlgContext);
						}

						++mAppliedATLEASTRuleCount;

						// create dependency
						CDependencyTrackPoint* nextDepTrackPoint = nullptr;
						CATLEASTDependencyNode* atleastDepNode = createATLEASTDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);

						CPROCESSINGLIST<CIndividualProcessNode*> indiList(calcAlgContext->getUsedTaskProcessorContext());
						createDistinctSuccessorIndividuals(processIndi, conDes,indiList,role->getIndirectSuperRoleList(),role,conceptOpLinkerIt,false,nextDepTrackPoint,cardinality,calcAlgContext);

						for (CPROCESSINGLIST<CIndividualProcessNode*>::const_iterator it = indiList.constBegin(), itEnd = indiList.constEnd(); it != itEnd; ++it) {
							STATINC(DISTINCTSUCCESSORINDINODECREATIONCOUNT,calcAlgContext);
							CIndividualProcessNode* succIndi = *it;
							if (processIndi->isNominalIndividualNode() && processIndi->getIndividualNominalLevel() <= 0) {
								succIndi->setExtendedQueueProcessing(true);
							}
							addIndividualToProcessingQueue(succIndi,calcAlgContext);
						}
					}
				}








				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNOMINALRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(NOMINALRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CIndividual* indi = concept->getNominalIndividual();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();


					CIndividualProcessNode* nominalNode = getCorrectedNominalIndividualNode(-indi->getIndividualID(),calcAlgContext);
					if (!negate) {
						if (nominalNode->getIndividualNodeID() != processIndi->getIndividualNodeID()) {

							// force initialized
							CIndividualProcessNode* locNominalNode = getLocalizedForcedBackendInitializedNominalIndividualNode(nominalNode, calcAlgContext);

							markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(locNominalNode, calcAlgContext);

							
							CReapplyConceptLabelSet* locNominalNodeConSet = locNominalNode->getReapplyConceptLabelSet(true);
							CConcept* nominalConcept = indi->getIndividualNominalConcept();
							CConceptDescriptor* nominalConDes = nullptr;
							CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
							if (-indi->getIndividualID() != locNominalNode->getIndividualNodeID()) {
								locNominalNodeConSet->getConceptDescriptor(nominalConcept, nominalConDes, nominalConDepTrackPoint);
							}
							//CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
							//if (-indi->getIndividualID() != locNominalNode->getIndividualNodeID()) {
							//	nominalConDepTrackPoint = locNominalNode->getIndividualMergingHash(true)->value(indi->getIndividualID()).getDependencyTrackPoint();
							//}


							if (processIndi->isBlockableIndividual()) {
								STATINC(INDIBLOCKABLENODENOMINALMERGINGCOUNT, calcAlgContext);
							}
							STATINC(INDINODENOMINALMERGECOUNT, calcAlgContext);
							CClashedDependencyDescriptor* clashDescriptors = nullptr;
							// test if merging is possible
							if (isIndividualNodesMergeable(processIndi, locNominalNode, clashDescriptors, calcAlgContext)) {

								propagateIndividualNodeNominalConnectionStatusToAncestors(processIndi, locNominalNode, calcAlgContext);

								// create dependency
								CDependencyTrackPoint* nextDepTrackPoint = nullptr;
								CNOMINALDependencyNode* nominalDepNode = createNOMINALDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, nominalConDepTrackPoint, calcAlgContext);

								CIndividualProcessNode* mergedNode = getMergedIndividualNodes(processIndi, locNominalNode, nextDepTrackPoint, calcAlgContext);

								//propagateIndividualNodeNeighboursNominalConnectionToAncestors(mergedNode, calcAlgContext);
							} else {
								// clash
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors, processIndi, conDes, depTrackPoint, calcAlgContext);
								if (nominalConDes) {
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locNominalNode, nominalConDes, nominalConDepTrackPoint, calcAlgContext);
								}
								throw CCalculationClashProcessingException(clashDescriptors);
							}
						}
					} else {
						// CHECK: clash check may be incomplete?
						// required for complex query answering (otherwise all nominal concepts must be created upfront)
						bool clashed = false;
						CClashedDependencyDescriptor* clashDescriptors = nullptr;
						if (processIndi->getNominalIndividual() && processIndi->getNominalIndividual()->getIndividualID() == indi->getIndividualID()) {
							clashed = true;
							clashDescriptors = createClashedConceptDescriptor(clashDescriptors, processIndi, conDes, depTrackPoint, calcAlgContext);
							clashDescriptors = createClashedConceptDescriptor(clashDescriptors, nominalNode, nullptr, nominalNode->getDependencyTrackPoint(), calcAlgContext);
						}

						CIndividualMergingHash* indiMergingHash = processIndi->getIndividualMergingHash(false);
						if (indiMergingHash && indiMergingHash->hasMergedIndividual(indi->getIndividualID())) {
							clashed = true;
							const CIndividualMergingHashData& mergingData = indiMergingHash->value(indi->getIndividualID());
							clashDescriptors = createClashedConceptDescriptor(clashDescriptors, processIndi, conDes, depTrackPoint, calcAlgContext);
							clashDescriptors = createClashedConceptDescriptor(clashDescriptors, processIndi, nullptr, mergingData.getDependencyTrackPoint(), calcAlgContext);
						}
						if (clashed) {
							throw CCalculationClashProcessingException(clashDescriptors);
						}


						CIndividualProcessNode* locNominalNode = getLocalizedIndividual(nominalNode, false, calcAlgContext);
						CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
						if (-indi->getIndividualID() != locNominalNode->getIndividualNodeID()) {
							nominalConDepTrackPoint = locNominalNode->getIndividualMergingHash(true)->value(indi->getIndividualID()).getDependencyTrackPoint();
						}


						CDependencyTrackPoint* nextDepTrackPoint = nullptr;
						CNOMINALDependencyNode* nominalDepNode = createNOMINALDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, nominalConDepTrackPoint, calcAlgContext);

						CDistinctEdge* disEdge = CObjectParameterizingAllocator< CDistinctEdge, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
						disEdge->initDistinctEdge(processIndi, locNominalNode, nextDepTrackPoint);

						processIndi->getDistinctHash(true)->insertDistinctIndividual(locNominalNode->getIndividualNodeID(), disEdge);
						locNominalNode->getDistinctHash(true)->insertDistinctIndividual(processIndi->getIndividualNodeID(), disEdge);

					}
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getCorrectedMergedIntoIndividualNode(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					while (indi->hasMergedIntoIndividualNodeID()) {
						cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
						indi = getUpToDateIndividual(mergedIntoID,calcAlgContext);
					}
					return indi;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isNominalIndividualNodeAvailable(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
					return indiProcNodeVec->hasData(indiID);
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getCorrectedNominalIndividualNode(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* indi = getUpToDateIndividual(indiID,calcAlgContext);
					if (indi) {
						while (indi->hasMergedIntoIndividualNodeID()) {
							STATINC(INDINODENOMINALCORRECTIDCOUNT,calcAlgContext);
							cint64 mergedIntoID = indi->getMergedIntoIndividualNodeID();
							indi = getUpToDateIndividual(mergedIntoID,calcAlgContext);
							// TODO: path compression? -> update merged into IDs
						}
					} else {
						// throw error
						throw CCalculationErrorProcessingException::getNominalMissingErrorException();
					}
					return indi;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::applyALLRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(ALLRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();


					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					if (restLink) {
						++mAppliedALLRuleCount;
						STATINC(ALLROLERESTRICTIONCOUNT,calcAlgContext);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,restLink,calcAlgContext);
						if (!isRestrictedTopObjectPropertyPropagation(processIndi, succIndi, concept, negate, calcAlgContext)) {

							CIndividualProcessNode* locSuccIndi = nullptr;
							CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);

							// create dependency
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CALLDependencyNode* allDepNode = nullptr;
							bool allDepNodeCreated = false;

							CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker;
							while (conceptOpLinkerIt) {
								CConcept* opConcept = conceptOpLinkerIt->getData();
								bool opConNeg = conceptOpLinkerIt->isNegated() ^ negate;
								if (!conLabelSet->hasConcept(opConcept,opConNeg)) {
									// add concept
									if (!allDepNodeCreated) {
										allDepNodeCreated = true;
										allDepNode = createALLDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,restLink->getDependencyTrackPoint(),calcAlgContext);
									}
									if (!locSuccIndi) {
										locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
										conLabelSet = locSuccIndi->getReapplyConceptLabelSet(true);
									}
									addConceptToIndividual(opConcept,opConNeg,locSuccIndi,nextDepTrackPoint,true,true,calcAlgContext);
								}
								conceptOpLinkerIt = conceptOpLinkerIt->getNext();
							}
							if (locSuccIndi) {
								addIndividualToProcessingQueue(locSuccIndi,calcAlgContext);
							}
						}
					} else {
						CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
						if (roleSuccHash) {
							CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
							while (roleSuccIt.hasNext()) {
								++mAppliedALLRuleCount;
								STATINC(ALLROLERESTRICTIONCOUNT,calcAlgContext);
								CIndividualLinkEdge* link = roleSuccIt.next(true);
								CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
								if (!isRestrictedTopObjectPropertyPropagation(processIndi, succIndi, concept, negate, calcAlgContext)) {
									CIndividualProcessNode* locSuccIndi = nullptr;
									CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);

									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									CALLDependencyNode* allDepNode = nullptr;
									bool allDepNodeCreated = false;

									CSortedNegLinker<CConcept*>* conceptOpLinkerIt = conceptOpLinker;
									while (conceptOpLinkerIt) {
										CConcept* opConcept = conceptOpLinkerIt->getData();
										bool opConNeg = conceptOpLinkerIt->isNegated() ^ negate;
										if (!conLabelSet->hasConcept(opConcept,opConNeg)) {
											// add concept
											if (!allDepNodeCreated) {
												allDepNodeCreated = true;
												allDepNode = createALLDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,link->getDependencyTrackPoint(),calcAlgContext);
											}
											if (!locSuccIndi) {
												locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
												conLabelSet = locSuccIndi->getReapplyConceptLabelSet(true);
											}
											addConceptToIndividual(opConcept,opConNeg,locSuccIndi,nextDepTrackPoint,true,true,calcAlgContext);
										}
										conceptOpLinkerIt = conceptOpLinkerIt->getNext();
									}
									if (locSuccIndi) {
										addIndividualToProcessingQueue(locSuccIndi,calcAlgContext);
									}
								}
							}
						}
					}
					if (!conProDes->isConceptReapplied()) {
						addConceptToReapplyQueue(conDes,role,processIndi,true,depTrackPoint,calcAlgContext);
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::initializeORProcessing(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CBranchingORProcessingRestrictionSpecification** plannedBranchingProcessRestriction, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();

					CConceptProcessPriority disjunctionDefaultPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(conDes, processIndi);


					if (conProDes->getProcessPriority().getPriority() >= mDeterministicProcessPriority && conProDes->getProcessPriority().getPriority() >= disjunctionDefaultPriority.getPriority()) {
						CConceptProcessData* conProData = (CConceptProcessData*)concept->getConceptData();
						if (conProData) {
							CConcept* impConcept = nullptr;
							CReplacementData* repData = conProData->getReplacementData();
							CXNegLinker<CConcept*>* commDisConLinker = nullptr;
							if (repData) {
								impConcept = repData->getImplicationReplacementConcept();
								commDisConLinker = repData->getCommonDisjunctConceptLinker();
							}
							if (commDisConLinker) {
								addConceptsToIndividual(commDisConLinker,false,processIndi,depTrackPoint,true,false,nullptr,calcAlgContext);
							}
							if (impConcept) {
								STATINC(ORREPLACEMENTIMPLICATIONCOUNT,calcAlgContext);
								addConceptToIndividual(impConcept,false,processIndi,depTrackPoint,true,false,calcAlgContext);
								return true;
							}
						}

						CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
						double priorityOffset = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityOffsetForDisjunctionDelayedConsidering(conDes,processIndi);
						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,true,nullptr,priorityOffset,calcAlgContext);
						return true;
					}
					return false;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasSaturatedClashedFlagForConcept(CConcept* concept, bool negation, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptData* conceptData = concept->getConceptData();
					CIndividualSaturationProcessNode* saturationIndiNode = nullptr;
					if (conceptData) {
						CConceptProcessData* conProcData = (CConceptProcessData*)conceptData;
						CConceptReferenceLinking* conRefLinking = conProcData->getConceptReferenceLinking();
						if (conRefLinking) {
							CConceptSaturationReferenceLinkingData* confSatRefLinkingData = (CConceptSaturationReferenceLinkingData*)conRefLinking;
							CSaturationConceptReferenceLinking* satCalcRefLinkData = confSatRefLinkingData->getConceptSaturationReferenceLinkingData(negation);
							if (satCalcRefLinkData) {
								saturationIndiNode = (CIndividualSaturationProcessNode*)satCalcRefLinkData->getIndividualProcessNodeForConcept();
							}
						}
					}

					if (saturationIndiNode) {
						if (saturationIndiNode->getIndirectStatusFlags()->hasClashedFlag()) {
							return true;
						}
					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::getAdditionalDisjunctCheckingConcept(CConcept* opConcept, bool opConNegation, CConcept** checkingConcept, bool* checkingNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (opConcept->getOperatorCode() == CCAQCHOOCE) {
						cint64 replaceCount = 0;
						CConcept* replaceCheckingConcept = nullptr;
						CSortedNegLinker<CConcept*>* opConceptOpLinkerIt = opConcept->getOperandList();
						while (opConceptOpLinkerIt) {
							CConcept* opOpConcept = opConceptOpLinkerIt->getData();
							bool opOpNegation = opConceptOpLinkerIt->isNegated();
							if (opOpNegation == opConNegation) {
								replaceCheckingConcept = opOpConcept;
								replaceCount++;
							}
							opConceptOpLinkerIt = opConceptOpLinkerIt->getNext();
						}

						if (replaceCount == 1 && replaceCheckingConcept) {
							if (checkingNegation) {
								*checkingNegation = false;
							}
							if (checkingConcept) {
								*checkingConcept = replaceCheckingConcept;
							}
							return true;
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::planORProcessing(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CBranchingORProcessingRestrictionSpecification** plannedBranchingProcessRestriction, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CProcessingRestrictionSpecification* procRest = conProDes->getProcessingRestrictionSpecification();


					if (initializeORProcessing(processIndi,conProDes,negate,plannedBranchingProcessRestriction,calcAlgContext)) {
						return true;
					}

					// plan OR processing
					if (!procRest) {
						STATINC(OREXECUTIONINITCOUNT,calcAlgContext);
						// concept is processed first time
						CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

						CSortedNegLinker<CConcept*>* firstNotPosAndNegContainedOperand = nullptr;
						CSortedNegLinker<CConcept*>* secondNotPosAndNegContainedOperand = nullptr;
						CSortedNegLinker<CConcept*>* containedOperand = nullptr;
						CDisjunctBranchingStatistics* firstNotPosAndNegContainedOperandBranchStats = nullptr;
						CDisjunctBranchingStatistics* secondNotPosAndNegContainedOperandBranchStats = nullptr;

						CClashedDependencyDescriptor* clashConDesLinker = nullptr;

						CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
						CDisjunctBranchingStatistics* disjunctBranchStats = nullptr;
						CConceptProcessData* conProcData = (CConceptProcessData*)concept->getConceptData();
						if (conProcData) {
							CDisjunctionBranchingStatistics* disjunctionBranchStats = (CDisjunctionBranchingStatistics*)conProcData->getBranchingStatistics();
							if (disjunctionBranchStats) {
								disjunctBranchStats = disjunctionBranchStats->getDisjunctBranchingStatistics();
							}
						}
						while (opLinker && !containedOperand) {
							CConcept* opConcept = opLinker->getData();
							bool opConNegation = opLinker->isNegated() ^ negate;
							bool containsNegation = false;

							bool opCheckingNegation = opConNegation;
							CConcept* opCheckingConcept = opConcept;

							CConceptDescriptor* containedConDes = nullptr;
							CDependencyTrackPoint* containedConDepTrackPoint = nullptr;
							bool contains = conSet->getConceptDescriptor(opCheckingConcept,containedConDes,containedConDepTrackPoint);
							if (!contains && getAdditionalDisjunctCheckingConcept(opCheckingConcept, opCheckingNegation, &opCheckingConcept, &opCheckingNegation, calcAlgContext)) {
								contains = conSet->getConceptDescriptor(opCheckingConcept, containedConDes, containedConDepTrackPoint);
							}
							if (!contains) {
								if (!hasSaturatedClashedFlagForConcept(opCheckingConcept, opCheckingNegation,calcAlgContext)) {
									if (!firstNotPosAndNegContainedOperand) {
										firstNotPosAndNegContainedOperand = opLinker;
										firstNotPosAndNegContainedOperandBranchStats = disjunctBranchStats;
									} else if (!secondNotPosAndNegContainedOperand) {
										secondNotPosAndNegContainedOperand = opLinker;
										secondNotPosAndNegContainedOperandBranchStats = disjunctBranchStats;
									}
								}
							} else {
								containsNegation = containedConDes->isNegated();
								if (containsNegation == opCheckingNegation) {
									containedOperand = opLinker;
								} else {
									clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,containedConDes,containedConDepTrackPoint,calcAlgContext);
								}
							}
							opLinker = opLinker->getNext();
							if (disjunctBranchStats) {
								disjunctBranchStats = disjunctBranchStats->getNext();
							}
						}


						if (containedOperand || !secondNotPosAndNegContainedOperand) {
							STATINC(ORINSTANTCONTAINSEXECUTEDCOUNT,calcAlgContext);
							// only one branch is applicable, execute OR rule
							if (plannedBranchingProcessRestriction) {
								CBranchingORProcessingRestrictionSpecification* branchORProcRest = CObjectAllocator< CBranchingORProcessingRestrictionSpecification >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								branchORProcRest->initBranchingORProcessingRestriction();
								branchORProcRest->setContainedOperand(containedOperand);
								branchORProcRest->setFirstNotPosAndNegContainedOperand(firstNotPosAndNegContainedOperand);
								branchORProcRest->setSecondNotPosAndNegContainedOperand(secondNotPosAndNegContainedOperand);
								branchORProcRest->setFirstNotPosAndNegContainedOperandBranchingStatistics(firstNotPosAndNegContainedOperandBranchStats);
								branchORProcRest->setSecondNotPosAndNegContainedOperandBranchingStatistics(secondNotPosAndNegContainedOperandBranchStats);
								branchORProcRest->addClashedConceptDescriptors(clashConDesLinker);
								*plannedBranchingProcessRestriction = branchORProcRest;
							}
							return false;
						} else {
							// try to trigger branching

							CConceptProcessData* conProcessData = (CConceptProcessData*)concept->getConceptData();
							CConceptRoleBranchingTrigger* conRoleBranchTriggerLinkerIt = nullptr;
							CConceptRoleBranchingTrigger* nextConRoleBranchTriggerLinkerIt = nullptr;
							CBranchingORProcessingRestrictionSpecification* branchORProcRest = CObjectAllocator< CBranchingORProcessingRestrictionSpecification >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
							branchORProcRest->initBranchingORProcessingRestriction();
							branchORProcRest->setFirstNotPosAndNegContainedOperand(firstNotPosAndNegContainedOperand);
							branchORProcRest->setSecondNotPosAndNegContainedOperand(secondNotPosAndNegContainedOperand);
							branchORProcRest->setFirstNotPosAndNegContainedOperandBranchingStatistics(firstNotPosAndNegContainedOperandBranchStats);
							branchORProcRest->setSecondNotPosAndNegContainedOperandBranchingStatistics(secondNotPosAndNegContainedOperandBranchStats);
							branchORProcRest->addClashedConceptDescriptors(clashConDesLinker);
							if (conProcessData) {
								if (mConfBranchTriggering) {
									conRoleBranchTriggerLinkerIt = conProcessData->getConceptRoleBranchTrigger();
								}
							}
							if (conRoleBranchTriggerLinkerIt) {
								// search trigger
								STATINC(ORTRIGGERSEARCHCOUNT,calcAlgContext);
								conRoleBranchTriggerLinkerIt = searchNextConceptRoleBranchTrigger(processIndi,conRoleBranchTriggerLinkerIt,calcAlgContext);
							}
							if (conRoleBranchTriggerLinkerIt) {
								// install trigger
								STATINC(ORTRIGGEREDDELAYEDEXECUTEDCOUNT,calcAlgContext);
								nextConRoleBranchTriggerLinkerIt = conRoleBranchTriggerLinkerIt->getNextBranchingTrigger();
								branchORProcRest->setConceptRoleBranchingTrigger(nextConRoleBranchTriggerLinkerIt);
								installConceptRoleBranchTrigger(processIndi,conDes,depTrackPoint,branchORProcRest,conRoleBranchTriggerLinkerIt,calcAlgContext);
								return true;
							} else {
								// branch triggering is not anymore possible, determine priority for this OR branch
								// determine additional OR priority offset
								STATINC(ORQUEUEDDELAYEDEXECUTEDCOUNT,calcAlgContext);
								double priorityOffset = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityOffsetForDisjunctionDelayedProcessing(conDes,processIndi);
								branchORProcRest->setPriorityOffset(priorityOffset);
								CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
								addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,true,branchORProcRest,priorityOffset,calcAlgContext);
								return true;
							}
						} 

					} else {
						STATINC(OREXECUTIONCONTINUECOUNT,calcAlgContext);
						// OR branching concept has already been considered before
						// try triggering again
						CBranchingORProcessingRestrictionSpecification* branchORProcRest = (CBranchingORProcessingRestrictionSpecification*)procRest;
						if (branchORProcRest->getContainedOperand() || !branchORProcRest->getSecondNotPosAndNegContainedOperand()) {
							*plannedBranchingProcessRestriction = branchORProcRest;
							return false;
						}
						CConceptRoleBranchingTrigger* conRoleBranchTriggerLinkerIt = branchORProcRest->getConceptRoleBranchingTrigger();
						CConceptRoleBranchingTrigger* nextConRoleBranchTriggerLinkerIt = nullptr;
						if (!conRoleBranchTriggerLinkerIt) {
							// OR branch was not triggered, execute OR rule
							if (plannedBranchingProcessRestriction) {
								*plannedBranchingProcessRestriction = branchORProcRest;
							}
							return false;
						} else {
							// search trigger
							STATINC(ORTRIGGERSEARCHCOUNT,calcAlgContext);
							conRoleBranchTriggerLinkerIt = searchNextConceptRoleBranchTrigger(processIndi,conRoleBranchTriggerLinkerIt,calcAlgContext);
						}
						CBranchingORProcessingRestrictionSpecification* nextBranchORProcRest = CObjectAllocator< CBranchingORProcessingRestrictionSpecification >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						nextBranchORProcRest->initBranchingORProcessingRestriction(branchORProcRest);
						if (conRoleBranchTriggerLinkerIt) {
							// install trigger
							STATINC(ORTRIGGEREDDELAYEDEXECUTEDCOUNT,calcAlgContext);
							nextConRoleBranchTriggerLinkerIt = conRoleBranchTriggerLinkerIt->getNextBranchingTrigger();
							nextBranchORProcRest->setConceptRoleBranchingTrigger(nextConRoleBranchTriggerLinkerIt);
							installConceptRoleBranchTrigger(processIndi,conDes,depTrackPoint,nextBranchORProcRest,conRoleBranchTriggerLinkerIt,calcAlgContext);
							return true;
						} else {
							STATINC(ORQUEUEDDELAYEDEXECUTEDCOUNT,calcAlgContext);
							double priorityOffset = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityOffsetForDisjunctionDelayedProcessing(conDes,processIndi);
							nextBranchORProcRest->setPriorityOffset(priorityOffset);
							nextBranchORProcRest->setConceptRoleBranchingTrigger(nullptr);
							CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
							addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,true,nextBranchORProcRest,priorityOffset,calcAlgContext);
							return true;
						}
					}
				}
				



				CNonDeterministicDependencyTrackPoint* CCalculationTableauCompletionTaskHandleAlgorithm::createNonDeterministicDependencyTrackPointBranch(CNonDeterministicDependencyNode* dependencyNode, bool singleBranch, CCalculationAlgorithmContextBase* calcAlgContext) {
					CNonDeterministicDependencyTrackPoint* nonDepTrackPoint = nullptr;
					if (mConfBuildDependencies && dependencyNode) {
						if (singleBranch || mConfBuildAllBranchingNodes) {
							CBranchTreeNode* branchNode = calcAlgContext->getNewBranchTreeNode();
							nonDepTrackPoint = dependencyNode->getDependencyTrackPointBranch();
							branchNode->branchingIncrement(nonDepTrackPoint);
							nonDepTrackPoint->initBranch(branchNode);
						} else {
							CBranchTreeNode* branchNode = calcAlgContext->getUsedBranchTreeNode();
							nonDepTrackPoint = dependencyNode->getDependencyTrackPointBranch();
							branchNode->branchingIncrement(nonDepTrackPoint);
							nonDepTrackPoint->initBranch(branchNode);
						}
					}
					return nonDepTrackPoint;
				}




				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createIndividualMergeCausingDescriptors(CClashedDependencyDescriptor* prevClashes, CIndividualProcessNode*& processIndi, CIndividualLinkEdge* link, CSortedNegLinker<CConcept*>* conceptAddLinker, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = prevClashes;
					
					if (link->getDependencyTrackPoint() != processIndi->getDependencyTrackPoint()) {
						clashDes = createClashedIndividualLinkDescriptor(clashDes,link,link->getDependencyTrackPoint(),calcAlgContext);
					}

					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CSortedNegLinker<CConcept*>* conceptAddLinkerIt = conceptAddLinker;
					while (conceptAddLinkerIt) {
						CConcept* concept = conceptAddLinkerIt->getData();
						bool conNegation = conceptAddLinkerIt->isNegated();

						CConceptDescriptor* containedConDes = nullptr;
						CDependencyTrackPoint* containedDepTrackPoint = nullptr;
						conSet->getConceptDescriptor(concept,containedConDes,containedDepTrackPoint);

						clashDes = createClashedConceptDescriptor(clashDes,processIndi,containedConDes,containedDepTrackPoint,calcAlgContext);

						conceptAddLinkerIt = conceptAddLinkerIt->getNext();
					}
					return clashDes;
				}



				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createClashedConceptDescriptor(CClashedDependencyDescriptor* prevClashes, CIndividualProcessNode*& processIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = calcAlgContext->getClashDescriptorFactory()->createClashedConceptDescriptor(prevClashes,processIndi,conDes,prevDepTrackPoint,calcAlgContext);
					return clashDes;
				}

				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createClashedIndividualLinkDescriptor(CClashedDependencyDescriptor* prevClashes, CIndividualLinkEdge* link, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = calcAlgContext->getClashDescriptorFactory()->createClashedIndividualLinkDescriptor(prevClashes,link,prevDepTrackPoint,calcAlgContext);
					return clashDes;
				}

				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createClashedIndividualDistinctDescriptor(CClashedDependencyDescriptor* prevClashes, CDistinctEdge* distinct, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = calcAlgContext->getClashDescriptorFactory()->createClashedIndividualDistinctDescriptor(prevClashes,distinct,prevDepTrackPoint,calcAlgContext);
					return clashDes;
				}

				CClashedDependencyDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createClashedNegationDisjointDescriptor(CClashedDependencyDescriptor* prevClashes, CNegationDisjointEdge* disjointNegLink, CDependencyTrackPoint* prevDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CClashedDependencyDescriptor* clashDes = calcAlgContext->getClashDescriptorFactory()->createClashedNegationDisjointDescriptor(prevClashes,disjointNegLink,prevDepTrackPoint,calcAlgContext);
					return clashDes;
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::executeORBranching(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CBranchingORProcessingRestrictionSpecification* plannedBranchingProcessRestriction, CCalculationAlgorithmContextBase* calcAlgContext) {
					++mAppliedORRuleCount;
					STATINC(OREXECUTIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);

					CSortedNegLinker<CConcept*>* containedOperand = nullptr;
					CSortedNegLinker<CConcept*>* firstNotPosAndNegContainedOperand = nullptr;
					CSortedNegLinker<CConcept*>* secondNotPosAndNegContainedOperand = nullptr;
					CDisjunctBranchingStatistics* firstNotPosAndNegContainedOperandBranchStats = nullptr;
					CDisjunctBranchingStatistics* secondNotPosAndNegContainedOperandBranchStats = nullptr;

					CPROCESSINGLIST< CSortedNegLinker<CConcept*>* > notContainedOperandsList(calcAlgContext->getUsedTaskProcessorContext());
					CPROCESSINGLIST< CDisjunctBranchingStatistics* > notContainedBranchingStatsList(calcAlgContext->getUsedTaskProcessorContext());

					cint64 notPosAndNegContainedOperandCount = 0;
					if (plannedBranchingProcessRestriction) {
						containedOperand = plannedBranchingProcessRestriction->getContainedOperand();
						firstNotPosAndNegContainedOperand = plannedBranchingProcessRestriction->getFirstNotPosAndNegContainedOperand();
						secondNotPosAndNegContainedOperand = plannedBranchingProcessRestriction->getSecondNotPosAndNegContainedOperand();
						firstNotPosAndNegContainedOperandBranchStats = plannedBranchingProcessRestriction->getFirstNotPosAndNegContainedOperandBranchingStatistics();
						secondNotPosAndNegContainedOperandBranchStats = plannedBranchingProcessRestriction->getSecondNotPosAndNegContainedOperandBranchingStatistics();
					}

					CClashedDependencyDescriptor* clashConDesLinker = plannedBranchingProcessRestriction->getClashedConceptDescriptors();

					if (!containedOperand) {
						// check if one operand is already in the concept set
						if (firstNotPosAndNegContainedOperand) {
							bool containsNegation = false;
							bool correctNegation = firstNotPosAndNegContainedOperand->isNegated() ^ negate;
							CConceptDescriptor* containedConDes = nullptr;
							CDependencyTrackPoint* containedConDepTrackPoint = nullptr;
							bool opCheckingNegation = correctNegation;
							CConcept* checkingConcept = firstNotPosAndNegContainedOperand->getData();
							bool contains = conSet->getConceptDescriptor(checkingConcept,containedConDes,containedConDepTrackPoint);
							if (!contains && getAdditionalDisjunctCheckingConcept(checkingConcept, opCheckingNegation, &checkingConcept, &opCheckingNegation, calcAlgContext)) {
								contains = conSet->getConceptDescriptor(checkingConcept, containedConDes, containedConDepTrackPoint);
							}
							if (contains) {
								containsNegation = containedConDes->isNegated();
								if (containsNegation == opCheckingNegation) {
									containedOperand = firstNotPosAndNegContainedOperand;
									// update first/second not contained operands
									firstNotPosAndNegContainedOperand = secondNotPosAndNegContainedOperand;
									firstNotPosAndNegContainedOperandBranchStats = secondNotPosAndNegContainedOperandBranchStats;
								} else {
									firstNotPosAndNegContainedOperand = nullptr;
									clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,containedConDes,containedConDepTrackPoint,calcAlgContext);
								}
							} else {
								++notPosAndNegContainedOperandCount;								
								notContainedOperandsList.append(firstNotPosAndNegContainedOperand);
								notContainedBranchingStatsList.append(firstNotPosAndNegContainedOperandBranchStats);
							}
							if (!containedOperand && secondNotPosAndNegContainedOperand) {
								bool remainingDisjunctsUseless = false;
								CSortedNegLinker<CConcept*>* containsOperandCheckIt = secondNotPosAndNegContainedOperand;
								CDisjunctBranchingStatistics* disjunctBranchStatsCheckIt = secondNotPosAndNegContainedOperandBranchStats;
								secondNotPosAndNegContainedOperand = nullptr;
								while (containsOperandCheckIt) {
									bool containsNegation = false;
									bool correctNegation = containsOperandCheckIt->isNegated() ^ negate;
									CConceptDescriptor* containedConDes = nullptr;
									CDependencyTrackPoint* containedConDepTrackPoint = nullptr;
									bool opCheckingNegation = correctNegation;
									CConcept* checkingConcept = containsOperandCheckIt->getData();
									bool contains = conSet->getConceptDescriptor(checkingConcept, containedConDes, containedConDepTrackPoint);
									if (!contains && getAdditionalDisjunctCheckingConcept(checkingConcept, opCheckingNegation, &checkingConcept, &opCheckingNegation, calcAlgContext)) {
										contains = conSet->getConceptDescriptor(checkingConcept, containedConDes, containedConDepTrackPoint);
									}
									if (contains) {
										containsNegation = containedConDes->isNegated();
										if (containsNegation == opCheckingNegation) {
											containedOperand = containsOperandCheckIt;
											break;
										} else {
											clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,containedConDes,containedConDepTrackPoint,calcAlgContext);
										}
									} else {
										if (!hasSaturatedClashedFlagForConcept(checkingConcept, opCheckingNegation,calcAlgContext)) {
											bool criticalWithOtherOperand = false;
											if (remainingDisjunctsUseless) {
												criticalWithOtherOperand = true;
											}
											for (CPROCESSINGLIST< CSortedNegLinker<CConcept*>* >::const_iterator opIt = notContainedOperandsList.constBegin(), opItEnd = notContainedOperandsList.constEnd(); opIt != opItEnd && !criticalWithOtherOperand; ++opIt) {
												CSortedNegLinker<CConcept*>* notContOpLinker = *opIt;
												if (containsOperandCheckIt->getData() == notContOpLinker->getData()) {
													if (containsOperandCheckIt->isNegated() == notContOpLinker->isNegated()) {
														criticalWithOtherOperand = true;
													} else {
														remainingDisjunctsUseless = true;
													}
												}
											}

											if (!criticalWithOtherOperand) {
												++notPosAndNegContainedOperandCount;
												notContainedOperandsList.append(containsOperandCheckIt);
												notContainedBranchingStatsList.append(disjunctBranchStatsCheckIt);
												// update first/second not contained operands
												if (!firstNotPosAndNegContainedOperand) {
													firstNotPosAndNegContainedOperand = containsOperandCheckIt;
													firstNotPosAndNegContainedOperandBranchStats = disjunctBranchStatsCheckIt;
												} else {
													if (!secondNotPosAndNegContainedOperand) {
														secondNotPosAndNegContainedOperand = containsOperandCheckIt;
														secondNotPosAndNegContainedOperandBranchStats = disjunctBranchStatsCheckIt;
													}
												}
											}
										}
									}
									containsOperandCheckIt = containsOperandCheckIt->getNext();
									if (disjunctBranchStatsCheckIt) {
										disjunctBranchStatsCheckIt = disjunctBranchStatsCheckIt->getNext();
									}
								}
							}
						}
					}


					if (!containedOperand) {
						// collect clashes
						// do branching


						if (notPosAndNegContainedOperandCount == 1) {
							STATINC(ORSINGLEBRANCHCOUNT,calcAlgContext);

							CDependency* dependencies = nullptr;

							for (CClashedDependencyDescriptor* clashConDesLinkerIt = clashConDesLinker; clashConDesLinkerIt; clashConDesLinkerIt = clashConDesLinkerIt->getNext()) {
								CClashedConceptDescriptor* clashedConDes = (CClashedConceptDescriptor*)clashConDesLinkerIt;
								CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi, clashedConDes->getConceptDescriptor(), clashConDesLinkerIt->getDependencyTrackPoint(), calcAlgContext);
								dependencies = connDep->append(dependencies);
							}

							CDependencyTrackPoint* newDependencyTrackPoint = nullptr;
							CORONLYOPTIONDependencyNode* orDependencyNode = createORONLYOPTIONDependency(newDependencyTrackPoint, processIndi, conDes, depTrackPoint, dependencies, calcAlgContext);

							CPROCESSINGLIST< CSortedNegLinker<CConcept*>* >::const_iterator opIt = notContainedOperandsList.constBegin();
							CPROCESSINGLIST< CDisjunctBranchingStatistics* >::const_iterator disjBranchStatIt = notContainedBranchingStatsList.constBegin();
							CSortedNegLinker<CConcept*>* operandConcept = *opIt;
							CDisjunctBranchingStatistics* disjBranchStats = nullptr;
							if (notContainedOperandsList.count() == notContainedBranchingStatsList.count()) {
								disjBranchStats = *disjBranchStatIt;
							}
							//if (newDependencyTrackPoint) {
							//	newDependencyTrackPoint->setDisjunctConceptLinker(operandConcept);
							//	newDependencyTrackPoint->setDisjunctBranchingStatistics(disjBranchStats);
							//}
							bool addOpNegated = operandConcept->isNegated() ^ negate;
							addConceptToIndividual(operandConcept->getData(), addOpNegated, processIndi, newDependencyTrackPoint, true, false, calcAlgContext);

							if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForBranchedDisjuncts(conProDes,processIndi,operandConcept)) {
								testIndividualNodeUnsatisfiableCached(processIndi,calcAlgContext);
							}


						} else if (notPosAndNegContainedOperandCount > 1) {
							STATINC(ORMULTIPLEBRANCHCOUNT,calcAlgContext);

							if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForDisjunctionBranching(conProDes, processIndi, &notContainedOperandsList)) {
								testIndividualNodeUnsatisfiableCached(processIndi, calcAlgContext);
							}


							CORDependencyNode* orDependencyNode = createORDependency(processIndi, conDes, depTrackPoint, calcAlgContext);
							if (orDependencyNode && clashConDesLinker) {
								orDependencyNode->addBranchClashes(clashConDesLinker);
							}


							CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(notPosAndNegContainedOperandCount,calcAlgContext);
							CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();

							// semantic branching
							CPROCESSINGLIST< CSortedNegLinker<CConcept*>* >::const_iterator branchOpConIt = notContainedOperandsList.constBegin();
							CPROCESSINGLIST< CDisjunctBranchingStatistics* >::const_iterator disjBranchStatIt = notContainedBranchingStatsList.constBegin();
							CSatisfiableCalculationTask* newTaskIt = newTaskList;
							cint64 branchNumber = 1;
							while (newTaskIt) {

								CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;
								CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);

								CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext,newProcessContext,newSatCalcTask);
								CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

								CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
								newProcessTagger->incBranchingTag();
								newProcessTagger->incLocalizationTag();

								CSortedNegLinker<CConcept*>* addingConceptLinker = nullptr;
								//CIndividualProcessNode* newLocIndiNode = getLocalizedIndividual(processIndi,false,newCalcAlgContext);
								//CConceptProcessingQueue* newConProcQueue = newLocIndiNode->getConceptProcessingQueue(true);

								CORDisjunctDependencyTrackPoint* newDependencyTrackPoint = (CORDisjunctDependencyTrackPoint*)createNonDeterministicDependencyTrackPointBranch(orDependencyNode,false,newCalcAlgContext);

								CSortedNegLinker<CConcept*>* branchingOperandConcept = nullptr;
								CPROCESSINGLIST< CSortedNegLinker<CConcept*>* >::const_iterator opIt = notContainedOperandsList.constBegin();
								do {
									STATINC(TASKORBRANCHCREATIONCOUNT,calcAlgContext);

									CSortedNegLinker<CConcept*>* operandConcept = *opIt;
									bool posOperand = (opIt == branchOpConIt);
									if (posOperand) {
										branchingOperandConcept = operandConcept;
									}

									bool addOpNegated = !posOperand ^ operandConcept->isNegated() ^ negate;

									if (posOperand || mConfSemanticBranching || mConfAtomicSemanticBranching && isConceptAdditionAtomaric(operandConcept->getData(),addOpNegated,newCalcAlgContext)) {
										CSortedNegLinker<CConcept*>* tmpAddingConceptLinker = CObjectAllocator< CSortedNegLinker<CConcept*> >::allocateAndConstruct(newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager());
										tmpAddingConceptLinker->init(operandConcept->getData(),addOpNegated);
										addingConceptLinker = tmpAddingConceptLinker->append(addingConceptLinker);
										//addConceptToIndividual(operandConcept->getData(),addOpNegated,newLocIndiNode,newDependencyTrackPoint,false,true,newCalcAlgContext);
									}


								} while (opIt++ != branchOpConIt);
								++branchOpConIt;

								CDisjunctBranchingStatistics* disjBranchStats = nullptr;
								if (notContainedOperandsList.count() == notContainedBranchingStatsList.count()) {
									disjBranchStats = *disjBranchStatIt;
									++disjBranchStatIt;
								}


								if (newDependencyTrackPoint) {
									newDependencyTrackPoint->setDisjunctConceptLinker(branchingOperandConcept);
									newDependencyTrackPoint->setDisjunctBranchingStatistics(disjBranchStats);
								}

								//if (calcAlgContext->getUsedUnsatisfiableCacheRetrievalStrategy()->testUnsatisfiableCacheForBranchedDisjuncts(conProDes,processIndi,branchingOperandConcept)) {
								//	addIndividualNodeForCacheUnsatisfiableRetrieval(newLocIndiNode,newCalcAlgContext);
								//}
								//prepareBranchedTaskProcessing(newLocIndiNode,newTaskIt,newCalcAlgContext);
								
								CBranchingInstructionAddIndividualConcepts* branchingInstruction = CObjectAllocator< CBranchingInstructionAddIndividualConcepts >::allocateAndConstruct(newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								branchingInstruction->initAddIndividualConceptsBranchingInstruction(processIndi,addingConceptLinker,newDependencyTrackPoint);
								newProcessingDataBox->setBranchingInstruction(branchingInstruction);


								// set new task priority
								double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskBranching(newSatCalcTask,calcAlgContext->getUsedSatisfiableCalculationTask(),processIndi,conDes,branchingOperandConcept,branchNumber,disjBranchStats);
								newSatCalcTask->setTaskPriority(newTaskPriority);

								++branchNumber;
								newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();
							}

							processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

							throw CCalculationStopProcessingException(true);
						} else {
							// throw clash
							clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
							throw CCalculationClashProcessingException(clashConDesLinker);
						}

					} else {
						// contains at least one operand, branching is not necessary, ignoring or concept
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptAdditionAtomaric(CConcept* addingConcept, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 opCode = addingConcept->getOperatorCode();
					if (negated && (opCode == CCSUB || opCode == CCIMPLTRIG) || opCode == CCATOM) {
						return true;
					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyORRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(ORRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();

					cint64 opCount = concept->getOperandCount();

					if (opCount <= 0) {

						// throw clash
						CClashedDependencyDescriptor* clashConDesLinker = nullptr;
						clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conDes,depTrackPoint,calcAlgContext);
						throw CCalculationClashProcessingException(clashConDesLinker);

					} else if (opCount == 1) {
						// apply AND rule
						applyANDRule(processIndi,conProDes,negate,calcAlgContext);
					} else {
						CBranchingORProcessingRestrictionSpecification* plannedBranchingProcessRestriction = nullptr;
						if (!planORProcessing(processIndi,conProDes,negate,&plannedBranchingProcessRestriction,calcAlgContext)) {
							if (mConfSatExpCachedDisjAbsorp && processIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
								STATINC(SATCACHEDABSORBEDDISJUNCTIONCONCEPTSCOUNT,calcAlgContext);
								addSatisfiableCachedAbsorbedDisjunctionConcept(conDes,processIndi,plannedBranchingProcessRestriction,depTrackPoint,calcAlgContext);
							} else {
								// delaying failed, execute OR rule
								executeORBranching(processIndi,conProDes,negate,plannedBranchingProcessRestriction,calcAlgContext);
							}
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(IMPLICATIONRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CProcessingRestrictionSpecification* procRest = conProDes->getProcessingRestrictionSpecification();
					cint64 opCount = concept->getOperandCount();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
					CTriggeredImplicationProcessingRestrictionSpecification* triggImpProcRes = nullptr;
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					if (!procRest) {
						triggImpProcRes = CObjectAllocator< CTriggeredImplicationProcessingRestrictionSpecification >::allocateAndConstruct(taskMemMan);
						triggImpProcRes->setConceptImplicationTrigger(opLinker->getNext());

					} else {
						CTriggeredImplicationProcessingRestrictionSpecification* lastTriggImpProcRes = (CTriggeredImplicationProcessingRestrictionSpecification*)procRest;
						triggImpProcRes = CObjectAllocator< CTriggeredImplicationProcessingRestrictionSpecification >::allocateAndConstruct(taskMemMan);
						triggImpProcRes->initImplicationTriggeringProcessingRestriction(lastTriggImpProcRes);
					}

					// search next not existing trigger
					bool allTriggersAvailable = false;
					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(true);
					while (triggImpProcRes->hasConceptImplicationTrigger()) {
						CSortedNegLinker<CConcept*>* nextTrigger = triggImpProcRes->getConceptImplicationTrigger();
						CConcept* triggerConcept = nextTrigger->getData();
						CConceptDescriptor* triggerConDes = nullptr;
						CDependencyTrackPoint* triggerDepTrackPoint = nullptr;
						if (conSet->getConceptDescriptor(triggerConcept,triggerConDes,triggerDepTrackPoint)) {
							if (triggerConDes->isNegated() == nextTrigger->isNegated()) {
								return;
							} else {
								if (triggerDepTrackPoint != depTrackPoint) {
									// add dependency track point
									CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi,triggerConDes,triggerDepTrackPoint,calcAlgContext);
									connDep->setNext(triggImpProcRes->getImplicationDependency());
									triggImpProcRes->setImplicationDependency(connDep);
								}
								triggImpProcRes->setConceptImplicationTrigger(nextTrigger->getNext());
							}
						} else {
							break;
						}
					}
					if (!triggImpProcRes->hasConceptImplicationTrigger()) {
						allTriggersAvailable = true;
					}

					if (!allTriggersAvailable) {
						// install to trigger
						STATINC(IMPLICATIONTRIGGERINGCOUNT,calcAlgContext);
						CSortedNegLinker<CConcept*>* nextTrigger = triggImpProcRes->getConceptImplicationTrigger();
						CConcept* triggerConcept = nextTrigger->getData();
						bool triggerNegation = !nextTrigger->isNegated();
						addConceptToReapplyQueue(conDes,triggerConcept,triggerNegation,processIndi,triggImpProcRes,depTrackPoint,calcAlgContext);
					} else {
						STATINC(IMPLICATIONEXECUTINGCOUNT,calcAlgContext);
						CDependency* triggerDeps = triggImpProcRes->getImplicationDependency();
						CDependencyTrackPoint* nextDepTrackPoint = nullptr;
						CIMPLICATIONDependencyNode* implDepNode = createIMPLICATIONDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,triggerDeps,calcAlgContext);
						CConcept* implConcept = opLinker->getData();
						bool impConNeg = opLinker->isNegated();
						addConceptToIndividual(implConcept,impConNeg,processIndi,nextDepTrackPoint,true,false,calcAlgContext);
					}


				}







				void CCalculationTableauCompletionTaskHandleAlgorithm::applyNOMINALIMPLICATIONRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(IMPLICATIONRULEAPPLICATIONCOUNT, calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();

					if (opLinker) {
						bool triggersAvailable = false;
						CDependencyTrackPoint* addNomTriggerDepTrackPoint = nullptr;
						CIndividual* indi = concept->getNominalIndividual();
						if (indi) {
							if (processIndi->getNominalIndividual()) {
								if (processIndi->getNominalIndividual()->getIndividualID() == indi->getIndividualID()) {
									triggersAvailable = true;
								} else {
									CIndividualMergingHash* mergingHash = processIndi->getIndividualMergingHash(false);
									if (mergingHash) {
										CIndividualMergingHashData mergedData = mergingHash->value(indi->getIndividualID());
										if (mergedData.isMergedWithIndividual()) {
											triggersAvailable = true;
											CDependencyTrackPoint* triggerDepTrackPoint = mergedData.getDependencyTrackPoint();
											if (triggerDepTrackPoint != processIndi->getDependencyTrackPoint()) {
												addNomTriggerDepTrackPoint = triggerDepTrackPoint;
											}
										}
									}
								}
							}
						}

						if (!triggersAvailable) {
							CIndividualMergingHash* mergingHash = processIndi->getIndividualMergingHash(true);
							CIndividualMergingHashData& mergingHashData = (*mergingHash)[indi->getIndividualID()];
							CCondensedReapplyConceptDescriptor* reapplyConDes = CObjectAllocator< CCondensedReapplyConceptDescriptor >::allocateAndConstruct(taskMemMan);
							reapplyConDes->initReapllyDescriptor(conDes,depTrackPoint);
							mergingHashData.getReapplyQueue()->addReapplyConceptDescriptor(reapplyConDes);
							//addConceptRestrictedToProcessingQueue(conDes, depTrackPoint,ConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool reapplied, CProcessingRestrictionSpecification* procRestriction, 0, calcAlgContext);
						} else {
							STATINC(IMPLICATIONEXECUTINGCOUNT, calcAlgContext);
							CCONNECTIONDependencyNode* connDep = createCONNECTIONDependency(processIndi, nullptr, addNomTriggerDepTrackPoint, calcAlgContext);
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CIMPLICATIONDependencyNode* implDepNode = createIMPLICATIONDependency(nextDepTrackPoint, processIndi, conDes, depTrackPoint, connDep, calcAlgContext);
							addConceptsToIndividual(opLinker, false, processIndi, nextDepTrackPoint, true, false, nullptr, calcAlgContext);
						}
					}
				}




				CSatisfiableCalculationTask* CCalculationTableauCompletionTaskHandleAlgorithm::createDependendBranchingTaskList(cint64 newTaskCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableCalculationTask* taskList = nullptr;
					CMemoryTemporaryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
					for (cint64 i = 0; i < newTaskCount; ++i) {
						STATINC(TASKCREATIONCOUNT,calcAlgContext);
						CSatisfiableCalculationTask* satCalcTask = CObjectMemoryPoolAllocator<CSatisfiableCalculationTask>::allocateAndConstructWithMemroyPool(taskMemMan);
						satCalcTask->initBranchDependedSatisfiableCalculationTask(calcAlgContext->getUsedSatisfiableCalculationTask(),calcAlgContext->getTaskProcessorContext());

						if (calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskDepth() < 90) {
							satCalcTask->setTaskID(mDebugTaskIDVector[calcAlgContext->getUsedSatisfiableCalculationTask()->getTaskDepth()+1]++);
						}

						taskList = (CSatisfiableCalculationTask*)satCalcTask->append(taskList);
					}
					return taskList;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::prepareBranchedTaskProcessing(CIndividualProcessNode*& individual, CSatisfiableCalculationTask* newTask, CCalculationAlgorithmContextBase* calcAlgContext) {
					addIndividualToProcessingQueue(individual,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::installConceptRoleBranchTrigger(CIndividualProcessNode*& processIndi, CConceptDescriptor* conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CProcessingRestrictionSpecification* procRest, CConceptRoleBranchingTrigger* trigger, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (trigger->isConceptTrigger()) {
						STATINC(CONCEPTTRIGGERINSTALLCOUNT,calcAlgContext);
						CConcept* triggerConcept = trigger->getTriggerConcept();
						bool triggerNegation = trigger->getTriggerNegation();
						addConceptToReapplyQueue(conceptDescriptor,triggerConcept,triggerNegation,processIndi,procRest,depTrackPoint,calcAlgContext);
					} else {
						STATINC(ROLETRIGGERINSTALLCOUNT,calcAlgContext);
						CRole* role = trigger->getTriggerRole();
						addConceptToReapplyQueue(conceptDescriptor,role,processIndi,procRest,depTrackPoint,calcAlgContext);
					}
				}



				CConceptRoleBranchingTrigger* CCalculationTableauCompletionTaskHandleAlgorithm::searchNextConceptRoleBranchTrigger(CIndividualProcessNode*& processIndi, CConceptRoleBranchingTrigger* triggers, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyRoleSuccessorHash* reapplySuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					CReapplyConceptLabelSet* conSet = processIndi->getReapplyConceptLabelSet(false);
					while (triggers) {
						if (triggers->isConceptTrigger()) {
							CConcept* triggerConcept = triggers->getTriggerConcept();
							bool triggerNegation = triggers->getTriggerNegation();
							if (!conSet || !conSet->containsConcept(triggerConcept,triggerNegation)) {
								return triggers;
							}
						} else {
							CRole* role = triggers->getTriggerRole();
							if (!reapplySuccHash || !reapplySuccHash->hasRoleSuccessor(role)) {
								return triggers;
							}
						}
						triggers = triggers->getNextBranchingTrigger();
					}
					return nullptr;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applySELFRule(CIndividualProcessNode*& processIndi, CConceptProcessDescriptor*& conProDes, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(SELFRULEAPPLICATIONCOUNT,calcAlgContext);
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					CRole* role = concept->getRole();
					CDependencyTrackPoint* depTrackPoint = conProDes->getDependencyTrackPoint();
					bool reapplied = conProDes->isConceptReapplied();
					CIndividualLinkEdge* restLink = getLinkProcessingRestriction(conProDes);
					if (!negate) {
						CIndividualLinkEdge* link = getIndividualNodeLink(processIndi,processIndi,role,calcAlgContext);
						if (!link) {
							// self edge/link does not exist
							// create dependency
							CDependencyTrackPoint* nextDepTrackPoint = nullptr;
							CSELFDependencyNode* selfDepNode = createSELFDependency(nextDepTrackPoint,processIndi,conDes,depTrackPoint,calcAlgContext);
							createNewIndividualsLinksReapplyed(processIndi,processIndi,role->getIndirectSuperRoleList(),role,nextDepTrackPoint,true,calcAlgContext);
						}
					} else {
						if (restLink) {
							if (restLink->isDestinationIndividual(processIndi) && restLink->isSourceIndividual(processIndi)) {
								// throw clash
								CClashedDependencyDescriptor* clashDes = nullptr;
								clashDes = createClashedIndividualLinkDescriptor(clashDes,restLink,restLink->getDependencyTrackPoint(),calcAlgContext);
								clashDes = createClashedConceptDescriptor(clashDes,processIndi,conDes,depTrackPoint,calcAlgContext);
								throw CCalculationClashProcessingException(clashDes);
							}
						} else {
							CIndividualLinkEdge* link = getIndividualNodeLink(processIndi,processIndi,role,calcAlgContext);
							if (link) {
								// throw clash
								CClashedDependencyDescriptor* clashDes = nullptr;
								clashDes = createClashedIndividualLinkDescriptor(clashDes,link,link->getDependencyTrackPoint(),calcAlgContext);
								clashDes = createClashedConceptDescriptor(clashDes,processIndi,conDes,depTrackPoint,calcAlgContext);
								throw CCalculationClashProcessingException(clashDes);
							}
						}
						if (!reapplied) {
							addConceptToReapplyQueue(conDes,role,processIndi,true,depTrackPoint,calcAlgContext);
						}
					}
				}


				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::getLinkProcessingRestriction(CConceptProcessDescriptor*& conProDes) {
					CProcessingRestrictionSpecification* procRestSpec = conProDes->getProcessingRestrictionSpecification();
					CIndividualLinkEdge* restLink = nullptr;
					if (procRestSpec) {
						CLinkProcessingRestrictionSpecification* linkProcRestSpec = (CLinkProcessingRestrictionSpecification*)procRestSpec;
						restLink = linkProcRestSpec->getLinkRestriction();
					}
					return restLink;
				}












				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualNodeLink(CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorRoleHash* succRoleHash = indiSource->getSuccessorRoleHash(false);
					if (succRoleHash) {
						CSuccessorRoleIterator succRoleIt = succRoleHash->getSuccessorRoleIterator(indiSource->getIndividualNodeID());
						while (succRoleIt.hasNext()) {
							CIndividualLinkEdge* link = succRoleIt.next(true);
							if (link->getLinkRole() == role) {
								return link;
							}
						}
					}
					return nullptr;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptClashSet(CReapplyConceptLabelSet* subConceptSet, CReapplyConceptLabelSet* superConceptSet, bool* subSetFlag, bool ignoreNominalsForSubsetChecking, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTSUBSETTESTCOUNT,calcAlgContext);
					cint64 subConSetCount = subConceptSet->getConceptCount();
					cint64 superConSetCount = superConceptSet->getConceptCount();
					cint64 thresholdFactor = mMapComparisonDirectLookupFactor;
					if (subSetFlag) {
						*subSetFlag = true;
					}
					if (subConSetCount * thresholdFactor < superConSetCount) {
						CReapplyConceptLabelSetIterator subConSetIt = subConceptSet->getConceptLabelSetIterator(true,false,false);
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							bool containedNegation = false;
							if (superConceptSet->containsConcept(subConDes->getConcept(), &containedNegation)) {
								if (containedNegation != subConDes->getNegation()) {									
									return true;
								}
							} else {
								if (!ignoreNominalsForSubsetChecking || subConDes->getConcept()->getOperatorCode() != CCNOMINAL) {
									if (subSetFlag) {
										*subSetFlag = false;
									}
								}
							}
							subConSetIt.moveNext();
						}
					} else {
						CReapplyConceptLabelSetIterator subConSetIt(subConceptSet->getConceptLabelSetIterator(true,false,false));
						CReapplyConceptLabelSetIterator superConSetIt(superConceptSet->getConceptLabelSetIterator(true,false,false));
						CConceptDescriptor* superConDes = superConSetIt.getConceptDescriptor();
						cint64 superConTag = superConDes->getConceptTag();
						superConSetIt.moveNext();
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							cint64 subConTag = subConDes->getConceptTag();

							bool conceptInSuperConSet = true;
							while (superConTag < subConTag) {
								if (!superConSetIt.hasValue()) {
									if (subSetFlag) {
										*subSetFlag = false;
									}
									return false;
								}
								superConDes = superConSetIt.getConceptDescriptor();
								superConTag = superConDes->getConceptTag();
								superConSetIt.moveNext();
							}
							if (subConTag != superConTag) {
								conceptInSuperConSet = false;
							} else {
								if (subConDes->isNegated() != superConDes->isNegated()) {
									return true;
								}
							}

							if (!conceptInSuperConSet) {
								if (!ignoreNominalsForSubsetChecking || subConDes->getConcept()->getOperatorCode() != CCNOMINAL) {
									if (subSetFlag) {
										*subSetFlag = false;
									}
								}
							}

							subConSetIt.moveNext();
						}
					}					
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptSubSetIgnoreNominals(CReapplyConceptLabelSet* subConceptSet, CReapplyConceptLabelSet* superConceptSet, bool* clashFlag, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTSUBSETTESTCOUNT,calcAlgContext);
					cint64 subConSetCount = subConceptSet->getConceptCount();
					cint64 superConSetCount = superConceptSet->getConceptCount();
					cint64 thresholdFactor = mMapComparisonDirectLookupFactor;
					if (subConSetCount * thresholdFactor < superConSetCount) {
						CReapplyConceptLabelSetIterator subConSetIt = subConceptSet->getConceptLabelSetIterator(true,false,false);
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							bool containedNegation = false;
							if (superConceptSet->containsConcept(subConDes->getConcept(), &containedNegation)) {
								if (containedNegation != subConDes->getNegation()) {
									if (clashFlag) {
										*clashFlag = true;
									}
									return false;
								}
							} else {
								if (subConDes->getConcept()->getOperatorCode() != CCNOMINAL) {
									return false;
								}
							}
							subConSetIt.moveNext();
						}
					} else {
						CReapplyConceptLabelSetIterator subConSetIt(subConceptSet->getConceptLabelSetIterator(true,false,false));
						CReapplyConceptLabelSetIterator superConSetIt(superConceptSet->getConceptLabelSetIterator(true,false,false));
						CConceptDescriptor* superConDes = superConSetIt.getConceptDescriptor();
						cint64 superConTag = superConDes->getConceptTag();
						superConSetIt.moveNext();
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							cint64 subConTag = subConDes->getConceptTag();

							bool conceptInSuperConSet = true;
							while (superConTag < subConTag) {
								if (!superConSetIt.hasValue()) {
									conceptInSuperConSet = false;
								}
								superConDes = superConSetIt.getConceptDescriptor();
								superConTag = superConDes->getConceptTag();
								superConSetIt.moveNext();
							}
							if (subConTag != superConTag) {
								conceptInSuperConSet = false;
							} else {
								if (subConDes->isNegated() != superConDes->isNegated()) {
									if (clashFlag) {
										*clashFlag = true;
									}
									return false;
								}
							}

							if (!conceptInSuperConSet) {
								if (subConDes->getConcept()->getOperatorCode() != CCNOMINAL) {
									return false;
								}
							}

							subConSetIt.moveNext();
						}
					}					
					return true;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptSubSet(CReapplyConceptLabelSet* subConceptSet, CReapplyConceptLabelSet* superConceptSet, CConceptDescriptor** firstNotEntailedConDes, bool* equalConSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTSUBSETTESTCOUNT,calcAlgContext);
					cint64 subConSetCount = subConceptSet->getConceptCount();
					cint64 superConSetCount = superConceptSet->getConceptCount();
					if (equalConSet) {
						if (subConSetCount != superConSetCount) {
							*equalConSet = false;
						} else {
							*equalConSet = true;
						}
					}
					if (subConSetCount > superConSetCount) {
						return false;
					}
					if (superConSetCount == 0) {
						return true;
					}
					cint64 thresholdFactor = 10;
					if (subConSetCount * thresholdFactor < superConSetCount) {
						CReapplyConceptLabelSetIterator subConSetIt = subConceptSet->getConceptLabelSetIterator(true,false,false);
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							if (!superConceptSet->containsConceptDescriptor(subConDes)) {
								if (firstNotEntailedConDes) {
									*firstNotEntailedConDes = subConDes;
								}
								return false;
							}
							subConSetIt.moveNext();
						}
					} else {
						CReapplyConceptLabelSetIterator subConSetIt = subConceptSet->getConceptLabelSetIterator(true,false,false);
						CReapplyConceptLabelSetIterator superConSetIt = superConceptSet->getConceptLabelSetIterator(true,false,false);
						CConceptDescriptor* superConDes = superConSetIt.getConceptDescriptor();
						cint64 superConTag = superConDes->getConceptTag();
						superConSetIt.moveNext();
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							cint64 subConTag = subConDes->getConceptTag();
							
							while (superConTag < subConTag) {
								if (!superConSetIt.hasValue()) {
									if (firstNotEntailedConDes) {
										*firstNotEntailedConDes = subConDes;
									}
									return false;
								}
								superConDes = superConSetIt.getConceptDescriptor();
								superConTag = superConDes->getConceptTag();
								superConSetIt.moveNext();
								if (equalConSet && superConTag < subConTag) {
									*equalConSet = false;
								}
							}
							if (subConTag != superConTag) {
								if (firstNotEntailedConDes) {
									*firstNotEntailedConDes = subConDes;
								}
								if (equalConSet) {
									*equalConSet = false;
								}
								return false;
							} else {
								if (subConDes->isNegated() != superConDes->isNegated()) {
									if (firstNotEntailedConDes) {
										*firstNotEntailedConDes = subConDes;
									}
									if (equalConSet) {
										*equalConSet = false;
									}
									return false;
								}
							}
							subConSetIt.moveNext();
						}
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptEqualSet(CReapplyConceptLabelSet* conceptSet1, CReapplyConceptLabelSet* conceptSet2, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTEQUALSETTESTCOUNT,calcAlgContext);
					cint64 conceptSet1Count = conceptSet1->getConceptCount();
					cint64 conceptSet2Count = conceptSet2->getConceptCount();
					if (conceptSet1Count != conceptSet2Count) {
						return false;
					}
					if (!conceptSet1->getConceptSignature()->isSignatureEquivalent(conceptSet2->getConceptSignature())) {
						return false;
					}
					CReapplyConceptLabelSetIterator conSet1It = conceptSet1->getConceptLabelSetIterator(true,false,false);
					CReapplyConceptLabelSetIterator conSet2It = conceptSet2->getConceptLabelSetIterator(true,false,false);
					while (conSet1It.hasValue()) {
						if (!conSet2It.hasValue()) {
							return false;
						}
						CConceptDescriptor* conDes1 = conSet1It.getConceptDescriptor();
						CConceptDescriptor* conDes2 = conSet2It.getConceptDescriptor();
						if (conDes1->getConcept() != conDes2->getConcept()) {
							return false;
						}
						if (conDes1->isNegated() != conDes2->isNegated()) {
							return false;
						}
						conSet1It.moveNext();
						conSet2It.moveNext();
					}
					return true;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptEqualSetConsiderNominalsForClashOnly(CReapplyConceptLabelSet* conceptSet1, CReapplyConceptLabelSet* conceptSet2, bool* clashFlag, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTEQUALSETTESTCOUNT, calcAlgContext);
					if (clashFlag) {
						*clashFlag = false;
					}
					CReapplyConceptLabelSetIterator conSet1It(conceptSet1->getConceptLabelSetIterator(true, false, false));
					CReapplyConceptLabelSetIterator conSet2It(conceptSet2->getConceptLabelSetIterator(true, false, false));
					while (conSet1It.hasValue() || conSet2It.hasValue()) {

						bool conSet1Nominal = false;
						bool conSet2Nominal = false;
						if (conSet1It.hasValue() && conSet1It.getConceptDescriptor()->getConcept()->getOperatorCode() == CCNOMINAL) {
							conSet1Nominal = true;
						}
						if (conSet2It.hasValue() && conSet2It.getConceptDescriptor()->getConcept()->getOperatorCode() == CCNOMINAL) {
							conSet2Nominal = true;
						}

						if (conSet1Nominal && conSet2Nominal) {
							CConceptDescriptor* conDes1 = conSet1It.getConceptDescriptor();
							CConceptDescriptor* conDes2 = conSet2It.getConceptDescriptor();
							if (conDes1->getConcept() == conDes2->getConcept()) {
								if (conDes1->isNegated() != conDes2->isNegated()) {
									if (clashFlag) {
										*clashFlag = true;
										return false;
									}
								}
							}
							conSet1It.moveNext();
							conSet2It.moveNext();
						} else if (conSet1Nominal) {
							conSet1It.moveNext();
						} else if (conSet2Nominal) {
							conSet2It.moveNext();
						} else {
							if (conSet1It.hasValue() && !conSet2It.hasValue() || !conSet1It.hasValue() && conSet2It.hasValue()) {
								return false;
							} else if (conSet1It.hasValue() && conSet2It.hasValue()) {
								CConceptDescriptor* conDes1 = conSet1It.getConceptDescriptor();
								CConceptDescriptor* conDes2 = conSet2It.getConceptDescriptor();
								if (conDes1->getConcept() != conDes2->getConcept()) {
									return false;
								}
								if (conDes1->isNegated() != conDes2->isNegated()) {
									if (clashFlag) {
										*clashFlag = true;
									}
									return false;
								}
								conSet1It.moveNext();
								conSet2It.moveNext();
							}
						}
					}
					return true;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::isPairwiseLabelConceptEqualSet(CReapplyConceptLabelSet* conceptSet1, CReapplyConceptLabelSet* conceptSet1Pair, CReapplyConceptLabelSet* conceptSet2, CReapplyConceptLabelSet* conceptSet2Pair, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(LABELCONCEPTPAIRWISEEQUALSETTESTCOUNT,calcAlgContext);
					cint64 conceptSet1Count = conceptSet1->getConceptCount();
					cint64 conceptSet1PCount = conceptSet1Pair->getConceptCount();
					if (conceptSet1Count != conceptSet1PCount) {
						return false;
					}
					cint64 conceptSet2Count = conceptSet2->getConceptCount();
					cint64 conceptSet2PCount = conceptSet2Pair->getConceptCount();
					if (conceptSet2Count != conceptSet2PCount) {
						return false;
					}
					if (!conceptSet1->getConceptSignature()->isSignatureEquivalent(conceptSet1Pair->getConceptSignature())) {
						return false;
					}
					if (!conceptSet2->getConceptSignature()->isSignatureEquivalent(conceptSet2Pair->getConceptSignature())) {
						return false;
					}
					CReapplyConceptLabelSetIterator conSet1It = conceptSet1->getConceptLabelSetIterator(true,false,false);
					CReapplyConceptLabelSetIterator conSet1PairIt = conceptSet1Pair->getConceptLabelSetIterator(true,false,false);
					while (conSet1It.hasValue()) {
						if (!conSet1PairIt.hasValue()) {
							return false;
						}
						CConceptDescriptor* conDes1 = conSet1It.getConceptDescriptor();
						CConceptDescriptor* conDes1Pair = conSet1PairIt.getConceptDescriptor();
						if (conDes1->getConcept() != conDes1Pair->getConcept()) {
							return false;
						}
						if (conDes1->isNegated() != conDes1Pair->isNegated()) {
							return false;
						}
						conSet1It.moveNext();
						conSet1PairIt.moveNext();
					}
					CReapplyConceptLabelSetIterator conSet2It = conceptSet2->getConceptLabelSetIterator(true,false);
					CReapplyConceptLabelSetIterator conSet2PairIt = conceptSet2Pair->getConceptLabelSetIterator(true,false,false);
					while (conSet2It.hasValue()) {
						if (!conSet2PairIt.hasValue()) {
							return false;
						}
						CConceptDescriptor* conDes2 = conSet2It.getConceptDescriptor();
						CConceptDescriptor* conDes2Pair = conSet2PairIt.getConceptDescriptor();
						if (conDes2->getConcept() != conDes2Pair->getConcept()) {
							return false;
						}
						if (conDes2->isNegated() != conDes2Pair->isNegated()) {
							return false;
						}
						conSet2It.moveNext();
						conSet2PairIt.moveNext();
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasOptimizedBlockingB2AutomateTransitionOperands(CConcept* concept, CRole* role, CReapplyConceptLabelSet* vConSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(OPTIMIZEDBLOCKINGB2AUTOMATETRANSACTIONTESTCOUNT,calcAlgContext);
					cint64 opCode = concept->getOperatorCode();
					CConceptOperator* conOperator = concept->getConceptOperator();
					if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQAND_TYPE)) {
						// recursive
						CSortedNegLinker<CConcept*>* opLinkerIt = concept->getOperandList();
						while (opLinkerIt) {
							CConcept* opConcept = opLinkerIt->getData();
							if (!hasOptimizedBlockingB2AutomateTransitionOperands(opConcept,role,vConSet,calcAlgContext)) {
								return false;
							}
							opLinkerIt = opLinkerIt->getNext();
						}
					} else if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQALL_TYPE)) {
						CRole* conRole = concept->getRole();
						if (conRole == role) {
							CSortedNegLinker<CConcept*>* opLinkerIt = concept->getOperandList();
							while (opLinkerIt) {
								CConcept* opConcept = opLinkerIt->getData();
								if (!vConSet->containsConcept(opConcept,false)) {
									return false;
								}
								opLinkerIt = opLinkerIt->getNext();
							}
						}
					}
					return true;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::isNominalVariablePropagationBindingSubSet(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {

					// checking back/candidate propagation
					CIndividualProcessNode* ancestorIndiNode = nullptr;
					CConceptPropagationBindingSetHash* conPropBindSetHash = testIndi->getConceptPropagationBindingSetHash(false);
					CConceptPropagationBindingSetHash* blockerConPropBindSetHash = blockerConPropBindSetHash = blockingIndi->getConceptPropagationBindingSetHash(false);
					if (conPropBindSetHash) {
						for (CConceptPropagationBindingSetHash::iterator it1 = conPropBindSetHash->begin(), it1End = conPropBindSetHash->end(); it1 != it1End; ++it1) {
							CConceptPropagationBindingSetHashData& hashData = it1.value();
							CPropagationBindingSet* propBindSet = hashData.mUsePropBindingSet;
							CConceptDescriptor* conDes = propBindSet->getConceptDescriptor();

							if (propBindSet && conDes) {
								CConcept* concept = conDes->getConcept();
								CPropagationBindingSet* blockerPropBindSet = nullptr;

								CPropagationBindingMap* propBindMap = propBindSet->getPropagationBindingMap();
								for (CPropagationBindingMap::iterator it2 = propBindMap->begin(), it2End = propBindMap->end(); it2 != it2End; ++it2) {
									CPropagationBindingMapData& mapData = it2.value();
									CPropagationBindingDescriptor* propBindDes = mapData.getPropagationBindingDescriptor();
									if (propBindDes) {
										CPropagationBinding* propBind = propBindDes->getPropagationBinding();
										if (propBind) {
											CVariable* propBindVar = propBind->getBindedVariable();
											if (propBindVar) {
												if (propBindVar->isNominalVariable()) {

													// propagation variable binding is also required in blocker node
													if (!blockerPropBindSet) {
														if (!blockerConPropBindSetHash) {
															return false;
														}
														blockerPropBindSet = blockerConPropBindSetHash->getPropagationBindingSet(concept,false);
														if (!blockerPropBindSet) {
															return false;
														}
													}
													bool blockingPossible = false;
													CPropagationBindingDescriptor* blockerPropBindDes = blockerPropBindSet->getPropagationBindingDescriptor(propBind);
													if (blockerPropBindDes) {
														blockingPossible = true;
													}

													if (!blockingPossible) {
														return false;
													}
												}
											}
										}
									}
								}
							}
						}
					}
					// checking back/candidate propagation for ancestor node
					if (blockerConPropBindSetHash) {
						if (!ancestorIndiNode) {
							ancestorIndiNode = getAncestorIndividual(testIndi,calcAlgContext);
						}
						if (ancestorIndiNode) {
							CConceptPropagationBindingSetHash* ancConPropBindSetHash = ancestorIndiNode->getConceptPropagationBindingSetHash(false);
							for (CConceptPropagationBindingSetHash::iterator it1 = blockerConPropBindSetHash->begin(), it1End = blockerConPropBindSetHash->end(); it1 != it1End; ++it1) {
								CConceptPropagationBindingSetHashData& hashData = it1.value();
								CPropagationBindingSet* blockerPropBindSet = hashData.mUsePropBindingSet;
								CConceptDescriptor* conDes = blockerPropBindSet->getConceptDescriptor();

								if (blockerPropBindSet && conDes) {
									CConcept* concept = conDes->getConcept();
									cint64 opCode = concept->getOperatorCode();
									bool negation = conDes->isNegated();

									if (!negation && (opCode == CCPBINDALL || opCode == CCPBINDAQALL)) {
										CRole* role = concept->getRole();
										for (CSortedNegLinker<CConcept*>* opConLinkerIt = concept->getOperandList(); opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
											CConcept* opConcept = opConLinkerIt->getData();
											if (testIndi->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
												if (!ancConPropBindSetHash) {
													return false;
												} else {
													CPropagationBindingSet* ancPropBindSet = nullptr;
													CPropagationBindingMap* propBindMap = blockerPropBindSet->getPropagationBindingMap();
													for (CPropagationBindingMap::iterator it2 = propBindMap->begin(), it2End = propBindMap->end(); it2 != it2End; ++it2) {
														CPropagationBindingMapData& mapData = it2.value();
														CPropagationBindingDescriptor* blockerPropBindDes = mapData.getPropagationBindingDescriptor();
														if (blockerPropBindDes) {
															CPropagationBinding* blockerPropBind = blockerPropBindDes->getPropagationBinding();
															if (blockerPropBind) {
																CVariable* blockerPropBindVar = blockerPropBind->getBindedVariable();
																if (blockerPropBindVar) {
																	if (blockerPropBindVar->isNominalVariable()) {

																		bool blockingPossible = false;
																		if (!ancPropBindSet) {
																			ancPropBindSet = ancConPropBindSetHash->getPropagationBindingSet(opConcept);
																			if (!ancPropBindSet) {
																				return false;
																			}
																		}
																		CPropagationBindingDescriptor* ancPropBindDes = ancPropBindSet->getPropagationBindingDescriptor(blockerPropBind);
																		if (ancPropBindDes) {
																			blockingPossible = true;
																		}
																		if (!blockingPossible) {
																			return false;
																		}

																	}
																}
															}
														}
													}

												}
											}
										}
									}

								}
							}
						}
					}



					// checking normal propagation
					CConceptVariableBindingPathSetHash* conVarBindSetHash = testIndi->getConceptVariableBindingPathSetHash(false);
					CConceptVariableBindingPathSetHash* blockerConVarBindSetHash = blockerConVarBindSetHash = blockingIndi->getConceptVariableBindingPathSetHash(false);
					if (conVarBindSetHash) {
						for (CConceptVariableBindingPathSetHash::iterator it1 = conVarBindSetHash->begin(), it1End = conVarBindSetHash->end(); it1 != it1End; ++it1) {
							CConceptVariableBindingPathSetHashData& hashData = it1.value();
							CVariableBindingPathSet* varBindSet = hashData.mUseVariableBindingPathSet;
							CConceptDescriptor* conDes = varBindSet->getConceptDescriptor();

							if (varBindSet && conDes) {
								CConcept* concept = conDes->getConcept();
								CVariableBindingPathSet* blockerVarBindSet = nullptr;

								CVariableBindingPathMap* varBindMap = varBindSet->getVariableBindingPathMap();
								for (CVariableBindingPathMap::iterator it2 = varBindMap->begin(), it2End = varBindMap->end(); it2 != it2End; ++it2) {
									CVariableBindingPathMapData& mapData = it2.value();
									CVariableBindingPathDescriptor* varBindDes = mapData.getVariableBindingPathDescriptor();
									if (varBindDes) {
										CVariableBindingPath* varBindPath = varBindDes->getVariableBindingPath();
										if (varBindPath) {

											// propagation variable binding is also required in blocker node
											if (!blockerVarBindSet) {
												if (!blockerConVarBindSetHash) {
													return false;
												}
												blockerVarBindSet = blockerConVarBindSetHash->getVariableBindingPathSet(concept,false);
												if (!blockerVarBindSet) {
													return false;
												}
											}
											bool blockingPossible = false;
											CVariableBindingPathDescriptor* blockerVarBindDes = blockerVarBindSet->getVariableBindingPathDescriptor(varBindPath);
											if (blockerVarBindDes) {
												blockingPossible = true;
											}

											if (!blockingPossible) {
												return false;
											}
										}
									}
								}
							}
						}
					}
					// checking normal propagation for ancestor node
					if (blockerConVarBindSetHash) {
						if (!ancestorIndiNode) {
							ancestorIndiNode = getAncestorIndividual(testIndi,calcAlgContext);
						}
						if (ancestorIndiNode) {
							CConceptVariableBindingPathSetHash* ancConVarBindSetHash = ancestorIndiNode->getConceptVariableBindingPathSetHash(false);
							for (CConceptVariableBindingPathSetHash::iterator it1 = blockerConVarBindSetHash->begin(), it1End = blockerConVarBindSetHash->end(); it1 != it1End; ++it1) {
								CConceptVariableBindingPathSetHashData& hashData = it1.value();
								CVariableBindingPathSet* blockerVarBindSet = hashData.mUseVariableBindingPathSet;
								CConceptDescriptor* conDes = blockerVarBindSet->getConceptDescriptor();

								if (blockerVarBindSet && conDes) {
									CConcept* concept = conDes->getConcept();
									cint64 opCode = concept->getOperatorCode();
									bool negation = conDes->isNegated();

									if (!negation && (opCode == CCVARBINDALL || opCode == CCVARBINDAQALL)) {
										CRole* role = concept->getRole();
										for (CSortedNegLinker<CConcept*>* opConLinkerIt = concept->getOperandList(); opConLinkerIt; opConLinkerIt = opConLinkerIt->getNext()) {
											CConcept* opConcept = opConLinkerIt->getData();
											if (testIndi->hasRoleSuccessorToIndividual(role,ancestorIndiNode,true)) {
												if (!ancConVarBindSetHash) {
													return false;
												} else {
													CVariableBindingPathSet* ancVarBindSet = nullptr;
													CVariableBindingPathMap* varBindMap = blockerVarBindSet->getVariableBindingPathMap();
													for (CVariableBindingPathMap::iterator it2 = varBindMap->begin(), it2End = varBindMap->end(); it2 != it2End; ++it2) {
														CVariableBindingPathMapData& mapData = it2.value();
														CVariableBindingPathDescriptor* blockerVarBindDes = mapData.getVariableBindingPathDescriptor();
														if (blockerVarBindDes) {
															CVariableBindingPath* blockerVarBindPath = blockerVarBindDes->getVariableBindingPath();
															if (blockerVarBindPath) {

																bool blockingPossible = false;
																if (!ancVarBindSet) {
																	ancVarBindSet = ancConVarBindSetHash->getVariableBindingPathSet(opConcept);
																	if (!ancVarBindSet) {
																		return false;
																	}
																}
																CVariableBindingPathDescriptor* ancVarBindPathDes = ancVarBindSet->getVariableBindingPathDescriptor(blockerVarBindPath);
																if (ancVarBindPathDes) {
																	blockingPossible = true;
																}
																if (!blockingPossible) {
																	return false;
																}

															}
														}
													}

												}
											}
										}
									}

								}
							}
						}
					}



					// TODO: check representative propagation

					return true;
				}



















				bool CCalculationTableauCompletionTaskHandleAlgorithm::areVariablePropagationBindingsCompatible(CVariableBindingPath* varBindPath1, CVariableBindingPath* varBindPath2, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (varBindPath1->getPropagationID() == varBindPath2->getPropagationID()) {
						return true;
					}
					CVariableBindingPath* lessVarBindPath = varBindPath1;
					CVariableBindingPath* moreVarBindPath = varBindPath2;
					if (varBindPath1->getVariableBindingCount() > varBindPath2->getVariableBindingCount()) {
						moreVarBindPath = varBindPath1;
						lessVarBindPath = varBindPath2;
					}
					for (CVariableBindingDescriptor* lessVarBindDesIt = lessVarBindPath->getVariableBindingDescriptorLinker(); lessVarBindDesIt; lessVarBindDesIt = lessVarBindDesIt->getNext()) {
						CVariableBinding* lessVariableBinding = lessVarBindDesIt->getVariableBinding();
						CVariable* variable = lessVariableBinding->getBindedVariable();
						CIndividualProcessNode* boundIndi = lessVariableBinding->getBindedIndividual();
						for (CVariableBindingDescriptor* moreVarBindDesIt = moreVarBindPath->getVariableBindingDescriptorLinker(); moreVarBindDesIt; moreVarBindDesIt = moreVarBindDesIt->getNext()) {
							CVariableBinding* moreVariableBinding = moreVarBindDesIt->getVariableBinding();
							if (moreVariableBinding->getBindedVariable() == variable && moreVariableBinding->getBindedIndividual()->getIndividualNodeID() != boundIndi->getIndividualNodeID()) {
								return false;
							}
						}

					}
					return true;
				}



				QSet<CConcept*> CCalculationTableauCompletionTaskHandleAlgorithm::getConceptsForCompatibleVariablePropagationBindings(CIndividualProcessNode*& individualNode, CVariableBindingPath* varBindPath, CCalculationAlgorithmContextBase* calcAlgContext) {
					//CPROCESSINGSET<CConcept*>* conceptSet = CObjectParameterizingAllocator< CPROCESSINGSET<CConcept*>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(), calcAlgContext->getUsedTaskProcessorContext());
					QSet<CConcept*> conceptSet;
					CConceptVariableBindingPathSetHash* conVarBindSetHash = individualNode->getConceptVariableBindingPathSetHash(false);
					if (conVarBindSetHash) {
						for (CConceptVariableBindingPathSetHash::iterator it1 = conVarBindSetHash->begin(), it1End = conVarBindSetHash->end(); it1 != it1End; ++it1) {
							CConceptVariableBindingPathSetHashData& hashData = it1.value();
							CVariableBindingPathSet* varBindSet = hashData.mUseVariableBindingPathSet;
							CConceptDescriptor* conDes = varBindSet->getConceptDescriptor();

							if (varBindSet && conDes) {
								bool conceptsVarBindsCompatible = false;
								CConcept* concept = conDes->getConcept();
								//TODO: use only specific binding trigger concepts?

								CVariableBindingPathMap* varBindMap = varBindSet->getVariableBindingPathMap();
								for (CVariableBindingPathMap::iterator itVarBind = varBindMap->begin(), itVarBindEnd = varBindMap->end(); itVarBind != itVarBindEnd && !conceptsVarBindsCompatible; ++itVarBind) {
									CVariableBindingPathMapData& mapData = itVarBind.value();
									CVariableBindingPathDescriptor* varBindDes = mapData.getVariableBindingPathDescriptor();
									if (varBindDes) {
										CVariableBindingPath* conVarBindPath = varBindDes->getVariableBindingPath();
										if (areVariablePropagationBindingsCompatible(varBindPath, conVarBindPath, calcAlgContext)) {
											conceptsVarBindsCompatible = true;
										}
									}
								}
								if (conceptsVarBindsCompatible) {
									conceptSet.insert(concept);
								}
							}
						}
					}
					return conceptSet;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::collectIndividualNodeVariablePropagationBindings(CIndividualProcessNode*& individualNode, QHash<cint64, CVariableBindingPath*>& collecingPropagationVariableBindingsHash, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool foundVarPropBindings = false;
					// checking normal propagation
					CConceptVariableBindingPathSetHash* conVarBindSetHash = individualNode->getConceptVariableBindingPathSetHash(false);
					if (conVarBindSetHash) {
						for (CConceptVariableBindingPathSetHash::iterator it1 = conVarBindSetHash->begin(), it1End = conVarBindSetHash->end(); it1 != it1End; ++it1) {
							CConceptVariableBindingPathSetHashData& hashData = it1.value();
							CVariableBindingPathSet* varBindSet = hashData.mUseVariableBindingPathSet;
							CConceptDescriptor* conDes = varBindSet->getConceptDescriptor();

							if (varBindSet && conDes) {
								CConcept* concept = conDes->getConcept();

								CVariableBindingPathMap* varBindMap = varBindSet->getVariableBindingPathMap();
								for (CVariableBindingPathMap::iterator it2 = varBindMap->begin(), it2End = varBindMap->end(); it2 != it2End; ++it2) {
									CVariableBindingPathMapData& mapData = it2.value();
									CVariableBindingPathDescriptor* varBindDes = mapData.getVariableBindingPathDescriptor();
									if (varBindDes) {
										CVariableBindingPath* varBindPath = varBindDes->getVariableBindingPath();
										if (varBindPath) {
											foundVarPropBindings = true;
											collecingPropagationVariableBindingsHash.insert(varBindPath->getPropagationID(), varBindPath);
										}
									}
								}
							}
						}
					}
					return foundVarPropBindings;
				}



				QSet< QSet<CConcept*> > CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindingsCached(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					IndiAssociatedConceptSetCacheData& conceptSetCacheData = mCachedIndiAssociatedConceptSetHash[individualNode];
					if (!conceptSetCacheData.mCreated) {
						STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGCONCEPTSETSBUILDINGCOUNT, calcAlgContext);
						conceptSetCacheData.mConceptSet = getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindings(individualNode, calcAlgContext);
						conceptSetCacheData.mCreated = true;
					} else {
						STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGCONCEPTSETSCACHEREUSECOUNT, calcAlgContext);
					}
					return conceptSetCacheData.mConceptSet;
				}



				QSet< QSet<CConcept*> > CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindings(CIndividualProcessNode*& individualNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					QSet< QSet<CConcept*> > associatedConceptsSet;

					QHash<cint64, CVariableBindingPath*> variablePropagationBindingCollectionHash;
					collectIndividualNodeVariablePropagationBindings(individualNode, variablePropagationBindingCollectionHash, calcAlgContext);

					for (QHash<cint64, CVariableBindingPath*>::const_iterator it = variablePropagationBindingCollectionHash.constBegin(), itEnd = variablePropagationBindingCollectionHash.constEnd(); it != itEnd; ++it) {
						CVariableBindingPath* varBindPath = it.value();
						const QSet<CConcept*>& associatedConceptSet = getConceptsForCompatibleVariablePropagationBindings(individualNode, varBindPath, calcAlgContext);
						associatedConceptsSet.insert(associatedConceptSet);
					}
					return associatedConceptsSet;
				}





				QSet< QList< QSet<CConcept*> > > CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualNodesListAssociatedConceptsSetFromVariablePropagationBindings(CIndividualProcessNode*& individualNode, CIndividualProcessNode*& ancestorIndividualNode, const QList<cint64>& dependentNominalIdList, CCalculationAlgorithmContextBase* calcAlgContext) {

					QHash<cint64, CVariableBindingPath*> variablePropagationBindingCollectionHash;
					collectIndividualNodeVariablePropagationBindings(individualNode, variablePropagationBindingCollectionHash, calcAlgContext);
					collectIndividualNodeVariablePropagationBindings(ancestorIndividualNode, variablePropagationBindingCollectionHash, calcAlgContext);
					// it is not necessary to collect the variable bindings/mappings from the nominal nodes since they are identical for the blocker node and the node that is to be blocked


					QSet< QList< QSet<CConcept*> > > allVariableMappingsAssociatedConceptsOverNodesListSet;

					for (QHash<cint64, CVariableBindingPath*>::const_iterator itVarPropBind = variablePropagationBindingCollectionHash.constBegin(), itVarPropBindEnd = variablePropagationBindingCollectionHash.constEnd(); itVarPropBind != itVarPropBindEnd; ++itVarPropBind) {
						CVariableBindingPath* varBindPath = itVarPropBind.value();

						QList< QSet<CConcept*> > associatedConceptsOverNodesList;
						const QSet<CConcept*>& testIndiAssociatedConceptSet = getConceptsForCompatibleVariablePropagationBindings(individualNode, varBindPath, calcAlgContext);
						associatedConceptsOverNodesList.append(testIndiAssociatedConceptSet);
						const QSet<CConcept*>& ancestorTestIndiAssociatedConceptSet = getConceptsForCompatibleVariablePropagationBindings(ancestorIndividualNode, varBindPath, calcAlgContext);
						associatedConceptsOverNodesList.append(ancestorTestIndiAssociatedConceptSet);

						for (QList<cint64>::const_iterator itNomId = dependentNominalIdList.constBegin(), itNomIdEnd = dependentNominalIdList.constEnd(); itNomId != itNomIdEnd; ++itNomId) {
							cint64 nomIndiId = *itNomId;
							CIndividualProcessNode* nominalIndiNode = getCorrectedNominalIndividualNode(nomIndiId, calcAlgContext);
							const QSet<CConcept*>& nominalIndiAssociatedConceptSet = getConceptsForCompatibleVariablePropagationBindings(nominalIndiNode, varBindPath, calcAlgContext);
							associatedConceptsOverNodesList.append(nominalIndiAssociatedConceptSet);
						}

						allVariableMappingsAssociatedConceptsOverNodesListSet.insert(associatedConceptsOverNodesList);
					}
					return allVariableMappingsAssociatedConceptsOverNodesListSet;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::isAnonymousVariablePropagationBindingSingleIndividualAnalogousPath(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBlockingVariableBindingsAnalogousPropagationData* testVarBindBlockData = testIndi->getVariableBindingsPropagationBlockingData(false);
					CBlockingVariableBindingsAnalogousPropagationData* blockingVarBindBlockData = blockingIndi->getVariableBindingsPropagationBlockingData(false);

					CConceptVariableBindingPathSetHash* testConVarBindPathSetHash = testIndi->getConceptVariableBindingPathSetHash(false);
					CConceptVariableBindingPathSetHash* blockingConVarBindPathSetHash = blockingIndi->getConceptVariableBindingPathSetHash(false);


					if (testVarBindBlockData && blockingVarBindBlockData) {
						if (testConVarBindPathSetHash && testVarBindBlockData->getLastPropagatedVariableBindingDescriptor() == testConVarBindPathSetHash->getLastVariableBindingDescriptionLinker()) {
							if (blockingConVarBindPathSetHash && blockingVarBindBlockData->getLastPropagatedVariableBindingDescriptor() == blockingConVarBindPathSetHash->getLastVariableBindingDescriptionLinker()) {
								if (testVarBindBlockData->getLastConceptSetsHashValue() != blockingVarBindBlockData->getLastConceptSetsHashValue()) {
									STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGCONCEPTSETHASHVALUEDIFFERENCECOUNT, calcAlgContext);
									return false;
								}
							}
						}
					}

					bool testIndiAssociatedConceptSetSetCreated = false;;
					bool blockingIndiAssociatedConceptSetSetCreated = false;;

					QSet< QSet<CConcept*> > testIndiAssociatedConceptSetSet; 
					QSet< QSet<CConcept*> > blockingIndiAssociatedConceptSetSet;

					cint64 testConceptSetsHashValue = 0;
					cint64 blockingConceptSetsHashValue = 0;

					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					if (!testVarBindBlockData) {
						testVarBindBlockData = CObjectAllocator< CBlockingVariableBindingsAnalogousPropagationData >::allocateAndConstruct(taskMemMan);
						testIndi->setVariableBindingsPropagationBlockingData(testVarBindBlockData);
					}
					if (testConVarBindPathSetHash && testVarBindBlockData->getLastPropagatedVariableBindingDescriptor() != testConVarBindPathSetHash->getLastVariableBindingDescriptionLinker()) {
						testIndiAssociatedConceptSetSet = getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindingsCached(testIndi, calcAlgContext);
						testConceptSetsHashValue = getBindingsCompatibleConceptSetsHashValue(testIndiAssociatedConceptSetSet, calcAlgContext);
						testIndiAssociatedConceptSetSetCreated = true;
						testVarBindBlockData = testIndi->getVariableBindingsPropagationBlockingData(true);
						if (!testVarBindBlockData) {
							testVarBindBlockData = CObjectAllocator< CBlockingVariableBindingsAnalogousPropagationData >::allocateAndConstruct(taskMemMan);
							testIndi->setVariableBindingsPropagationBlockingData(testVarBindBlockData);
						}
						testVarBindBlockData->setLastConceptSetsHashValue(testConceptSetsHashValue);
						testVarBindBlockData->setLastPropagatedVariableBindingDescriptor(testConVarBindPathSetHash->getLastVariableBindingDescriptionLinker());
					}


					if (!blockingVarBindBlockData) {
						blockingVarBindBlockData = CObjectAllocator< CBlockingVariableBindingsAnalogousPropagationData >::allocateAndConstruct(taskMemMan);
						blockingIndi->setVariableBindingsPropagationBlockingData(blockingVarBindBlockData);
					}
					if (blockingConVarBindPathSetHash && blockingVarBindBlockData->getLastPropagatedVariableBindingDescriptor() != blockingConVarBindPathSetHash->getLastVariableBindingDescriptionLinker()) {
						blockingIndiAssociatedConceptSetSet = getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindings(blockingIndi, calcAlgContext);
						blockingConceptSetsHashValue = getBindingsCompatibleConceptSetsHashValue(blockingIndiAssociatedConceptSetSet, calcAlgContext);
						blockingIndiAssociatedConceptSetSetCreated = true;
						blockingVarBindBlockData = blockingIndi->getVariableBindingsPropagationBlockingData(true);
						if (!blockingVarBindBlockData) {
							blockingVarBindBlockData = CObjectAllocator< CBlockingVariableBindingsAnalogousPropagationData >::allocateAndConstruct(taskMemMan);
							blockingIndi->setVariableBindingsPropagationBlockingData(blockingVarBindBlockData);
						}
						blockingVarBindBlockData->setLastConceptSetsHashValue(blockingConceptSetsHashValue);
						blockingVarBindBlockData->setLastPropagatedVariableBindingDescriptor(blockingConVarBindPathSetHash->getLastVariableBindingDescriptionLinker());
					}


					if (testVarBindBlockData->getLastConceptSetsHashValue() != blockingVarBindBlockData->getLastConceptSetsHashValue()) {
						STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGCONCEPTSETHASHVALUEDIFFERENCECOUNT, calcAlgContext);
						return false;
					}

					if (!testIndiAssociatedConceptSetSetCreated) {
						testIndiAssociatedConceptSetSet = getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindingsCached(testIndi, calcAlgContext);
						testIndiAssociatedConceptSetSetCreated = true;
					}
					if (!blockingIndiAssociatedConceptSetSetCreated) {
						blockingIndiAssociatedConceptSetSet = getIndividualNodeAssociatedConceptsSetFromVariablePropagationBindings(blockingIndi, calcAlgContext);
						blockingIndiAssociatedConceptSetSetCreated = true;
					}


					KONCLUCE_TASK_ALGORITHM_VARIABLE_PROPAGATION_BLOCKING_DEBUGGING_INSTRUCTION(
						if (mConfDebuggingWriteData) {
							mAnalogousPropagationBlockingTestingIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsSetString(testIndi, testIndiAssociatedConceptSetSet, calcAlgContext);
							mAnalogousPropagationBlockingBlockingIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsSetString(blockingIndi, blockingIndiAssociatedConceptSetSet, calcAlgContext);


							if (file.open(QIODevice::Append)) {
								file.write((QString("\r\n\r\nAnalogous propagation blocking test for testing individual %1 with blocking candidate %2\r\n").arg(testIndi->getIndividualNodeID()).arg(blockingIndi->getIndividualNodeID())).toLocal8Bit());
								file.write((QString("\r\nAssociated concepts sets for testing individual %1:\r\n").arg(testIndi->getIndividualNodeID())).toLocal8Bit());
								file.write((mAnalogousPropagationBlockingTestingIndiAssociatedConceptsString).toLocal8Bit());
								file.write((QString("\r\nAssociated concepts sets for blocking individual %1:\r\n").arg(blockingIndi->getIndividualNodeID())).toLocal8Bit());
								file.write((mAnalogousPropagationBlockingBlockingIndiAssociatedConceptsString).toLocal8Bit());
								file.close();
							}
						}
					);



					if (testIndiAssociatedConceptSetSet != blockingIndiAssociatedConceptSetSet) {
						return false;
					}
					return true;
				}



				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getBindingsCompatibleConceptSetsHashValue(const QSet< QSet<CConcept*> >& associatedConceptSets, CCalculationAlgorithmContextBase* calcAlgContext) {

					cint64 hashValue = associatedConceptSets.size();
					for (QSet< QSet<CConcept*> >::const_iterator it = associatedConceptSets.constBegin(), itEnd = associatedConceptSets.constEnd(); it != itEnd; ++it) {
						const QSet<CConcept*>& conSet = *it;

						cint64 conSetHashValue = conSet.size();
						for (QSet<CConcept*>::const_iterator conIt = conSet.constBegin(), conItEnd = conSet.constEnd(); conIt != conItEnd; ++conIt) {
							CConcept* concept = *conIt;
							conSetHashValue += concept->getConceptTag();
						}
						hashValue += conSetHashValue * conSet.size();
					}

					return hashValue;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::isAnonymousVariablePropagationBindingAnalogousPath(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {

					KONCLUCE_TASK_ALGORITHM_VARIABLE_PROPAGATION_BLOCKING_DEBUGGING_INSTRUCTION(
						QString writingFolder = "./Debugging/CompletionTasks/";
						QFile file(QString("%1%2-task.txt").arg(writingFolder, "propagation-blocking-testing"));
						if (mConfDebuggingWriteData) {
							mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
							if (file.open(QIODevice::WriteOnly)) {
								file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
								file.close();
							}
						}
					);

					if (!mFirstBlockingTestDebugWritten) {
						mFirstBlockingTestDebugWritten = true;
						if (mConfDebuggingWriteData) {
							QString writingFolder = "./Debugging/CompletionTasks/";
							mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList(QString("%1%2-task.txt").arg(writingFolder, "first-propagation-blocking-testing"), calcAlgContext);							
						}
					}
					

					STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGTESTCOUNT, calcAlgContext);
					if (!isAnonymousVariablePropagationBindingSingleIndividualAnalogousPath(testIndi, blockingIndi, calcAlgContext)) {
						STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGFAILCOUNT, calcAlgContext);
						return false;
					}


					CIndividualProcessNode* ancestorIndiNode = getAncestorIndividual(testIndi, calcAlgContext);
					CIndividualProcessNode* ancestorBlockingIndi = getAncestorIndividual(blockingIndi, calcAlgContext);
					if (!isAnonymousVariablePropagationBindingSingleIndividualAnalogousPath(ancestorIndiNode, ancestorBlockingIndi, calcAlgContext)) {
						STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGFAILCOUNT, calcAlgContext);
						return false;
					}


					STATINC(SIMPLEANALOGOUSPROPAGATIONBLOCKINGSUCCESSCOUNT, calcAlgContext);

					// first: determine order of (nominal) nodes, e.g., current node, ancestor node, dependent nominal 1, dependent nominal 2, ...
					QList<cint64> dependentNominalIdList;
					CSuccessorConnectedNominalSet* testIndiSuccConnNomSet = testIndi->getSuccessorNominalConnectionSet(false);
					if (testIndiSuccConnNomSet) {
						for (CSuccessorConnectedNominalSet::const_iterator it = testIndiSuccConnNomSet->constBegin(), itEnd = testIndiSuccConnNomSet->constEnd(); it != itEnd; ++it) {
							dependentNominalIdList.append(*it);
						}
					}
					CSuccessorConnectedNominalSet* blockingIndiSuccConnNomSet = blockingIndi->getSuccessorNominalConnectionSet(false);
					if (blockingIndiSuccConnNomSet) {
						for (CSuccessorConnectedNominalSet::const_iterator it = blockingIndiSuccConnNomSet->constBegin(), itEnd = blockingIndiSuccConnNomSet->constEnd(); it != itEnd; ++it) {
							if (!testIndiSuccConnNomSet || !testIndiSuccConnNomSet->contains(*it)) {
								dependentNominalIdList.append(*it);
							}
						}
					}
					if (!dependentNominalIdList.isDetached()) {
						STATINC(FULLANALOGOUSPROPAGATIONBLOCKINGNOMINALSINVOLVEDCOUNT, calcAlgContext);
					}


					STATINC(FULLANALOGOUSPROPAGATIONBLOCKINGTESTCOUNT, calcAlgContext);
					// second: get associated concepts sets over these nodes
					QSet< QList< QSet<CConcept*> > > testIndiAllVariableMappingsAssociatedConceptsOverNodesListSet = getIndividualNodesListAssociatedConceptsSetFromVariablePropagationBindings(testIndi, ancestorIndiNode, dependentNominalIdList, calcAlgContext);
					QSet< QList< QSet<CConcept*> > > blockingIndiAllVariableMappingsAssociatedConceptsOverNodesListSet = getIndividualNodesListAssociatedConceptsSetFromVariablePropagationBindings(blockingIndi, ancestorBlockingIndi, dependentNominalIdList, calcAlgContext);


					KONCLUCE_TASK_ALGORITHM_VARIABLE_PROPAGATION_BLOCKING_DEBUGGING_INSTRUCTION(
						if (mConfDebuggingWriteData) {
							mAnalogousPropagationBlockingTestingIndiAllAssociatedConceptsString = generateDebugIndividualNodesListAssociatedConceptsSetString(testIndi, ancestorIndiNode, dependentNominalIdList, testIndiAllVariableMappingsAssociatedConceptsOverNodesListSet, "testing", calcAlgContext);
							mAnalogousPropagationBlockingBlockingIndiAllAssociatedConceptsString = generateDebugIndividualNodesListAssociatedConceptsSetString(blockingIndi, ancestorBlockingIndi, dependentNominalIdList, blockingIndiAllVariableMappingsAssociatedConceptsOverNodesListSet, "blocking", calcAlgContext);


							if (file.open(QIODevice::Append)) {
								file.write((QString("\r\n\r\n\r\nAdvanced analogous propagation blocking test with dependent nominals for testing individual %1 with blocking candidate %2\r\n").arg(testIndi->getIndividualNodeID()).arg(blockingIndi->getIndividualNodeID())).toLocal8Bit());
								QStringList dependentNominalIdStringList;
								for (cint64 id : dependentNominalIdList) {
									dependentNominalIdStringList.append(QString::number(id));
								}
								file.write((QString("Dependent nominals %1:\r\n").arg(dependentNominalIdStringList.join(", "))).toLocal8Bit());


								file.write((QString("\r\nAssociated concepts sets over nominals for testing individual %1:\r\n").arg(testIndi->getIndividualNodeID())).toLocal8Bit());
								file.write((mAnalogousPropagationBlockingTestingIndiAllAssociatedConceptsString).toLocal8Bit());
								file.write((QString("\r\nAssociated concepts sets over nominals for blocking individual %1:\r\n").arg(blockingIndi->getIndividualNodeID())).toLocal8Bit());
								file.write((mAnalogousPropagationBlockingBlockingIndiAllAssociatedConceptsString).toLocal8Bit());
								file.close();
							}
						}
					);


					// third: compare
					if (testIndiAllVariableMappingsAssociatedConceptsOverNodesListSet != blockingIndiAllVariableMappingsAssociatedConceptsOverNodesListSet) {
						STATINC(FULLANALOGOUSPROPAGATIONBLOCKINGFAILCOUNT, calcAlgContext);
						return false;
					}

					STATINC(FULLANALOGOUSPROPAGATIONBLOCKINGSUCCESSCOUNT, calcAlgContext);
					return true;
				}






				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIndividualNodeAssociatedConceptsString(cint64 indiNodeId, const QSet<CConcept*>& associatedConcepts, CCalculationAlgorithmContextBase* calcAlgContext) {
					QMap<cint64, QString> conTagConceptStringMap;
					for (QSet<CConcept*>::const_iterator it = associatedConcepts.constBegin(), itEnd = associatedConcepts.constEnd(); it != itEnd; ++it) {
						CConcept* concept(*it);
						//QString conceptString = CConceptTextFormater::getConceptString(concept, false);
						QString conceptString = QString::number(concept->getConceptTag());;
						conTagConceptStringMap.insert(concept->getConceptTag(), conceptString);
					}

					QString conceptsString;
					for (QMap<cint64, QString>::const_iterator it = conTagConceptStringMap.constBegin(), itEnd = conTagConceptStringMap.constEnd(); it != itEnd; ++it) {
						QString conceptString = it.value();
						if (!conceptsString.isEmpty()) {
							conceptsString += ", " + conceptString;
						} else {
							conceptsString = conceptString;
						}
					}
					return QString("%1 : {%2}").arg(indiNodeId).arg(conceptsString);
				}




				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIndividualNodeAssociatedConceptsSetString(CIndividualProcessNode*& individualNode, const QSet< QSet<CConcept*> >& allVariableMappingsAssociatedConceptsSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList allNodeListAssociatedConceptsStringList;

					for (QSet< QSet<CConcept*> >::const_iterator it = allVariableMappingsAssociatedConceptsSet.constBegin(), itEnd = allVariableMappingsAssociatedConceptsSet.constEnd(); it != itEnd; ++it) {

						const QSet<CConcept*>& testIndiAssociatedConcepts = *it;
						QString testIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsString(individualNode->getIndividualNodeID(), testIndiAssociatedConcepts, calcAlgContext);
						allNodeListAssociatedConceptsStringList.append(testIndiAssociatedConceptsString);
					}

					return allNodeListAssociatedConceptsStringList.join("<br>\n");
				}




				QString CCalculationTableauCompletionTaskHandleAlgorithm::generateDebugIndividualNodesListAssociatedConceptsSetString(CIndividualProcessNode*& individualNode, CIndividualProcessNode*& ancestorIndividualNode, const QList<cint64>& dependentNominalIdList, const QSet< QList< QSet<CConcept*> > >& allVariableMappingsAssociatedConceptsOverNodesListSet, const QString& nodeNaming, CCalculationAlgorithmContextBase* calcAlgContext) {
					QStringList allNodeListAssociatedConceptsStringList;

					for (QSet< QList< QSet<CConcept*> > >::const_iterator it = allVariableMappingsAssociatedConceptsOverNodesListSet.constBegin(), itEnd = allVariableMappingsAssociatedConceptsOverNodesListSet.constEnd(); it != itEnd; ++it) {
						const QList< QSet<CConcept*> >& nodeListAssociatedConcepts = *it;

						QList< QSet<CConcept*> >::const_iterator it2 = nodeListAssociatedConcepts.constBegin();

						QStringList nodeListAssociatedConceptsStringList;
						const QSet<CConcept*>& testIndiAssociatedConcepts = *it2;
						QString testIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsString(individualNode->getIndividualNodeID(), testIndiAssociatedConcepts, calcAlgContext);
						nodeListAssociatedConceptsStringList.append(QString("%1 node %2").arg(nodeNaming).arg(testIndiAssociatedConceptsString));
						++it2;

						const QSet<CConcept*>& ancestorTestIndiAssociatedConcepts = *it2;
						QString ancestorTestIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsString(ancestorIndividualNode->getIndividualNodeID(), ancestorTestIndiAssociatedConcepts, calcAlgContext);
						nodeListAssociatedConceptsStringList.append(QString("%1 predecessor %2").arg(nodeNaming).arg(ancestorTestIndiAssociatedConceptsString));
						++it2;

						QList<cint64>::const_iterator dependentNominalIdIt = dependentNominalIdList.constBegin();
						for (QList< QSet<CConcept*> >::const_iterator it2End = nodeListAssociatedConcepts.constEnd(); it2 != it2End; ++it2) {
							const QSet<CConcept*>& nominalIndiAssociatedConcepts = *it2;
							QString nominalIndiAssociatedConceptsString = generateDebugIndividualNodeAssociatedConceptsString(*dependentNominalIdIt, nominalIndiAssociatedConcepts, calcAlgContext);
							nodeListAssociatedConceptsStringList.append(QString("nominal node %1").arg(nominalIndiAssociatedConceptsString));
							++dependentNominalIdIt;
						}

						allNodeListAssociatedConceptsStringList.append(nodeListAssociatedConceptsStringList.join("  |||  "));

					}

					return allNodeListAssociatedConceptsStringList.join("<br>\n");
				}

























				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptOptimizedBlocking(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(OPTIMIZEDBLOCKINGTESTCOUNT,calcAlgContext);
					CIndividualProcessNode* wNode = testIndi;
					CIndividualProcessNode* wPredNode = blockingIndi;

					CReapplyConceptLabelSet* wSubConSet = wNode->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* wPredSuperConSet = wPredNode->getReapplyConceptLabelSet(false);
					CConceptDescriptor* firstNotEntailedConDes = nullptr;
					// B1 test
					bool equalSet = false;
					bool subSet = isLabelConceptSubSet(wSubConSet,wPredSuperConSet,&firstNotEntailedConDes,&equalSet,calcAlgContext);
					if (!subSet) {
						return false;
					}


					CIndividualProcessNode* vNode = getAncestorIndividual(wNode,calcAlgContext);
					CReapplyConceptLabelSet* vConSet = vNode->getReapplyConceptLabelSet(false);
					// B2 test

					CSuccessorRoleHash* ancRoleHash = wNode->getSuccessorRoleHash(false);
					if (!ancRoleHash) {
						// no inverse roles
						return true;
					}
					// assume blocking is possible
					bool blocked = true;

					cint64 violatingB2Restrictions = 0;
					cint64 violatingNonDetB2Restrictions = 0;

					CSuccessorRoleIterator baseAncRoleIt = ancRoleHash->getSuccessorRoleIterator(vNode->getIndividualNodeID());
					CSuccessorRoleIterator ancRoleIt1 = baseAncRoleIt;
					while (ancRoleIt1.hasNext() && blocked) {
						CIndividualLinkEdge* link = ancRoleIt1.next();
						// from w to v is a edge labeled with r, w is an inv(r)-successor of v
						CRole* role = link->getLinkRole();
						// B2, (ALL r. C) in w'
						CReapplyQueueIterator reapplyQuIt = wPredNode->getRoleReapplyIterator(role,false);
						while (reapplyQuIt.hasNext() && blocked) {
							CReapplyConceptDescriptor* reapplyConDes = reapplyQuIt.next();
							CConceptDescriptor* conDes = reapplyConDes->getConceptDescriptor();
							CConcept* concept = conDes->getConcept();
							bool conNeg = conDes->isNegated();
							cint64 conOpCode = concept->getOperatorCode();
							CConceptOperator* conOperator = concept->getConceptOperator();
							if (!conNeg && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE)) || conNeg && conOpCode == CCSOME) {
								// B2a
								CSortedNegLinker<CConcept*>* opLinkerIt = concept->getOperandList();
								while (opLinkerIt && blocked) {
									CConcept* opConcept = opLinkerIt->getData();
									bool opConNeg = opLinkerIt->isNegated() ^ conNeg;
									if (!vConSet->containsConcept(opConcept,opConNeg)) {
										blocked = false;
										CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
										bool nonDetDependency = depTrackPoint->getBranchingTag() > 0;
										++violatingB2Restrictions;
										if (nonDetDependency) {
											++violatingNonDetB2Restrictions;
										}
									}
									opLinkerIt = opLinkerIt->getNext();
								}
							} else if (!conNeg && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQAND_TYPE))) {
								// B2b, transitive and automate transitions
								if (!hasOptimizedBlockingB2AutomateTransitionOperands(concept,role,vConSet,calcAlgContext)) {
									blocked = false;
									CDependencyTrackPoint* depTrackPoint = conDes->getDependencyTrackPoint();
									bool nonDetDependency = depTrackPoint->getBranchingTag() > 0;
									++violatingB2Restrictions;
									if (nonDetDependency) {
										++violatingNonDetB2Restrictions;
									}
								}
							}
						}
					}

					CReapplyRoleSuccessorHash* wPredSuccHash = wPredNode->getReapplyRoleSuccessorHash(false);
					if (blocked) {

						// test c-blocked and a-blocked specific parts
						// B3, B5

						bool cBlocked = true;
						bool aBlocked = true;
						CSuccessorRoleIterator ancRoleIt2 = baseAncRoleIt;
						while (ancRoleIt2.hasNext() && blocked) {
							CIndividualLinkEdge* link = ancRoleIt2.next();
							CRole* role = link->getLinkRole();
							// B?, (ATMOST n r. C) in w'
							CReapplyQueueIterator reapplyQuIt = wPredNode->getRoleReapplyIterator(role,false);
							while (reapplyQuIt.hasNext() && blocked) {
								CReapplyConceptDescriptor* reapplyConDes = reapplyQuIt.next();
								CConceptDescriptor* conDes = reapplyConDes->getConceptDescriptor();
								CConcept* concept = conDes->getConcept();
								bool conNeg = conDes->isNegated();
								cint64 conOpCode = concept->getOperatorCode();

								bool checkBlockerRoleCardinality = false;
								cint64 blockerMinSuccCardinality = 0;
								CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();

								if (!conNeg && conOpCode == CCATMOST || conNeg && conOpCode == CCATLEAST) {
									cint64 cardinality = concept->getParameter();
									if (conNeg) {
										--cardinality;
									}

									CSortedNegLinker<CConcept*>* opLinkerIt = opLinker;
									if (!opLinkerIt) {
										cBlocked = false;
										if (!checkBlockerRoleCardinality) {
											checkBlockerRoleCardinality = true;
											blockerMinSuccCardinality = cardinality;
										}
									}
									while (opLinkerIt) {
										CConcept* opConcept = opLinkerIt->getData();
										bool opConNeg = opLinkerIt->isNegated();
										bool containsNeg = false;
										if (!vConSet->containsConcept(opConcept,&containsNeg)) {
											// contains not positive and negative
											cBlocked = false;
											if (!checkBlockerRoleCardinality) {
												checkBlockerRoleCardinality = true;
												blockerMinSuccCardinality = cardinality;
											}
										} else {
											if (containsNeg == opConNeg) {
												cBlocked = false;
												if (!checkBlockerRoleCardinality) {
													checkBlockerRoleCardinality = true;
													blockerMinSuccCardinality = cardinality;
												}
											}
										}
										opLinkerIt = opLinkerIt->getNext();
									}
								}


								if (checkBlockerRoleCardinality) {
									// count
									cint64 minRoleCardinality = 0;
									if (wPredSuccHash) {
										CRoleSuccessorLinkIterator succIt = wPredSuccHash->getRoleSuccessorLinkIterator(role);
										while (succIt.hasNext() && blocked) {
											CIndividualLinkEdge* succLink = succIt.next();
											CIndividualProcessNode* succIndiNode = getSuccessorIndividual(wPredNode,succLink,calcAlgContext);
											if (succIndiNode->isNominalIndividualNode() || succIndiNode->getNominalIndividual() || succIndiNode->getIndividualAncestorDepth() > wPredNode->getIndividualAncestorDepth()) {
												if (!opLinker) {
													++minRoleCardinality;
													if (minRoleCardinality >= blockerMinSuccCardinality) {
														blocked = false;
													}
												} else {
													if (containsIndividualNodeConcepts(succIndiNode,opLinker,false,calcAlgContext)) {
														++minRoleCardinality;
														if (minRoleCardinality >= blockerMinSuccCardinality) {
															blocked = false;
														}
													}
												}
											}
										}
									}
								}
							}
						}

						if (cBlocked) {
							// test whether B6 holds
							CReapplyConceptLabelSetIterator vConSetIt = vConSet->getConceptLabelSetIterator(false,false,false);
							while (cBlocked && vConSetIt.hasNext()) {
								CConceptDescriptor* conDes = vConSetIt.next();
								CConcept* concept = conDes->getConcept();
								bool conNeg = conDes->isNegated();
								cint64 conOpCode = concept->getOperatorCode();
								if (!conNeg && conOpCode == CCATLEAST || conNeg && conOpCode == CCATMOST) {
									cint64 cardinality = concept->getParameter() + 1*conNeg;
									if (cardinality > 1) {
										CRole* role = concept->getRole();
										if (hasIndividualsLink(vNode,wNode,role,false,calcAlgContext)) {
											CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
											if (opLinker) {
												if (!containsIndividualNodeConcepts(wSubConSet,opLinker,!conNeg,calcAlgContext)) {
													cBlocked = false;
												}
											} else {
												cBlocked = false;
											}
										}
									}
								}
							}
							if (cBlocked) {
								return true;
							}
						}
					}

					if (blocked) {
						// test whether B4 holds
						CReapplyConceptLabelSetIterator blockerConLabSetIt = wPredSuperConSet->getConceptLabelSetIterator(false,false,false);
						while (blockerConLabSetIt.hasNext() && blocked) {
							CConceptDescriptor* conDes = blockerConLabSetIt.next();
							CConcept* concept = conDes->getConcept();
							bool conNeg = conDes->isNegated();
							cint64 conOpCode = concept->getOperatorCode();
							CRole* role = concept->getRole();
							cint64 cardinality = concept->getParameter();
							CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();
							bool needsRestrictionTest = false;
							bool negateOps = false;
							if (!conNeg && conOpCode == CCATLEAST || conNeg && conOpCode == CCATMOST) {
								if (conNeg) {
									++cardinality;
								}
								needsRestrictionTest = true;
							} else if (!conNeg && (conOpCode == CCSOME || conOpCode == CCAQSOME) || conNeg && conOpCode == CCALL) {
								cardinality = 1;
								needsRestrictionTest = true;
								negateOps = conNeg;
							}

							if (needsRestrictionTest) {
								// B4b
								bool restrictionHolds = false;
								if (hasIndividualsLink(wNode,vNode,role,false,calcAlgContext)) {
									if (containsIndividualNodeConcepts(vConSet,opLinker,negateOps,calcAlgContext)) {
										restrictionHolds = true;
									}
								}
								if (!restrictionHolds) {
									// B4a
									// w' needs m role-successors
									cint64 minRoleCardinality = 0;
									if (wPredSuccHash) {
										CRoleSuccessorLinkIterator succIt = wPredSuccHash->getRoleSuccessorLinkIterator(role);
										while (succIt.hasNext()) {
											CIndividualLinkEdge* link = succIt.next();
											CIndividualProcessNode* succIndi = getSuccessorIndividual(wPredNode,link,calcAlgContext);
											if (succIndi->isNominalIndividualNode() || succIndi->getNominalIndividual() || succIndi->getIndividualAncestorDepth() > wPredNode->getIndividualAncestorDepth()) {
												if (!opLinker) {
													++minRoleCardinality;
												} else {
													if (containsIndividualNodeConcepts(succIndi,opLinker,negateOps,calcAlgContext)) {
														++minRoleCardinality;
													}
												}
											}
										}
									}
									if (minRoleCardinality < cardinality) {
										blocked = false;
									}
								}
							}
						}
					}


					if (!blocked && blockAltData && mConfSignatureMirroringBlocking && mOptSignatureMirroringBlockingInBlocking) {
						cint64 diffConceptCount = wPredSuperConSet->getConceptCount() - wSubConSet->getConceptCount();

						CBlockingAlternativeSignatureBlockingCandidateData* sigBlockCandData = nullptr;
						if (*blockAltData) {
							sigBlockCandData = dynamic_cast<CBlockingAlternativeSignatureBlockingCandidateData*>(*blockAltData);
						}
						if (!sigBlockCandData) {
							CMemoryAllocationManager* tempMemMan = calcAlgContext->getUsedTemporaryMemoryAllocationManager();
							sigBlockCandData = CObjectAllocator<CBlockingAlternativeSignatureBlockingCandidateData>::allocateAndConstruct(tempMemMan);
							sigBlockCandData->initSignatureBlockingCandidateData(wPredNode,violatingB2Restrictions,violatingNonDetB2Restrictions,diffConceptCount);
							*blockAltData = sigBlockCandData;
						} else {
							bool lessViolNonDetRes = violatingNonDetB2Restrictions < sigBlockCandData->getViolatedNonDeterministicRestrictionCount();
							bool lessViolRes = violatingB2Restrictions < sigBlockCandData->getViolatedRestrictionCount();
							bool lessConcepts = diffConceptCount < sigBlockCandData->getConceptDifferenceCount();

							double newScore = violatingNonDetB2Restrictions*1.2 + violatingB2Restrictions + diffConceptCount*0.1;
							double oldScore = sigBlockCandData->getViolatedNonDeterministicRestrictionCount()*1.2 + sigBlockCandData->getViolatedRestrictionCount() + sigBlockCandData->getConceptDifferenceCount()*0.1;

							if (newScore > oldScore) {
								sigBlockCandData->initSignatureBlockingCandidateData(wPredNode,violatingB2Restrictions,violatingNonDetB2Restrictions,diffConceptCount);
							}
						}
						


					}

					return blocked;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcept(CIndividualProcessNode*& testIndi, CConcept* conTest, bool* containsNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* conLabelSet = testIndi->getReapplyConceptLabelSet(false);
					return containsIndividualNodeConcept(conLabelSet,conTest,containsNegation,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcept(CReapplyConceptLabelSet* conLabelSet, CConcept* conTest, bool* containsNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool containsNeg = false;
					if (!conLabelSet->containsConcept(conTest,&containsNeg)) {
						return false;
					}
					if (containsNegation) {
						if (containsNeg) {
							*containsNegation = true;
						} else {
							*containsNegation = false;
						}
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcepts(CReapplyConceptLabelSet* conLabelSet, CSortedNegLinker<CConcept*>* conTestLinkerIt, bool* containsNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool containsAllNegated = true;
					bool containsAllNonNegated = true;
					if (!conTestLinkerIt) {
						// interpret as top
						if (containsNegation) {
							*containsNegation = false;
						}
						containsAllNegated = false; 
					}
					while (conTestLinkerIt && (containsAllNegated || containsAllNonNegated)) {
						CConcept* concept = conTestLinkerIt->getData();
						bool conNeg = conTestLinkerIt->isNegated();
						bool containsNeg = false;
						if (!conLabelSet->containsConcept(concept,&containsNeg)) {
							return false;
						}
						if (containsNeg == conNeg) {
							containsAllNegated = false;
						} else {
							containsAllNonNegated = false;
						}
						conTestLinkerIt = conTestLinkerIt->getNext();
					}
					if (containsNegation) {
						if (containsAllNegated) {
							*containsNegation = true;
							return true;
						} 
						if (containsAllNonNegated) {
							*containsNegation = false;
							return true;
						}
					}
					if (containsAllNonNegated) {
						return true;
					}
					if (containsAllNegated) {
						return true;
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcepts(CReapplyConceptLabelSet* conLabelSet, CSortedNegLinker<CConcept*>* conTestLinkerIt, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					while (conTestLinkerIt) {
						CConcept* concept = conTestLinkerIt->getData();
						bool conNeg = conTestLinkerIt->isNegated() ^ negated;
						if (!conLabelSet->containsConcept(concept,conNeg)) {
							return false;
						}
						conTestLinkerIt = conTestLinkerIt->getNext();
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcepts(CIndividualProcessNode*& testIndi, CSortedNegLinker<CConcept*>* conTestLinkerIt, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* conLabelSet = testIndi->getReapplyConceptLabelSet(false);
					return containsIndividualNodeConcepts(conLabelSet,conTestLinkerIt,negated,calcAlgContext);
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcepts(CIndividualProcessNode*& testIndi, CSortedNegLinker<CConcept*>* conTestLinkerIt, bool* containsNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* conLabelSet = testIndi->getReapplyConceptLabelSet(false);
					return containsIndividualNodeConcepts(conLabelSet,conTestLinkerIt,containsNegation,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::containsIndividualNodeConcepts(CIndividualProcessNode*& testIndi, CSortedNegLinker<CConcept*>* conTestLinkerIt, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyConceptLabelSet* conLabelSet = testIndi->getReapplyConceptLabelSet(false);
					return containsIndividualNodeConcepts(conLabelSet,conTestLinkerIt,(bool*)nullptr,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptSubSetBlocking(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(SUBSETBLOCKINGTESTCOUNT,calcAlgContext);
					if (testContinueBlocking) {
						// is still sub set when added something to blocker individual node
						return true;
					}
					CReapplyConceptLabelSet* subConSet = testIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* superConSet = blockingIndi->getReapplyConceptLabelSet(false);
					CConceptDescriptor* firstNotEntailedConDes = nullptr;
					bool subSet = isLabelConceptSubSet(subConSet,superConSet,&firstNotEntailedConDes,nullptr,calcAlgContext);
					return subSet;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptEqualBlocking(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(EQUALSETBLOCKINGTESTCOUNT,calcAlgContext);
					CReapplyConceptLabelSet* conSet1 = testIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* conSet2 = blockingIndi->getReapplyConceptLabelSet(false);
					return isLabelConceptEqualSet(conSet1,conSet2,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptEqualPairwiseBlocking(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(PAIRWISEEQUALSETBLOCKINGTESTCOUNT,calcAlgContext);
					CIndividualProcessNode* ancTestIndi = getAncestorIndividual(testIndi,calcAlgContext);
					if (!ancTestIndi) {
						return false;
					}
					CIndividualProcessNode* ancBlockingIndi = getAncestorIndividual(blockingIndi,calcAlgContext);
					if (!ancBlockingIndi) {
						return false;
					}
					CIndividualLinkEdge* testIndiAncLink = testIndi->getAncestorLink();
					CIndividualLinkEdge* blockingIndiAncLink = testIndi->getAncestorLink();
					if (testIndiAncLink->getLinkRole() != blockingIndiAncLink->getLinkRole()) {
						return false;
					}
					CReapplyConceptLabelSet* conSet1 = testIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* conSet1Pair = blockingIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* conSet2 = ancTestIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* conSet2Pair = ancBlockingIndi->getReapplyConceptLabelSet(false);
					return isPairwiseLabelConceptEqualSet(conSet1,conSet1Pair,conSet2,conSet2Pair,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeBlocking(CIndividualProcessNode*& testIndi, CIndividualProcessNode*& blockingIndi, CIndividualNodeBlockingTestData* blockData, bool testContinueBlocking, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODEBLOCKINGTESTCOUNT,calcAlgContext);
					// TODO: check config, first test concept set sizes

					CReapplyConceptLabelSet* testConSet = testIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* blockingConSet = blockingIndi->getReapplyConceptLabelSet(false);
					cint64 testConSetCount = testConSet->getConceptCount();
					cint64 blockingConSetCount = blockingConSet->getConceptCount();
					if (testConSetCount > blockingConSetCount) {
						return false;
					}

					if (!testContinueBlocking) {
						CConceptDescriptor* initConDes = testIndi->getIndividualInitializationConcept();
						if (initConDes) {
							if (!blockingIndi->getReapplyConceptLabelSet(false)->containsConceptDescriptor(initConDes)) {
								return false;
							}
						}
					}



					bool testProcessingBlocking = false;
					if (mOptDetExpPreporcessing) {
						testProcessingBlocking = true;
					}


					bool blockingConcepts = false;

					if (testProcessingBlocking || mConfSubSetBlocking) {
						if (isLabelConceptSubSetBlocking(testIndi,blockingIndi,blockData,testContinueBlocking,blockAltData,calcAlgContext)) {
							blockingConcepts = true;
						}
					} else if (mConfOptimizedSubSetBlocking) {
						if (isLabelConceptOptimizedBlocking(testIndi,blockingIndi,blockData,testContinueBlocking,blockAltData,calcAlgContext)) {
							blockingConcepts = true;
						}
					} else if (mConfEqualSetBlocking) {
						if (isLabelConceptEqualBlocking(testIndi,blockingIndi,blockData,testContinueBlocking,blockAltData,calcAlgContext)) {
							blockingConcepts = true;
						}
					} else if (mConfPairwiseEqualSetBlocking) {
						if (isLabelConceptEqualPairwiseBlocking(testIndi,blockingIndi,blockData,testContinueBlocking,blockAltData,calcAlgContext)) {
							blockingConcepts = true;
						}
					}

					bool blockingPropBindings = false;
					if (blockingConcepts) {
						if (mOptAnalogousPropagationPathBlocking) {
							blockingPropBindings = isAnonymousVariablePropagationBindingAnalogousPath(testIndi, blockingIndi, blockData, testContinueBlocking, blockAltData, calcAlgContext);
						} else {
							blockingPropBindings = isNominalVariablePropagationBindingSubSet(testIndi, blockingIndi, blockData, testContinueBlocking, blockAltData, calcAlgContext);
						}
					}

					return blockingConcepts && blockingPropBindings;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::detectIndividualNodeBlockedStatus(CIndividualProcessNode*& testIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(DETECTINDINODEBLOCKINGSTATUSCOUNT,calcAlgContext);
					bool previousProcessingBlocked = false;
					bool previousBlocked = testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED | CIndividualProcessNode::PRFINDIRECTBLOCKED | CIndividualProcessNode::PRFPROCESSINGBLOCKED);
					if (!mOptDetExpPreporcessing && testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED)) {
						testIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED);
						previousProcessingBlocked = true;
					} else if (mOptDetExpPreporcessing && testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED)) {
						return true;
					} else {
						if (!testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
							return previousBlocked;
						}
					}


					bool previousIndirectBlocked = testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINDIRECTBLOCKED);
					if (previousIndirectBlocked) {
						if (!testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
							testIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED);
							return true;
						}
					}

					bool previousDirectBlocked = testIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED);

					CIndividualProcessNode* ancTestIndi = testIndi;
					CIndividualProcessNode* blockingIndi = nullptr;

					CBlockingAlternativeData* blockAltData = nullptr;

					bool blocked = false;

					bool blockingTesting = true;
					if (!previousBlocked && mCompGraphCacheHandler && mConfIgnoreBlockingCompletionGraphCachedNonBlockingNodes) {
						if (mCompGraphCacheHandler->isIndividualNodeCompletionGraphConsistencePresentNonBlocked(testIndi, calcAlgContext)) {
							blockingTesting = false;
						}
					}



					// test each modified ancestor
					while (blockingTesting && !blocked && ancTestIndi && ancTestIndi->isBlockableIndividual() && !ancTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE) &&
								ancTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS) && 
								!ancTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
						STATINC(DETECTANCINDINODEBLOCKINGSTATUSCOUNT,calcAlgContext);
						CIndividualProcessNode* locAncTestIndi = getLocalizedIndividual(ancTestIndi,false,calcAlgContext);
						
						// search blocker node
						blockAltData = nullptr;
						blockingIndi = nullptr;

						if (mConfSaturationCachingTestingDuringBlockingTests) {
							detectIndividualNodeSaturationCached(locAncTestIndi,calcAlgContext);
						}

						bool skipBlockerSearch = false;
						if (locAncTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED) && locAncTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED)) {
							skipBlockerSearch = true;
						}

						if (!skipBlockerSearch) {
							blockingIndi = getBlockingIndividualNode(locAncTestIndi,&blockAltData,calcAlgContext);
						}

						locAncTestIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED 
								| CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS | CIndividualProcessNode::PRFDIRECTBLOCKED | CIndividualProcessNode::PRFINDIRECTBLOCKED | CIndividualProcessNode::PRFPROCESSINGBLOCKED);

						if (!blockingIndi) {
							STATINC(FAILEDBLOCKINGSTATUSDETECTIONCOUNT,calcAlgContext);
							if (blockAltData) {
								blocked = testAlternativeBlocked(locAncTestIndi,blockAltData,calcAlgContext);
							}
							if (!blocked) {
								locAncTestIndi->setBlockerIndividualNode(nullptr);
								ancTestIndi = getAncestorIndividual(locAncTestIndi,calcAlgContext);

								if (!previousBlocked && mCompGraphCacheHandler && mConfIgnoreBlockingCompletionGraphCachedNonBlockingNodes) {
									if (mCompGraphCacheHandler->isIndividualNodeCompletionGraphConsistencePresentNonBlocked(locAncTestIndi, calcAlgContext)) {
										blockingTesting = false;
									}
								}

							}
						} else {
							STATINC(SUCCESSBLOCKINGSTATUSDETECTIONCOUNT,calcAlgContext);

							//if (blockingIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
							//	propagateIndividualNodeNominalConnectionToAncestors(locAncTestIndi,calcAlgContext);
							//}
							if (blockingIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
								propagateIndividualNodeNominalConnectionStatusToAncestors(locAncTestIndi,blockingIndi,calcAlgContext);
							}


							bool testProcessingBlocking = false;
							if (mOptDetExpPreporcessing) {
								testProcessingBlocking = true;
							}


							locAncTestIndi->setBlockerIndividualNode(blockingIndi);
							locAncTestIndi->mDebugBlockerLastConceptDes = blockingIndi->getReapplyConceptLabelSet(false)->getAddingSortedConceptDescriptionLinker();


							if (!testProcessingBlocking) {
								CIndividualProcessNode* locBlockingNode = getLocalizedIndividual(blockingIndi,false,calcAlgContext);
								CXLinker<CIndividualProcessNode*>* blockedIndiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								blockedIndiNodeLinker->initLinker(locAncTestIndi);
								locBlockingNode->addBlockedIndividualsLinker(blockedIndiNodeLinker);
								locAncTestIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED);
							} else {
								locAncTestIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED);
								addIndividualToBlockingUpdateReviewProcessingQueue(blockingIndi,calcAlgContext);
							}
							propagateIndirectSuccessorBlocking(locAncTestIndi,calcAlgContext);
							blocked = true;
						}
					}



					if (!blockingIndi && previousBlocked) {
						reactivateIndirectBlockedSuccessors(testIndi,false,calcAlgContext);
					}
					return blocked;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getBlockingIndividualNode(CIndividualProcessNode* blockingTestIndi, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* blockingIndi = nullptr;
					if (!blockingIndi && mConfAnywhereBlockingLinkedCandidateHashSearch) {
						blockingIndi = getAnywhereBlockingIndividualNodeLinkedCanidateHashed(blockingTestIndi,blockAltData,calcAlgContext);
					}
					if (!blockingIndi && mConfAnywhereBlockingCandidateHashSearch) {
						blockingIndi = getAnywhereBlockingIndividualNodeCanidateHashed(blockingTestIndi,blockAltData,calcAlgContext);
					}
					if (!blockingIndi && mConfAnywhereBlockingSearch) {
						blockingIndi = getAnywhereBlockingIndividualNode(blockingTestIndi,blockAltData,calcAlgContext);
					} 
					if (!blockingIndi && mConfAncestorBlockingSearch) {
						blockingIndi = getAncestorBlockingIndividualNode(blockingTestIndi,blockAltData,calcAlgContext);
					}
					return blockingIndi;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::continueIndividualNodeBlock(CIndividualProcessNode*& indi, CIndividualNodeBlockingTestData* blockData, CIndividualProcessNode*& blockerIndiNode, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* blockingIndiNode = nullptr;
					if (blockData) {
						blockingIndiNode = blockData->getBlockingIndividualNode();
						if (blockingIndiNode) {
							STATINC(CONTINUEBLOCKINGTESTCOUNT,calcAlgContext);
							blockingIndiNode = getUpToDateIndividual(blockingIndiNode,calcAlgContext);
							if (blockingIndiNode->isBlockableIndividual() && isIndividualNodeValidBlocker(blockingIndiNode,calcAlgContext)) {
								if (isIndividualNodeBlocking(indi,blockingIndiNode,blockData,true,blockAltData,calcAlgContext)) {
									blockerIndiNode = blockingIndiNode;
									return true;
								}
							} else if (blockingIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED)) {
								CIndividualNodeBlockingTestData* candidateBlockData = (CIndividualNodeBlockingTestData*)blockingIndiNode->getIndividualBlockData(false);
								if (candidateBlockData) {
									CIndividualProcessNode* candidateBlockingIndiNode = candidateBlockData->getBlockingIndividualNode();
									if (candidateBlockingIndiNode && candidateBlockingIndiNode->isBlockableIndividual() && isIndividualNodeValidBlocker(candidateBlockingIndiNode, calcAlgContext)) {
										if (isIndividualNodeBlocking(indi, candidateBlockingIndiNode, blockData, true, blockAltData, calcAlgContext)) {
											blockerIndiNode = candidateBlockingIndiNode;
											blockData->setBlockingIndividualNode(candidateBlockingIndiNode);
											return true;
										}
									}
								}
							}
						}
					}
					return false;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::signatureCachedIndividualNodeBlock(CIndividualProcessNode*& indi, CIndividualNodeBlockingTestData* blockData, CIndividualProcessNode*& blockerIndiNode, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED)) {
						CSignatureBlockingIndividualNodeConceptExpansionData* sigBlockExpData = indi->getSignatureBlockingIndividualNodeConceptExpansionData(false);
						if (sigBlockExpData) {
							CIndividualProcessNode* blockingIndiNode = sigBlockExpData->getBlockerIndividualNode();
							if (blockingIndiNode) {
								blockingIndiNode = getUpToDateIndividual(blockingIndiNode,calcAlgContext);
								if (blockingIndiNode->isBlockableIndividual() && isIndividualNodeValidBlocker(blockingIndiNode,calcAlgContext)) {
									if (isIndividualNodeBlocking(indi,blockingIndiNode,blockData,false,blockAltData,calcAlgContext)) {
										blockerIndiNode = blockingIndiNode;
										return true;
									}
								}
							}
						}
					}
					return false;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::clearBlockingCache(CCalculationAlgorithmContextBase* calcAlgContext) {
					mCachedIndiAssociatedConceptSetHash.clear();
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAncestorBlockingIndividualNode(CIndividualProcessNode* blockingTestIndi, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					clearBlockingCache(calcAlgContext);
					CMemoryAllocationManager* taskMemMan = nullptr;
					CIndividualProcessNode* blockerNode = nullptr;
					CNodeSwitchHistory* nodeSwitchHistory = calcAlgContext->getUsedProcessingDataBox()->getNodeSwitchHistory(false);
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualNodeBlockingTestData* blockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(false);
					CIndividualNodeBlockingTestData* locBlockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(true);
					if (!locBlockData) {
						locBlockData = CObjectAllocator<CIndividualNodeBlockingTestData>::allocateAndConstruct(taskMemMan);
						locBlockData->initBlockData(blockData);
						blockingTestIndi->setIndividualBlockData(locBlockData);
					}
					cint64 prevNodeSwitchTag = locBlockData->getNodeSwitchTag();
					cint64 prevNodeConceptLabelModTag = locBlockData->getConceptLabelSetModificationTag();
					cint64 minTestIndiNodeID = 0;
					cint64 minTestAncIndiDepth = 0;
					locBlockData->updateNodeSwitchTag(calcAlgContext->getUsedProcessTagger());
					locBlockData->updateConceptLabelSetModificationTag(calcAlgContext->getUsedProcessTagger());

					CIndividualProcessNode* continueBlockingIndiNode = nullptr;
					if (continueIndividualNodeBlock(blockingTestIndi,locBlockData,continueBlockingIndiNode,blockAltData,calcAlgContext)) {
						blockerNode = continueBlockingIndiNode;
					} else {
						locBlockData->clearBlockingIndividualNode();
						if (signatureCachedIndividualNodeBlock(blockingTestIndi, locBlockData, continueBlockingIndiNode, blockAltData, calcAlgContext)) {
							blockerNode = continueBlockingIndiNode;
						} else {
							if (nodeSwitchHistory && locBlockData && prevNodeSwitchTag > 0) {
								nodeSwitchHistory->getMinIndividualAncestorDepthAndNodeID(prevNodeSwitchTag,minTestAncIndiDepth,minTestIndiNodeID);
								minTestIndiNodeID = qMax(minTestIndiNodeID,(cint64)0);
								minTestAncIndiDepth = qMax(minTestAncIndiDepth,(cint64)0);
							}
							CIndividualProcessNode* ancIndiNode = getAncestorIndividual(blockingTestIndi,calcAlgContext);
							while (!blockerNode && ancIndiNode && isIndividualNodeValidBlocker(ancIndiNode,calcAlgContext) && ancIndiNode->getIndividualAncestorDepth() >= minTestAncIndiDepth) {
								if (continueBlockingIndiNode != ancIndiNode) {
									STATINC(ANCESTORBLOCKINGSEARCHINDINODECOUNT,calcAlgContext);
									if (isIndividualNodeConceptLabelSetModified(ancIndiNode,prevNodeConceptLabelModTag,calcAlgContext) && isIndividualNodeBlocking(blockingTestIndi,ancIndiNode,locBlockData,false,blockAltData,calcAlgContext)) {
										blockerNode = ancIndiNode;
									}
								}
								if (!blockerNode) {
									ancIndiNode = getAncestorIndividual(ancIndiNode,calcAlgContext);
								}
							}
						}
					}
					locBlockData->setBlockingIndividualNode(blockerNode);
					return blockerNode;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAnywhereBlockingIndividualNode(CIndividualProcessNode* blockingTestIndi, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					clearBlockingCache(calcAlgContext);
					CMemoryAllocationManager* taskMemMan = nullptr;
					CIndividualProcessNode* blockerNode = nullptr;
					CNodeSwitchHistory* nodeSwitchHistory = calcAlgContext->getUsedProcessingDataBox()->getNodeSwitchHistory(false);
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualNodeBlockingTestData* blockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(false);
					CIndividualNodeBlockingTestData* locBlockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(true);
					if (!locBlockData) {
						locBlockData = CObjectAllocator<CIndividualNodeBlockingTestData>::allocateAndConstruct(taskMemMan);
						locBlockData->initBlockData(blockData);
						blockingTestIndi->setIndividualBlockData(locBlockData);
					}
					cint64 prevNodeSwitchTag = locBlockData->getNodeSwitchTag();
					cint64 prevNodeConceptLabelModTag = locBlockData->getConceptLabelSetModificationTag();
					cint64 minTestIndiNodeID = 0;
					cint64 minTestAncIndiDepth = 0;
					locBlockData->updateNodeSwitchTag(calcAlgContext->getUsedProcessTagger());
					locBlockData->updateConceptLabelSetModificationTag(calcAlgContext->getUsedProcessTagger());

					CIndividualProcessNode* continueBlockingIndiNode = nullptr;
					if (continueIndividualNodeBlock(blockingTestIndi,locBlockData,continueBlockingIndiNode,blockAltData,calcAlgContext)) {
						blockerNode = continueBlockingIndiNode;
					} else {
						locBlockData->clearBlockingIndividualNode();
						if (signatureCachedIndividualNodeBlock(blockingTestIndi, locBlockData, continueBlockingIndiNode, blockAltData, calcAlgContext)) {
							blockerNode = continueBlockingIndiNode;
						} else {
							cint64 lastContinueTestedBlockingIndiNodeID = -1;
							if (locBlockData->getBlockingIndividualNode()) {
								lastContinueTestedBlockingIndiNodeID = locBlockData->getBlockingIndividualNode()->getIndividualNodeID();
							}
							if (nodeSwitchHistory && locBlockData && prevNodeSwitchTag > 0) {
								nodeSwitchHistory->getMinIndividualAncestorDepthAndNodeID(prevNodeSwitchTag,minTestAncIndiDepth,minTestIndiNodeID);
								minTestIndiNodeID = qMax(minTestIndiNodeID,(cint64)0);
								minTestAncIndiDepth = qMax(minTestAncIndiDepth,(cint64)0);
							}
							cint64 prevIndiID = blockingTestIndi->getIndividualNodeID() - 1;
							CIndividualProcessNode* prevIndiNode = nullptr;
							while (!blockerNode && prevIndiID > 0 && prevIndiID >= minTestIndiNodeID) {
								if (prevIndiID != lastContinueTestedBlockingIndiNodeID) {
									prevIndiNode = getUpToDateIndividual(prevIndiID,calcAlgContext);
									if (prevIndiNode && isIndividualNodeValidBlocker(prevIndiNode, calcAlgContext) && isIndividualNodeConceptLabelSetModified(prevIndiNode, prevNodeConceptLabelModTag, calcAlgContext)) {

										bool invalidDescendant = false;
										if (prevIndiNode->getIndividualAncestorDepth() >= blockingTestIndi->getIndividualAncestorDepth()) {
											// make sure the candidate is not a descendant
											CIndividualProcessNode* ancPrevIndiNode = prevIndiNode;
											while (ancPrevIndiNode->getIndividualAncestorDepth() >= blockingTestIndi->getIndividualAncestorDepth() && !invalidDescendant) {
												if (ancPrevIndiNode->getIndividualNodeID() == blockingTestIndi->getIndividualNodeID()) {
													invalidDescendant = true;
												}
												ancPrevIndiNode = getAncestorIndividual(ancPrevIndiNode, calcAlgContext);
											}
										}


										if (!invalidDescendant) {
											STATINC(ANYWHEREBLOCKINGSEARCHINDINODECOUNT, calcAlgContext);
											if (isIndividualNodeBlocking(blockingTestIndi, prevIndiNode, locBlockData, false, blockAltData, calcAlgContext)) {
												blockerNode = prevIndiNode;
											}
										}
									}
								}
								--prevIndiID;
							}
						}
					}
					locBlockData->setBlockingIndividualNode(blockerNode);
					return blockerNode;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAnywhereBlockingIndividualNodeLinkedCanidateHashed(CIndividualProcessNode* blockingTestIndi, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					clearBlockingCache(calcAlgContext);
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualProcessNode* blockerNode = nullptr;
					CIndividualNodeBlockingTestData* blockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(false);
					CIndividualNodeBlockingTestData* locBlockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(true);
					if (!locBlockData) {
						locBlockData = CObjectAllocator<CIndividualNodeBlockingTestData>::allocateAndConstruct(taskMemMan);
						locBlockData->initBlockData(blockData);
						blockingTestIndi->setIndividualBlockData(locBlockData);
					}

					CIndividualProcessNode* continueBlockingIndiNode = nullptr;
					if (continueIndividualNodeBlock(blockingTestIndi,locBlockData,continueBlockingIndiNode,blockAltData,calcAlgContext)) {
						blockerNode = continueBlockingIndiNode;
					} else {
						locBlockData->clearBlockingIndividualNode();
						if (signatureCachedIndividualNodeBlock(blockingTestIndi, locBlockData, continueBlockingIndiNode, blockAltData, calcAlgContext)) {
							blockerNode = continueBlockingIndiNode;
						} else {
							cint64 lastContinueTestedBlockingIndiNodeID = -1;
							if (locBlockData->getBlockingIndividualNode()) {
								lastContinueTestedBlockingIndiNodeID = locBlockData->getBlockingIndividualNode()->getIndividualNodeID();
							}

							CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
							CBlockingIndividualNodeLinkedCandidateHash* blockingCandHash = procDataBox->getBlockingIndividualNodeLinkedCandidateHash(false);
							CReapplyConceptLabelSet* conSet = blockingTestIndi->getReapplyConceptLabelSet(false);
							CCoreConceptDescriptor* coreConDesLinker = conSet->getCoreConceptDescriptorLinker();
							cint64 blockingTestIndiID = blockingTestIndi->getIndividualNodeID();


							if (!coreConDesLinker) {

								blockerNode = getAnywhereBlockingIndividualNodeCanidateHashed(blockingTestIndi,blockAltData,calcAlgContext);

							} else {

								CBlockingIndividualNodeLinkedCandidateData* minBlockingIndNodeCandData = nullptr;
								cint64 minBlockingIndNodeCandDataCount = 0;
								CConceptDescriptor* minBlockingConDes = nullptr;

								CCoreConceptDescriptor* lastAddedCoreConDes = locBlockData->getLastAddedCoreConceptDescriptor();
								CConceptDescriptor* lastConDes = locBlockData->getLastCoreBlockingCandidateConceptDescriptor();
								cint64 lastNodeDiff = locBlockData->getLastCoreBlockingCandidateConceptNodeDifference();
								if (lastAddedCoreConDes != coreConDesLinker) {
									lastConDes = nullptr;
								}

								CBlockingIndividualNodeLinkedCandidateData* lastMinBlockingIndNodeCandData = nullptr;

								if (lastConDes) {
									CBlockingIndividualNodeLinkedCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(lastConDes,false);
									if (blockingCandData) {
										cint64 blockingIndNodeCandDataCount = blockingCandData->getCandidateCount();
										if (blockingIndNodeCandDataCount <= lastNodeDiff) {
											minBlockingIndNodeCandData = blockingCandData;
											minBlockingIndNodeCandDataCount = blockingIndNodeCandDataCount;
										}
									}
								}

								if (!minBlockingIndNodeCandData) {

									for (CCoreConceptDescriptor* coreConDesLinkerIt = coreConDesLinker; coreConDesLinkerIt; coreConDesLinkerIt = coreConDesLinkerIt->getNext()) {
										CConceptDescriptor* conDes = coreConDesLinkerIt->getConceptDesciptor();
										CBlockingIndividualNodeLinkedCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(conDes,false);
										if (blockingCandData) {
											cint64 blockingIndNodeCandDataCount = blockingCandData->getCandidateCount();
											if (!minBlockingIndNodeCandData || blockingIndNodeCandDataCount < minBlockingIndNodeCandDataCount) {

												lastMinBlockingIndNodeCandData = minBlockingIndNodeCandData;

												minBlockingIndNodeCandDataCount = blockingIndNodeCandDataCount;
												minBlockingIndNodeCandData = blockingCandData;
												minBlockingConDes = conDes;
											} else if (!lastMinBlockingIndNodeCandData) {
												lastMinBlockingIndNodeCandData = blockingCandData;
											}
										}
									}
								}

								locBlockData->setLastAddedCoreConceptDescriptor(coreConDesLinker);
								locBlockData->setLastCoreBlockingCandidateConceptDescriptor(minBlockingConDes);
								locBlockData->setLastCoreBlockingCandidateConceptNodeDifference(0);
								if (lastMinBlockingIndNodeCandData) {
									cint64 diffCount = lastMinBlockingIndNodeCandData->getCandidateCount();
									locBlockData->setLastCoreBlockingCandidateConceptNodeDifference(diffCount);
								}

								CBlockingIndividualNodeLinkedCandidateData* blockingCandData = minBlockingIndNodeCandData;
								if (blockingCandData) {
									CBlockingIndividualNodeLinker* blockingIndNodeLinker = blockingCandData->getBlockingCandidatesIndividualNodeLinker();
									while (blockingIndNodeLinker && !blockerNode) {
										CIndividualProcessNode* blockerCandIndiNode = blockingIndNodeLinker->getCandidateIndividualNode();
										cint64 blockerCandIndiNodeID = blockerCandIndiNode->getIndividualNodeID();

										if (blockerCandIndiNodeID != lastContinueTestedBlockingIndiNodeID && blockerCandIndiNodeID != blockingTestIndiID) {

											STATINC(ANYWHERECORECONCEPTBLOCKINGCANDIDATEHASHSEARCHINDINODECOUNT,calcAlgContext);
											CIndividualProcessNode* upBlockerCandIndiNode = getUpToDateIndividual(blockerCandIndiNode,calcAlgContext);

											if (isIndividualNodeValidBlocker(upBlockerCandIndiNode,calcAlgContext)) {

												bool invalidDescendant = false;
												if (upBlockerCandIndiNode->getIndividualAncestorDepth() >= blockingTestIndi->getIndividualAncestorDepth()) {
													// make sure the candidate is not a descendant
													CIndividualProcessNode* ancPrevIndiNode = upBlockerCandIndiNode;
													while (ancPrevIndiNode->getIndividualAncestorDepth() >= blockingTestIndi->getIndividualAncestorDepth() && !invalidDescendant) {
														if (ancPrevIndiNode->getIndividualNodeID() == blockingTestIndi->getIndividualNodeID()) {
															invalidDescendant = true;
														}
														ancPrevIndiNode = getAncestorIndividual(ancPrevIndiNode, calcAlgContext);
													}
												}


												if (!invalidDescendant) {
													if (isIndividualNodeBlocking(blockingTestIndi, upBlockerCandIndiNode, locBlockData, false, blockAltData, calcAlgContext)) {
														blockerNode = upBlockerCandIndiNode;
													}
												}
											}

										}

										blockingIndNodeLinker = blockingIndNodeLinker->getNext();
									}
								}

							}
						}
					}

					return blockerNode;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAnywhereBlockingIndividualNodeCanidateHashed(CIndividualProcessNode* blockingTestIndi, CBlockingAlternativeData** blockAltData, CCalculationAlgorithmContextBase* calcAlgContext) {
					clearBlockingCache(calcAlgContext);
					CMemoryAllocationManager* taskMemMan = nullptr;
					CIndividualProcessNode* blockerNode = nullptr;
					CNodeSwitchHistory* nodeSwitchHistory = calcAlgContext->getUsedProcessingDataBox()->getNodeSwitchHistory(false);
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualNodeBlockingTestData* blockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(false);
					CIndividualNodeBlockingTestData* locBlockData = (CIndividualNodeBlockingTestData*)blockingTestIndi->getIndividualBlockData(true);
					if (!locBlockData) {
						locBlockData = CObjectAllocator<CIndividualNodeBlockingTestData>::allocateAndConstruct(taskMemMan);
						locBlockData->initBlockData(blockData);
						blockingTestIndi->setIndividualBlockData(locBlockData);
					}
					cint64 prevNodeSwitchTag = locBlockData->getNodeSwitchTag();
					cint64 prevNodeConceptLabelModTag = locBlockData->getConceptLabelSetModificationTag();
					cint64 minTestIndiNodeID = 0;
					cint64 minTestAncIndiDepth = 0;

					CIndividualProcessNode* continueBlockingIndiNode = nullptr;
					if (continueIndividualNodeBlock(blockingTestIndi,locBlockData,continueBlockingIndiNode,blockAltData,calcAlgContext)) {
						blockerNode = continueBlockingIndiNode;
					} else {
						cint64 lastContinueTestedBlockingIndiNodeID = -1;
						if (locBlockData->getBlockingIndividualNode()) {
							lastContinueTestedBlockingIndiNodeID = locBlockData->getBlockingIndividualNode()->getIndividualNodeID();
						}
						if (nodeSwitchHistory && locBlockData && prevNodeSwitchTag > 0) {
							nodeSwitchHistory->getMinIndividualAncestorDepthAndNodeID(prevNodeSwitchTag,minTestAncIndiDepth,minTestIndiNodeID);
							minTestIndiNodeID = qMax(minTestIndiNodeID,(cint64)0);
							minTestAncIndiDepth = qMax(minTestAncIndiDepth,(cint64)0);
						}
						if (blockingTestIndi->getIndividualInitializationConcept()) {
							CBlockingIndividualNodeCandidateIterator indiNodeCandIt(getBlockingIndividualNodeCandidateIterator(blockingTestIndi,calcAlgContext));
							while (!blockerNode && indiNodeCandIt.hasNext()) {
								CIndividualProcessNode* indiNode = indiNodeCandIt.nextIndividualCandidate(true);
								CIndividualProcessNode* upIndiNode = getUpToDateIndividual(indiNode,calcAlgContext);
								cint64 upIndiNodeID = upIndiNode->getIndividualNodeID();
								if (upIndiNodeID != lastContinueTestedBlockingIndiNodeID) {
									if (upIndiNode->hasPurgedBlockedProcessingRestrictionFlags() || !upIndiNode->isBlockableIndividual()) {
										STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATEREMOVECOUNT,calcAlgContext);
										indiNodeCandIt.removeLastIndividualCandidate();
									} else if (isIndividualNodeValidBlocker(upIndiNode,calcAlgContext) && isIndividualNodeConceptLabelSetModified(upIndiNode,prevNodeConceptLabelModTag,calcAlgContext)) {
										STATINC(ANYWHEREBLOCKINGCANDIDATEHASHSEARCHINDINODECOUNT,calcAlgContext);
										if (isIndividualNodeBlocking(blockingTestIndi,upIndiNode,locBlockData,false,blockAltData,calcAlgContext)) {
											blockerNode = upIndiNode;
										}
									}
								}
							}
						} else {
							cint64 prevIndiID = blockingTestIndi->getIndividualNodeID() - 1;
							CIndividualProcessNode* prevIndiNode = nullptr;
							while (!blockerNode && prevIndiID > 0 && prevIndiID >= minTestIndiNodeID) {
								if (prevIndiID != lastContinueTestedBlockingIndiNodeID) {
									prevIndiNode = getUpToDateIndividual(prevIndiID,calcAlgContext);
									if (prevIndiNode && isIndividualNodeValidBlocker(prevIndiNode,calcAlgContext) && isIndividualNodeConceptLabelSetModified(prevIndiNode,prevNodeConceptLabelModTag,calcAlgContext)) {
										STATINC(ANYWHEREBLOCKINGCANDIDATEHASHSEARCHINDINODECOUNT,calcAlgContext);
										if (isIndividualNodeBlocking(blockingTestIndi,prevIndiNode,locBlockData,false,blockAltData,calcAlgContext)) {
											blockerNode = prevIndiNode;
										}
									}
								}
								--prevIndiID;
							}
						}
					}
					locBlockData->setBlockingIndividualNode(blockerNode);
					if (!blockerNode) {
						locBlockData->updateNodeSwitchTag(calcAlgContext->getUsedProcessTagger());
						locBlockData->updateConceptLabelSetModificationTag(calcAlgContext->getUsedProcessTagger());
					}
					return blockerNode;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualNodeCandidateForConcept(CIndividualProcessNode*& indi, CConceptDescriptor* conDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CBlockingIndividualNodeCandidateHash* blockingCandHash = procDataBox->getBlockingIndividualNodeCandidateHash(true);
					CBlockingIndividualNodeCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(conDes,true);
					STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATEADDCOUNT,calcAlgContext);
					blockingCandData->insertBlockingCandidateIndividualNode(indi);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualNodeCandidateForConcept(CIndividualProcessNode*& indi, CSortedNegLinker<CConcept*>* concepts, bool negated, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CBlockingIndividualNodeCandidateHash* blockingCandHash = procDataBox->getBlockingIndividualNodeCandidateHash(true);
					CSortedNegLinker<CConcept*>* conceptIt = concepts;
					while (conceptIt) {
						CConcept* concept = conceptIt->getData();
						bool conceptNeg = conceptIt->isNegated()^negated;
						CBlockingIndividualNodeCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(concept,conceptNeg,true);
						STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATEADDCOUNT,calcAlgContext);
						blockingCandData->insertBlockingCandidateIndividualNode(indi);
						cint64 opCode = concept->getOperatorCode();
						if (!conceptNeg && opCode == CCAND || conceptNeg && opCode == CCOR) {
							addIndividualNodeCandidateForConcept(indi,concept->getOperandList(),conceptNeg,calcAlgContext);
						}
						conceptIt = conceptIt->getNext();
					}
				}


				CBlockingIndividualNodeCandidateIterator CCalculationTableauCompletionTaskHandleAlgorithm::getBlockingIndividualNodeCandidateIterator(CIndividualProcessNode* blockingTestIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					cint64 testingIndiID = blockingTestIndi->getIndividualNodeID();
					CConceptDescriptor* initializationConceptDes = blockingTestIndi->getIndividualInitializationConcept();
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
					CNodeSwitchHistory* nodeSwitchHistory = procDataBox->getNodeSwitchHistory(false);
					// test whether hash has to be updated
					bool needsHashUpdate = true;
					CBlockingIndividualNodeCandidateHash* blockingCandHash = procDataBox->getBlockingIndividualNodeCandidateHash(true);
					CBlockingIndividualNodeCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(initializationConceptDes,true);
						
					if (mConfAnywhereBlockingLazyExactHashing) {
						cint64 maxValidIndiID = blockingCandData->getMaxValidIndividualID()+1;
						cint64 conLabelSetModTag = blockingCandData->getConceptLabelSetModificationTag();
						cint64 nodeSwitchTag = blockingCandData->getNodeSwitchTag();
						cint64 minTestIndiNodeID = 1;
						cint64 minTestAncIndiDepth = 0;
						if (nodeSwitchHistory && nodeSwitchTag > 0) {
							nodeSwitchHistory->getMinIndividualAncestorDepthAndNodeID(nodeSwitchTag,minTestAncIndiDepth,minTestIndiNodeID);
							minTestIndiNodeID = qMax(minTestIndiNodeID,(cint64)1);
							minTestAncIndiDepth = qMax(minTestAncIndiDepth,(cint64)0);
						}
						if (maxValidIndiID >= testingIndiID && minTestIndiNodeID >= testingIndiID) {
							needsHashUpdate = false;
						}
						if (needsHashUpdate) {
							STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATECOUNT,calcAlgContext);
							if (maxValidIndiID != testingIndiID) {
								// insert testing node
								STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATEADDCOUNT,calcAlgContext);
								blockingCandData->insertBlockingCandidateIndividualNode(blockingTestIndi);
							}
							cint64 destIndiID = qMin(maxValidIndiID,minTestIndiNodeID);
							destIndiID = qMax(destIndiID,(cint64)0);
							for (cint64 indiID = testingIndiID-1; indiID >= destIndiID; --indiID) {
								CIndividualProcessNode* indi = getUpToDateIndividual(indiID,calcAlgContext);
								if (indi && indi->isBlockableIndividual() && !indi->hasPurgedBlockedProcessingRestrictionFlags()) {
									if (indiID >= maxValidIndiID || isIndividualNodeConceptLabelSetModified(indi,conLabelSetModTag,calcAlgContext)) {
										if (indi->getReapplyConceptLabelSet(false)->containsConceptDescriptor(initializationConceptDes)) {
											// add to candidate hash
											STATINC(ANYWHEREBLOCKINGCANDIDATEHASHUDATEADDCOUNT,calcAlgContext);
											blockingCandData->insertBlockingCandidateIndividualNode(indi);
										}
									}
								}
							}
							CProcessTagger* processTagger = calcAlgContext->getUsedProcessTagger();
							blockingCandData->updateConceptLabelSetModificationTag(processTagger);
							blockingCandData->updateNodeSwitchTag(processTagger);
							blockingCandData->setMaxValidIndividualID(qMax(maxValidIndiID,testingIndiID));
						}
					}

					return blockingCandData->getBlockingCandidatesIndividualNodeIterator(blockingTestIndi);
				}








				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeModified(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool addIndividualToProcessingQueueDueToModification = false;
					if (!indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDRETESTDUETOMODIFICATION)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHEDRETESTDUETOMODIFICATION);
					}
					if (!indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED) && !indi->getNominalIndividual()) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED);
						propagateProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFBLOCKINGRETESTDUEANCESTORMODIFIED,true,
								CIndividualProcessNode::PRFDIRECTBLOCKED | CIndividualProcessNode::PRFINDIRECTBLOCKED | CIndividualProcessNode::PRFPROCESSINGBLOCKED,calcAlgContext);
						addIndividualToProcessingQueueDueToModification = true;
					}
					eliminiateBlockedIndividuals(indi,calcAlgContext);
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATISFIABLECACHEDDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATISFIABLECACHEDDUEDIRECTMODIFIED);
						addIndividualToProcessingQueueDueToModification = true;
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSIGNATUREBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSIGNATUREBLOCKINGCACHEDDUEDIRECTMODIFIED);
						addIndividualToProcessingQueueDueToModification = true;
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED);
						addIndividualToProcessingQueueDueToModification = true;
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATURATIONBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATURATIONBLOCKINGCACHEDDUEDIRECTMODIFIED);
						addIndividualToProcessingQueueDueToModification = true;
					}

					if (addIndividualToProcessingQueueDueToModification) {
						addIndividualToBlockingUpdateReviewProcessingQueue(indi,calcAlgContext);
					}

					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED);
						if (!addIndividualToProcessingQueueDueToModification) {
							addIndividualToBackendSynchronisationRetestQueue(indi,calcAlgContext);
						}
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDFULLEXPANSION)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED);
						if (!addIndividualToProcessingQueueDueToModification) {
							addIndividualToBackendDirectInfluenceExpansionQueue(indi, calcAlgContext);
						}
					}
					if (mOptIncrementalCompatibleExpansion && indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANDING) && !indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED)) {
						indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANSIONRETESTDUEDIRECTMODIFIED);
						addIndividualToIncrementalCompatibilityCheckingQueue(indi,calcAlgContext);
					}

					if (indi->isNominalIndividualNode() && indi->getNominalIndividual() && indi->isDelayedNominalProcessingQueued()) {
						indi->setDelayedNominalProcessingQueued(false);
						addIndividualToProcessingQueue(indi,calcAlgContext);
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndirectSuccessorBlocking(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingBlockedProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFINDIRECTBLOCKED,true,CIndividualProcessNode::PRFINDIRECTBLOCKED,calcAlgContext);
					propagateClearingProcessingRestrictionToSuccessors(indi, CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS, true, CIndividualProcessNode::PRFINDIRECTBLOCKED, calcAlgContext);
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::pruneSuccessors(CIndividualProcessNode*& indi, CIndividualProcessNode* ancestorIndi, bool removeNominalLinks, CCalculationAlgorithmContextBase* calcAlgContext) {
					indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED);

					eliminiateBlockedIndividuals(indi,calcAlgContext);

					if (removeNominalLinks && ancestorIndi) {
						cint64 ancIndiID = ancestorIndi->getIndividualNodeID();
						CConnectionSuccessorSet* connSuccSet = indi->getConnectionSuccessorSet(false);
						if (connSuccSet) {
							if (connSuccSet->getConnectionSuccessorCount() > 0) {
								CConnectionSuccessorSetIterator conSuccIt = connSuccSet->getConnectionSuccessorIterator();
								while (conSuccIt.hasNext()) {
									cint64 connID = conSuccIt.next(true);
									if (ancIndiID != connID) {
										CIndividualProcessNode* nomIndi = getUpToDateIndividual(connID,calcAlgContext);
										if (nomIndi->isNominalIndividualNode()) {
											CIndividualProcessNode* locNomIndi = getLocalizedIndividual(nomIndi,false,calcAlgContext);
											CSuccessorRoleIterator succRoleIt = locNomIndi->getSuccessorRoleIterator(indi);
											while (succRoleIt.hasNext()) {
												CIndividualLinkEdge* link = succRoleIt.next(true);
												locNomIndi->removeIndividualLink(link);
											}
											locNomIndi->removeIndividualConnection(indi);
										}
									}
								}
							}
						}
						CSuccessorIterator succIt = indi->getSuccessorIterator();
						while (succIt.hasNext()) {
							CIndividualLinkEdge* succLink = succIt.nextLink(true);							
							CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);
							if (succIndi->isNominalIndividualNode() && succIndi->getIndividualNodeID() != ancIndiID) {
								CIndividualProcessNode* locNomIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
								CSuccessorRoleIterator succRoleIt = locNomIndi->getSuccessorRoleIterator(indi);
								while (succRoleIt.hasNext()) {
									CIndividualLinkEdge* link = succRoleIt.next(true);
									locNomIndi->removeIndividualLink(link);
								}
								locNomIndi->removeIndividualConnection(indi);
							}
						}

					}
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						if (succLink->getCreatorIndividual()->getIndividualNodeID() == indi->getIndividualNodeID()) {
							CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);
							cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
							if (succAncDepth > ancDepth) {
								if (succIndi->isBlockableIndividual() && !succIndi->hasPurgedBlockedProcessingRestrictionFlags()) {
									CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
									pruneSuccessors(locSuccIndi,indi,true,calcAlgContext);
								}
							}
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateProcessingRestrictionToAncestor(CIndividualProcessNode*& indi, cint64 addRestrictionFlags, bool recursive, cint64 whileNotContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingProcessingRestrictionToAncestor(indi,addRestrictionFlags,recursive,whileNotContainsFlags,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateAddingProcessingRestrictionToAncestor(CIndividualProcessNode*& indi, cint64 addRestrictionFlags, bool recursive, cint64 whileNotContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (indi->hasIndividualAncestor()) {
						CIndividualProcessNode* ancIndi = getAncestorIndividual(indi,calcAlgContext);
						if (!ancIndi->hasPartialProcessingRestrictionFlags(whileNotContainsFlags)) {
							CIndividualProcessNode* locAncIndi = getLocalizedIndividual(ancIndi,false,calcAlgContext);
							locAncIndi->addProcessingRestrictionFlags(addRestrictionFlags);
							if (recursive) {
								propagateAddingProcessingRestrictionToAncestor(locAncIndi,addRestrictionFlags,recursive,whileNotContainsFlags,calcAlgContext);
							}
						}
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateProcessingRestrictionToSuccessors(CIndividualProcessNode*& indi, cint64 addRestrictionFlags, bool recursive, cint64 whileNotContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingProcessingRestrictionToSuccessors(indi,addRestrictionFlags,recursive,whileNotContainsFlags,calcAlgContext);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateAddingBlockedProcessingRestrictionToSuccessors(CIndividualProcessNode*& indi, cint64 addRestrictionFlags, bool recursive, cint64 whileNotContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (!succIndi->hasPartialProcessingRestrictionFlags(whileNotContainsFlags)) {
								CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
								locSuccIndi->addProcessingRestrictionFlags(addRestrictionFlags);
								if (recursive) {
									propagateAddingBlockedProcessingRestrictionToSuccessors(locSuccIndi,addRestrictionFlags,recursive,whileNotContainsFlags,calcAlgContext);
								}
								eliminiateBlockedIndividuals(locSuccIndi,calcAlgContext);
							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateAddingProcessingRestrictionToSuccessors(CIndividualProcessNode*& indi, cint64 addRestrictionFlags, bool recursive, cint64 whileNotContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (!succIndi->hasPartialProcessingRestrictionFlags(whileNotContainsFlags)) {
								CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
								locSuccIndi->addProcessingRestrictionFlags(addRestrictionFlags);
								if (recursive) {
									propagateAddingProcessingRestrictionToSuccessors(locSuccIndi,addRestrictionFlags,recursive,whileNotContainsFlags,calcAlgContext);
								}
							}
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateClearingProcessingRestrictionToSuccessors(CIndividualProcessNode*& indi, cint64 clearRestrictionFlags, bool recursive, cint64 whileContainsFlags, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(whileContainsFlags)) {
								CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
								locSuccIndi->clearProcessingRestrictionFlags(clearRestrictionFlags);
								if (recursive) {
									propagateClearingProcessingRestrictionToSuccessors(locSuccIndi,clearRestrictionFlags,recursive,whileContainsFlags,calcAlgContext);
								}
							}
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::reactivateIndirectBlockedSuccessors(CIndividualProcessNode*& indi, bool recursive, CCalculationAlgorithmContextBase* calcAlgContext) {
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINDIRECTBLOCKED)) {
								if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
									CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(succIndi,true,calcAlgContext);
									locBlockedIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS);
									addIndividualToProcessingQueue(locBlockedIndiNode,calcAlgContext);
								}
							}
						}
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::reactivateBlockedIndividuals(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CXLinker<CIndividualProcessNode*>* blockedIndiNodeIt = indi->getBlockedIndividualsLinker();
					while (blockedIndiNodeIt) {
						CIndividualProcessNode* blockedIndiNode = blockedIndiNodeIt->getData();
						if (!blockedIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED)) {
							CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,true,calcAlgContext);
							locBlockedIndiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED);
							addIndividualToProcessingQueue(locBlockedIndiNode,calcAlgContext);
						}
						blockedIndiNodeIt = blockedIndiNodeIt->getNext();
					}
					indi->clearBlockedIndividualsLinker();
					return true;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualProcessedAndReactivate(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mOptProcessedNodePropagation || mOptProcessedConsNodePropagation && indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONSNODEPREPARATIONINDINODE)) {
						if (!indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED)) {
							indi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED);

							if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED) || !hasAncestorIndividualNode(indi,calcAlgContext)) {
								// wake up next individual nodes

								searchReactivateIndividualsProcessedPropagated(indi,calcAlgContext);
							}
						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::searchReactivateIndividualsProcessedPropagated(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {


					CXLinker<CIndividualProcessNode*>* processingBlockedNodeLinker = indi->getProcessingBlockedIndividualsLinker();
					while (processingBlockedNodeLinker) {
						CIndividualProcessNode* blockedNode = processingBlockedNodeLinker->getData();
						CIndividualProcessNode* locBlockedNode = getLocalizedIndividual(blockedNode,true,calcAlgContext);
						locBlockedNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEPROCESSINGCOMPLETED);
						addIndividualToProcessingQueue(locBlockedNode,calcAlgContext);
						// set blocking retest flag, clear processing blocked flag
						processingBlockedNodeLinker = processingBlockedNodeLinker->getNext();
					}
					indi->clearBlockedIndividualsLinker();

					cint64 indiID = indi->getIndividualNodeID();

					// TODO: check multiple not processed ancestors
					CSuccessorIterator succIt = indi->getSuccessorIterator();
					cint64 ancDepth = indi->getIndividualAncestorDepth();
					while (succIt.hasNext()) {
						CIndividualLinkEdge* succLink = succIt.nextLink(true);
						CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
						cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
						if (succAncDepth > ancDepth) {
							if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED)) {
								// test whether have unprocessed nominals or ancestor
								bool allProcessedAncestor = true;
								CConnectionSuccessorSetIterator connIt = succIndi->getConnectionSuccessorIterator();
								while (allProcessedAncestor && connIt.hasNext()) {
									cint64 connIndiNodeID = connIt.next();
									if (connIndiNodeID != indiID) {
										CIndividualProcessNode* ancNomIndi = getUpToDateIndividual(connIndiNodeID,calcAlgContext);
										if (ancNomIndi->getIndividualAncestorDepth() >= ancDepth || ancNomIndi->isNominalIndividualNode()) {
											if (!ancNomIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED | CIndividualProcessNode::PRFANCESTORALLPROCESSED)) {
												allProcessedAncestor = false;
											}
										}
									}
								}
								if (allProcessedAncestor) {
									CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
									locSuccIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED);
									if (!locSuccIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED)) {
										if (locSuccIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED)) {
											locSuccIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEPROCESSINGCOMPLETED);
											addIndividualToProcessingQueue(locSuccIndi,calcAlgContext);
										}
									} else {
										// search recursive all nodes which has to be reactivated
										searchReactivateIndividualsProcessedPropagated(locSuccIndi,calcAlgContext);
									}
								}
							}
						}
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualUnprocessed(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mOptProcessedNodePropagation) {
						propagateIndividualUnprocessed(indi,false,calcAlgContext);
					} else if (mOptProcessedConsNodePropagation) {
						propagateIndividualUnprocessed(indi,true,calcAlgContext);
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualUnprocessed(CIndividualProcessNode*& indi, bool requiresConsFlag, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!requiresConsFlag || indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONSNODEPREPARATIONINDINODE)) {
						if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED)) {
							indi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGCOMPLETED);
							if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED)) {

								CSuccessorIterator succIt = indi->getSuccessorIterator();
								cint64 ancDepth = indi->getIndividualAncestorDepth();
								while (succIt.hasNext()) {
									CIndividualLinkEdge* succLink = succIt.nextLink(true);
									CIndividualProcessNode* succIndi = getSuccessorIndividual(indi,succLink,calcAlgContext);						
									cint64 succAncDepth = succIndi->getIndividualAncestorDepth();
									if (succAncDepth > ancDepth) {
										if (!succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED)) {
											CIndividualProcessNode* locSuccIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
											locSuccIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORALLPROCESSED);
											propagateIndividualUnprocessed(locSuccIndi,CIndividualProcessNode::PRFANCESTORALLPROCESSED,calcAlgContext);
										}
									}
								}

							}
						}
					}
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeProcessingBlocked(CIndividualProcessNode* blockingTestIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODEPROCESSINGBLOCKINGTESTCOUNT,calcAlgContext);
					if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENPROCESSINGDELAYING)) {
						return true;
					}
					if (blockingTestIndi->hasPurgedBlockedProcessingRestrictionFlags()) {
						return true;
					}
					if (isSaturationCachedProcessingBlocked(blockingTestIndi,calcAlgContext)) {
						return true;
					}
					if (isIndividualNodeCompletionGraphCached(blockingTestIndi,calcAlgContext)) {
						return true;
					}
					if (isSatisfiableCachedProcessingBlocked(blockingTestIndi,calcAlgContext)) {
						return true;
					}
					if (isSignatureBlockedProcessingBlocked(blockingTestIndi,calcAlgContext)) {
						return true;
					}
					if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFPROCESSINGBLOCKED)) {
						if (mOptDetExpPreporcessing) {
							return true;
						} else {
							return detectIndividualNodeBlockedStatus(blockingTestIndi,calcAlgContext);
						}
					}
					if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINDIRECTBLOCKED)) {
						if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
							return detectIndividualNodeBlockedStatus(blockingTestIndi,calcAlgContext);
						} else {
							return true;
						}
					}
					if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED)) {
						if (blockingTestIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED)) {
							return detectIndividualNodeBlockedStatus(blockingTestIndi,calcAlgContext);
						} else {
							return true;
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeExpansionBlocked(CIndividualProcessNode* blockingTestIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODEEXPANSIONBLOCKINGTESTCOUNT,calcAlgContext);
					return detectIndividualNodeBlockedStatus(blockingTestIndi,calcAlgContext);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::needsIndividualNodeExpansionBlockingTest(CConceptProcessDescriptor* conProDes, CIndividualProcessNode* blockingTestIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* conDes = conProDes->getConceptDescriptor();
					CConcept* concept = conDes->getConcept();
					double conPriority = conProDes->getProcessPriority().getPriority();
					bool conNeg = conDes->getNegation();
					cint64 opCode = concept->getOperatorCode();
					cint64 opCount = concept->getOperandCount();;
					cint64 parameter = concept->getParameter();
					bool needsBlockingTest = false;
					if (!conNeg) {
						switch (opCode) {
							case CCSOME : case CCATLEAST : case CCAQSOME: {
								needsBlockingTest = true; 
								break;
							}
							case CCOR : {
								if (mOptNonStrictIndiNodeProcessing) {
									if (opCount >= 1) {
										needsBlockingTest = true; 
									}
								}
								break;
							}
							case CCATMOST : {
								if (mOptNonStrictIndiNodeProcessing) {
									if (parameter > 1) {
										needsBlockingTest = true; 
									}
								}
								break;
							}
						}
					} else {
						switch (opCode) {
							case CCALL : case CCATMOST : {
								needsBlockingTest = true; 
								break;
							}
							case CCAND : case CCEQ : {
								if (mOptNonStrictIndiNodeProcessing) {
									if (opCount >= 1) {
										needsBlockingTest = true; 
									}
								}
								break;
							}
							case CCATLEAST : {
								if (mOptNonStrictIndiNodeProcessing) {
									if (parameter > 2) {
										needsBlockingTest = true; 
									}
								}
								break;
							}
						}

					}
					return needsBlockingTest;
				}









				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasAncestorIndividualNode(CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* ancIndi = nullptr;
					CIndividualLinkEdge* ancLink = processIndi->getAncestorLink();
					return ancLink != nullptr;

				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasRoleSuccessorConcept(CIndividualProcessNode*& processIndi, CRole* role, CConcept* concept, bool conceptNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					if (roleSuccHash) {
						CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
						while (roleSuccIt.hasNext()) {
							CIndividualLinkEdge* link = roleSuccIt.next();
							CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
							CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);
							bool contained = conLabelSet->hasConcept(concept,conceptNegation);
							if (contained) {
								return true;
							}
						}
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasRoleSuccessorConcepts(CIndividualProcessNode*& processIndi, CRole* role, CSortedNegLinker<CConcept*>* conceptLinker, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					if (roleSuccHash) {
						CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
						while (roleSuccIt.hasNext()) {
							bool allContained = true;
							CIndividualLinkEdge* link = roleSuccIt.next();
							CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
							CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);
							CSortedNegLinker<CConcept*>* conceptLinkerIt = conceptLinker;
							while (conceptLinkerIt && allContained) {
								CConcept* concept = conceptLinkerIt->getData();
								bool conceptNegation = conceptLinkerIt->isNegated() ^ negate;
								bool contained = conLabelSet->hasConcept(concept,conceptNegation);
								allContained &= contained;
								conceptLinkerIt = conceptLinkerIt->getNext();
							}
							if (allContained) { 
								if (processIndi->isIndividualAncestor(succIndi)) {
								}
								return true;
							}
						}
					}
					return false;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getRoleSuccessorWithConcepts(CIndividualProcessNode*& processIndi, CRole* role, CSortedNegLinker<CConcept*>* conceptLinker, bool negate, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					if (roleSuccHash) {
						CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
						while (roleSuccIt.hasNext()) {
							bool allContained = true;
							CIndividualLinkEdge* link = roleSuccIt.next();
							CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
							CReapplyConceptLabelSet* conLabelSet = succIndi->getReapplyConceptLabelSet(false);
							CSortedNegLinker<CConcept*>* conceptLinkerIt = conceptLinker;
							while (conceptLinkerIt && allContained) {
								CConcept* concept = conceptLinkerIt->getData();
								bool conceptNegation = conceptLinkerIt->isNegated() ^ negate;
								bool contained = conLabelSet->hasConcept(concept,conceptNegation);
								allContained &= contained;
								conceptLinkerIt = conceptLinkerIt->getNext();
							}
							if (allContained) { 
								return succIndi;
							}
						}
					}
					return nullptr;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasDistinctRoleSuccessorConcepts(CIndividualProcessNode*& processIndi, CRole* role, CSortedNegLinker<CConcept*>* conceptLinker, bool negate, cint64 distinctCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyRoleSuccessorHash* roleSuccHash = processIndi->getReapplyRoleSuccessorHash(false);
					if (roleSuccHash) {
						CRoleSuccessorLinkIterator roleSuccIt = roleSuccHash->getRoleSuccessorLinkIterator(role);
						while (roleSuccIt.hasNext()) {
							bool allContained = true;
							CIndividualLinkEdge* link = roleSuccIt.next();
							CIndividualProcessNode* succIndi = getSuccessorIndividual(processIndi,link,calcAlgContext);
							cint64 succIndiID = succIndi->getIndividualNodeID();
							CDistinctHash* disHash = succIndi->getDistinctHash(false);
							if (disHash) {
								cint64 maxSuccDisCount = disHash->getDistinctCount()+1;
								if (maxSuccDisCount >= distinctCount && containsIndividualNodeConcepts(succIndi,conceptLinker,negate,calcAlgContext)) {
									cint64 succDisCount = 1;
									cint64 failDisCount = 0;
									CDistinctIterator disIt = disHash->getDistinctIterator();
									while (disIt.hasNext() && maxSuccDisCount-failDisCount >= distinctCount && succDisCount < distinctCount) {
										cint64 disIndiID = disIt.nextDistinctIndividualID();
										if (disIndiID != succIndiID && processIndi->hasRoleSuccessorToIndividual(role,disIndiID,true)) {
											// check has necessary concept
											if (disIndiID < succIndiID) {
												// the combination has been already checked, where successor individual node had the smaller ID
												break;
											}											
											CIndividualProcessNode* disIndi = getUpToDateIndividual(disIndiID,calcAlgContext);
											if (containsIndividualNodeConcepts(disIndi,conceptLinker,negate,calcAlgContext)) {
												++succDisCount;
											} else {
												++failDisCount;
											}
										}
									}
									if (succDisCount >= distinctCount) {
										return true;
									}
								}
							}
						}
					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::createIndividualNodeDisjointRolesLinks(CIndividualProcessNode*& sourceIndi, CIndividualProcessNode*& destinationIndi, CSortedNegLinker<CRole*>* disjointRoleLinker, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (disjointRoleLinker) {
						CMemoryAllocationManager* taskMemMan = nullptr;
						taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

						CSortedNegLinker<CRole*>* disjointRoleLinkerIt = disjointRoleLinker;
						while (disjointRoleLinkerIt) {
							CRole* disjointRole = disjointRoleLinkerIt->getData();

							// add negation / disjoint edge
							CNegationDisjointEdge* negDisEdge = CObjectParameterizingAllocator< CNegationDisjointEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
							negDisEdge->initNegationDisjointEdge(sourceIndi,destinationIndi,disjointRole,depTrackPoint);

							CIndividualLinkEdge* linkIndi = sourceIndi->getRoleSuccessorToIndividualLink(disjointRole,destinationIndi,true);
							if (linkIndi) {
								// create clash
								CClashedDependencyDescriptor* clashDes = nullptr;
								clashDes = createClashedIndividualLinkDescriptor(clashDes,linkIndi,linkIndi->getDependencyTrackPoint(),calcAlgContext);
								clashDes = createClashedNegationDisjointDescriptor(clashDes,negDisEdge,depTrackPoint,calcAlgContext);
								throw CCalculationClashProcessingException(clashDes);
							} else {
								sourceIndi->setDisjointRoleConnections(true);
								destinationIndi->setDisjointRoleConnections(true);
								sourceIndi->installDisjointLink(negDisEdge);
							}
							disjointRoleLinkerIt = disjointRoleLinkerIt->getNext();
						}
						// it is not necessary to install to the destination individual node the connection from the source node, the disjoint roles have a role link which does this already
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::createIndividualNodeNegationLink(CIndividualProcessNode*& sourceIndi, CIndividualProcessNode*& destinationIndi, CRole* negationRole, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CNegationDisjointEdge* negDisEdge = CObjectParameterizingAllocator< CNegationDisjointEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
					negDisEdge->initNegationDisjointEdge(sourceIndi,destinationIndi,negationRole,depTrackPoint);

					CIndividualLinkEdge* linkIndi = sourceIndi->getRoleSuccessorToIndividualLink(negationRole,destinationIndi,true);
					if (linkIndi) {
						// create clash
						CClashedDependencyDescriptor* clashDes = nullptr;
						clashDes = createClashedIndividualLinkDescriptor(clashDes,linkIndi,linkIndi->getDependencyTrackPoint(),calcAlgContext);
						clashDes = createClashedNegationDisjointDescriptor(clashDes,negDisEdge,depTrackPoint,calcAlgContext);
						throw CCalculationClashProcessingException(clashDes);
					} else {
						// add negation / disjoint edge
						sourceIndi->installDisjointLink(negDisEdge);
						sourceIndi->setDisjointRoleConnections(true);
						destinationIndi->setDisjointRoleConnections(true);
						destinationIndi->getConnectionSuccessorSet(true)->insertConnectionSuccessor(sourceIndi->getIndividualNodeID());
					}
				}


		




				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeNewNominalConnectionToAncestors(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateIndividualNodeNominalConnectionFlagsToAncestors(indi,CIndividualProcessNode::PRFSUCCESSORNEWNOMINALCONNECTION | CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeNominalConnectionToAncestors(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateIndividualNodeNominalConnectionFlagsToAncestors(indi,CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeNominalConnectionFlagsToAncestors(CIndividualProcessNode*& indi, cint64 nominalPropagationFlags, CCalculationAlgorithmContextBase* calcAlgContext) {

					CIndividualProcessNode* ancIndi = indi;
					while (ancIndi && !ancIndi->hasPartialProcessingRestrictionFlags(nominalPropagationFlags)) {
						ancIndi->addProcessingRestrictionFlags(nominalPropagationFlags);

						CXLinker<CIndividualProcessNode*>* procBlockIndiLinkerIt = ancIndi->getProcessingBlockedIndividualsLinker();
						while (procBlockIndiLinkerIt) {
							CIndividualProcessNode* blockedIndiNode = procBlockIndiLinkerIt->getData();
							if (!blockedIndiNode->hasPartialProcessingRestrictionFlags(nominalPropagationFlags)) {
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,true,calcAlgContext);
								propagateIndividualNodeNominalConnectionFlagsToAncestors(locBlockedIndiNode,nominalPropagationFlags,calcAlgContext);
							}
							procBlockIndiLinkerIt = procBlockIndiLinkerIt->getNext();
						}
						CXLinker<CIndividualProcessNode*>* blockedIndiLinkerIt = ancIndi->getBlockedIndividualsLinker();
						while (blockedIndiLinkerIt) {
							CIndividualProcessNode* blockedIndiNode = blockedIndiLinkerIt->getData();
							if (!blockedIndiNode->hasPartialProcessingRestrictionFlags(nominalPropagationFlags)) {
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,true,calcAlgContext);
								propagateIndividualNodeNominalConnectionFlagsToAncestors(locBlockedIndiNode,nominalPropagationFlags,calcAlgContext);
							}
							blockedIndiLinkerIt = blockedIndiLinkerIt->getNext();
						}
						CBlockingFollowSet* followSet = ancIndi->getBlockingFollowSet(false);
						if (followSet) {
							for (CBlockingFollowSet::const_iterator it = followSet->constBegin(), itEnd = followSet->constEnd(); it != itEnd; ++it) {
								cint64 blockedIndiNodeID = *it;
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNodeID,calcAlgContext);
								propagateIndividualNodeNominalConnectionFlagsToAncestors(locBlockedIndiNode,nominalPropagationFlags,calcAlgContext);
							}
						}
						if (ancIndi->hasSuccessorIndividualNodeBackwardDependencyLinker()) {
							CXLinker<CIndividualProcessNode*>* succIndiNodeBackwardDepLinkerIt = ancIndi->getSuccessorIndividualNodeBackwardDependencyLinker();
							while (succIndiNodeBackwardDepLinkerIt) {
								CIndividualProcessNode* succIndiNodeBackwardDep = succIndiNodeBackwardDepLinkerIt->getData();
								if (ancIndi->hasSuccessorIndividualNode(succIndiNodeBackwardDep) && !succIndiNodeBackwardDep->hasPartialProcessingRestrictionFlags(nominalPropagationFlags)) {
									CIndividualProcessNode* locSuccIndiNodeBackwardDep = getLocalizedIndividual(succIndiNodeBackwardDep,true,calcAlgContext);
									propagateIndividualNodeNominalConnectionFlagsToAncestors(locSuccIndiNodeBackwardDep,nominalPropagationFlags,calcAlgContext);
								}
								succIndiNodeBackwardDepLinkerIt = succIndiNodeBackwardDepLinkerIt->getNext();
							}
						}

						if (ancIndi->hasIndividualAncestor()) {
							ancIndi = getAncestorIndividual(ancIndi,calcAlgContext);
							CIndividualProcessNode* locAncIndi = getLocalizedIndividual(ancIndi,false,calcAlgContext);
							ancIndi = locAncIndi;
						} else {
							ancIndi = nullptr;
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeNominalConnectionStatusToAncestors(CIndividualProcessNode*& indi, CIndividualProcessNode* copyFromIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (copyFromIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION) || copyFromIndiNode->isNominalIndividualNode()) {
						if (mConfExactNominalDependencyTracking) {
							CSuccessorConnectedNominalSet* copySuccConnNomSet = copyFromIndiNode->getSuccessorNominalConnectionSet(false);
							if (copySuccConnNomSet) {
								for (CSuccessorConnectedNominalSet::const_iterator it = copySuccConnNomSet->constBegin(), itEnd = copySuccConnNomSet->constEnd(); it != itEnd; ++it) {
									cint64 nominalID = *it;
									if (!indi->hasSuccessorConnectionToNominal(nominalID)) {
										propagateIndividualNodeConnectedNominalToAncestors(indi,nominalID,calcAlgContext);
									}
								}
							}
						}
						if (copyFromIndiNode->isNominalIndividualNode()) {
							CIndividual* nominalIndi = copyFromIndiNode->getNominalIndividual();
							if (mConfExactNominalDependencyTracking && nominalIndi) {
								cint64 nominalID = -nominalIndi->getIndividualID();
								if (!indi->hasSuccessorConnectionToNominal(nominalID)) {
									propagateIndividualNodeConnectedNominalToAncestors(indi,nominalID,calcAlgContext);
								}
							}
							cint64 level = copyFromIndiNode->getIndividualNominalLevelOrAncestorDepth();
							if (!nominalIndi || level > 0) {
								propagateIndividualNodeNewNominalConnectionToAncestors(indi,calcAlgContext);
							}
						}
						if (!indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
							propagateIndividualNodeNominalConnectionToAncestors(indi,calcAlgContext);
						}


						if (copyFromIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNEWNOMINALCONNECTION)) {
							propagateIndividualNodeNewNominalConnectionToAncestors(indi,calcAlgContext);
						}
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeConnectedNominalToAncestors(CIndividualProcessNode*& indi, cint64 nominalID, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 nominalPropagationFlags = CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION;
					CIndividualProcessNode* ancIndi = indi;
					while (ancIndi && !ancIndi->hasSuccessorConnectionToNominal(nominalID)) {
						markIndividualNodeBackendNonConceptSetRelatedProcessing(ancIndi, calcAlgContext);
						ancIndi->addProcessingRestrictionFlags(nominalPropagationFlags);
						ancIndi->addSuccessorConnectionToNominal(nominalID);

						CXLinker<CIndividualProcessNode*>* procBlockIndiLinkerIt = ancIndi->getProcessingBlockedIndividualsLinker();
						while (procBlockIndiLinkerIt) {
							CIndividualProcessNode* blockedIndiNode = procBlockIndiLinkerIt->getData();
							if (!blockedIndiNode->hasSuccessorConnectionToNominal(nominalID)) {
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,true,calcAlgContext);
								propagateIndividualNodeConnectedNominalToAncestors(locBlockedIndiNode,nominalID,calcAlgContext);
							}
							procBlockIndiLinkerIt = procBlockIndiLinkerIt->getNext();
						}
						CXLinker<CIndividualProcessNode*>* blockedIndiLinkerIt = ancIndi->getBlockedIndividualsLinker();
						while (blockedIndiLinkerIt) {
							CIndividualProcessNode* blockedIndiNode = blockedIndiLinkerIt->getData();
							if (!blockedIndiNode->hasSuccessorConnectionToNominal(nominalID)) {
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNode,true,calcAlgContext);
								propagateIndividualNodeConnectedNominalToAncestors(locBlockedIndiNode,nominalID,calcAlgContext);
							}
							blockedIndiLinkerIt = blockedIndiLinkerIt->getNext();
						}
						CBlockingFollowSet* followSet = ancIndi->getBlockingFollowSet(false);
						if (followSet) {
							for (CBlockingFollowSet::const_iterator it = followSet->constBegin(), itEnd = followSet->constEnd(); it != itEnd; ++it) {
								cint64 blockedIndiNodeID = *it;
								CIndividualProcessNode* locBlockedIndiNode = getLocalizedIndividual(blockedIndiNodeID,calcAlgContext);
								propagateIndividualNodeConnectedNominalToAncestors(locBlockedIndiNode,nominalID,calcAlgContext);
							}
						}
						if (ancIndi->hasSuccessorIndividualNodeBackwardDependencyLinker()) {
							CXLinker<CIndividualProcessNode*>* succIndiNodeBackwardDepLinkerIt = ancIndi->getSuccessorIndividualNodeBackwardDependencyLinker();
							while (succIndiNodeBackwardDepLinkerIt) {
								CIndividualProcessNode* succIndiNodeBackwardDep = succIndiNodeBackwardDepLinkerIt->getData();
								if (ancIndi->hasSuccessorIndividualNode(succIndiNodeBackwardDep) && !succIndiNodeBackwardDep->hasSuccessorConnectionToNominal(nominalID)) {
									CIndividualProcessNode* locSuccIndiNodeBackwardDep = getLocalizedIndividual(succIndiNodeBackwardDep,true,calcAlgContext);
									propagateIndividualNodeConnectedNominalToAncestors(locSuccIndiNodeBackwardDep,nominalID,calcAlgContext);
								}
								succIndiNodeBackwardDepLinkerIt = succIndiNodeBackwardDepLinkerIt->getNext();
							}
						}

						if (ancIndi->hasIndividualAncestor()) {
							ancIndi = getAncestorIndividual(ancIndi,calcAlgContext);
							CIndividualProcessNode* locAncIndi = getLocalizedIndividual(ancIndi,false,calcAlgContext);
							ancIndi = locAncIndi;
						} else {
							ancIndi = nullptr;
						}
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndividualNodeNeighboursNominalConnectionToAncestors(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConnectionSuccessorSetIterator conSuccIt = indi->getConnectionSuccessorIterator();
					while (conSuccIt.hasNext()) {
						cint64 neighbourID = conSuccIt.nextSuccessorConnectionID();
						CIndividualProcessNode* neighbourIndiNode = getUpToDateIndividual(neighbourID,calcAlgContext);
						if (!neighbourIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
							CIndividualProcessNode* locNeighbourIndiNode = getLocalizedIndividual(neighbourIndiNode,false,calcAlgContext);
							propagateIndividualNodeNominalConnectionStatusToAncestors(locNeighbourIndiNode,indi,calcAlgContext);
						}
					}
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodesMergeableWithoutNewRuleApplications(CIndividualProcessNode* mergeIntoIndi1, CIndividualProcessNode* indi2, bool* mergingPossiblyRequiresRuleApplications, bool cancelOnPossiblyNewRuleApplications, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODESMERGEABLETESTCOUNT, calcAlgContext);
					CDistinctHash* disHash = mergeIntoIndi1->getDistinctHash(false);
					STATINC(INDINODESMERGEABLEDISTINCTTESTCOUNT, calcAlgContext);


					bool labelIsSubsetByIgnoringNominals = false;
					if (isLabelConceptClashSet(indi2->getReapplyConceptLabelSet(false), mergeIntoIndi1->getReapplyConceptLabelSet(false), &labelIsSubsetByIgnoringNominals, true, calcAlgContext)) {
						return false;
					} else {
						if (mergingPossiblyRequiresRuleApplications) {
							if (!labelIsSubsetByIgnoringNominals) {
								*mergingPossiblyRequiresRuleApplications = true;
								if (cancelOnPossiblyNewRuleApplications) {
									return false;
								}
							}
						}
					}


					if (mergingPossiblyRequiresRuleApplications && labelIsSubsetByIgnoringNominals) {
						CReapplyConceptLabelSetIterator conIt = mergeIntoIndi1->getReapplyConceptLabelSet(false)->getConceptLabelSetIterator(false, false, false);
						while (conIt.hasNext() && !*mergingPossiblyRequiresRuleApplications) {
							CConceptDescriptor* conDes = conIt.next();
							CConcept* concept = conDes->getConcept();
							bool conNeg = conDes->isNegated();
							cint64 conOpCode = concept->getOperatorCode();
							CRole* role = concept->getRole();

							CSortedNegLinker<CConcept*>* opLinker = concept->getOperandList();

							CConceptOperator* conOperator = concept->getConceptOperator();

							if (!conNeg && (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE)) || conNeg && conOpCode == CCSOME) {

								CRoleSuccessorLinkIterator roleSuccIt = indi2->getRoleSuccessorLinkIterator(role);
								while (roleSuccIt.hasNext()) {
									CIndividualLinkEdge* link = roleSuccIt.next();
									CIndividualProcessNode* succIndi = getSuccessorIndividual(indi2, link, calcAlgContext);

									for (CSortedNegLinker<CConcept*>* opLinkerIt = opLinker; opLinkerIt; opLinkerIt = opLinkerIt->getNext()) {
										CConcept* opConcept = opLinkerIt->getData();
										bool opConNeg = opLinkerIt->isNegated() ^ conNeg;
										bool containsNeg = false;
										if (succIndi->getReapplyConceptLabelSet(false)->containsConcept(concept, &containsNeg)) {
											if (containsNeg != opConNeg) {
												return false;
											}
										} else {
											*mergingPossiblyRequiresRuleApplications = true;
											if (cancelOnPossiblyNewRuleApplications) {
												return false;
											}
										}
									}
								}




							} else if (!conNeg && conOpCode == CCATMOST || conNeg && conOpCode == CCATLEAST) {
								cint64 cardinality = concept->getParameter();
								if (conNeg) {
									--cardinality;
								}


								cint64 usedCount = mergeIntoIndi1->getRoleSuccessorCount(role);
								cint64 requiredCount = indi2->getRoleSuccessorCount(role);

								if (usedCount + requiredCount > cardinality) {
									cint64 triviallyMergableCount = 0;
									cint64 triviallyNonMergableCount = 0;

									CRoleSuccessorLinkIterator roleSuccIt = indi2->getRoleSuccessorLinkIterator(role);
									while (roleSuccIt.hasNext() && usedCount + requiredCount - triviallyMergableCount > cardinality && usedCount + triviallyNonMergableCount <= cardinality) {
										CIndividualLinkEdge* link = roleSuccIt.next();
										CIndividualProcessNode* succIndi = getSuccessorIndividual(indi2, link, calcAlgContext);

										bool mergeable = true;
										bool successorRelevant = false;
										if (succIndi->isNominalIndividualNode()) {
											CSortedNegLinker<CConcept*>* opLinkerIt = opLinker;
											if (!opLinkerIt) {
												successorRelevant = true;
											}
											while (opLinkerIt && !successorRelevant) {
												CConcept* opConcept = opLinkerIt->getData();
												bool opConNeg = opLinkerIt->isNegated();
												bool containsNeg = false;
												if (succIndi->getReapplyConceptLabelSet(false)->containsConcept(concept, &containsNeg)) {
													if (containsNeg == opConNeg) {
														successorRelevant = true;
													}
												} else {
													successorRelevant = true;
												}
												opLinkerIt = opLinkerIt->getNext();
											}
											if (successorRelevant) {
												if (!mergeIntoIndi1->hasRoleSuccessorToIndividual(role, succIndi, false)) {
													mergeable = false;
												}
											}
										} else if (succIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE)) {
											successorRelevant = true;
										}

										if (!successorRelevant || mergeable) {
											triviallyMergableCount++;
										}
										if (successorRelevant && !mergeable) {
											triviallyNonMergableCount++;
										}
									}

									if (usedCount + requiredCount - triviallyMergableCount > cardinality) {
										*mergingPossiblyRequiresRuleApplications = true;
										if (cancelOnPossiblyNewRuleApplications) {
											return false;
										}
									}
								}
							}
						}
					}

					CClashedDependencyDescriptor* clashDescriptors = nullptr;

					if (disHash) {
						CDistinctEdge* disEdge = disHash->getIndividualDistinctEdge(indi2->getIndividualNodeID());
						if (disEdge) {
							clashDescriptors = createClashedIndividualDistinctDescriptor(clashDescriptors, disEdge, disEdge->getDependencyTrackPoint(), calcAlgContext);
							return false;
						}
					}

					if (mConfUniqueNameAssumption) {
						if (mergeIntoIndi1->isNominalIndividualNode() && indi2->isNominalIndividualNode()) {
							if (mergeIntoIndi1->getNominalIndividual() != indi2->getNominalIndividual()) {
								// TODO: clashes correct?
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors, mergeIntoIndi1, nullptr, mergeIntoIndi1->getDependencyTrackPoint(), calcAlgContext);
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors, indi2, nullptr, indi2->getDependencyTrackPoint(), calcAlgContext);
								return false;
							}
						}
					}

					


					if (!areIndividualNodesDisjointRolesMergeable(mergeIntoIndi1, indi2, clashDescriptors, calcAlgContext)) {
						return false;
					}

					STATINC(INDINODESMERGEABLETESTSUCCESSCOUNT, calcAlgContext);
					return true;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandBackendCacheIndividualNodesNominalMerging(CIndividualProcessNode* indi1, CIndividualProcessNode* indi2, CCalculationAlgorithmContextBase* calcAlgContext) {
					// check for each neighbour of indi1, whether there is a neighbouing link in the backend cache to that individual for indi2 and vice versa

					bool expanded = false;
					expanded |= expandBackendCacheIndividualNodesNominalMergingNeighbouringConnections(indi1, indi2, calcAlgContext);
					expanded |= expandBackendCacheIndividualNodesNominalMergingNeighbouringConnections(indi2, indi1, calcAlgContext);
					return expanded;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandBackendCacheIndividualNodesNominalMergingNeighbouringConnections(CIndividualProcessNode* indi1, CIndividualProcessNode* indi2, CCalculationAlgorithmContextBase* calcAlgContext) {
					// check for each nominal neighbour of a blockable node indi1, whether there is a neighbouing link in the backend cache to that individual for indi2 and vice versa

					cint64 indi1ID = indi1->getIndividualNodeID();
					cint64 indi2ID = indi2->getIndividualNodeID();
					CConnectionSuccessorSet* connSuccSet1 = indi1->getConnectionSuccessorSet(false);

					if (connSuccSet1 && !indi1->getNominalIndividual()) {
						// TODO: check if required adaptation for mConfNewMergingsOnlyInferringExpansion
						// if two nominal/abox individual nodes are merged, then all connections are expanded any way


						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData2 = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indi2->getIndividualBackendCacheSynchronisationData(false);
						if (backendSyncData2) {
							if (backendSyncData2) {
								CBackendRepresentativeMemoryCacheIndividualAssociationData* assData2 = backendSyncData2->getAssocitaionData();
								if (assData2) {
									CBackendRepresentativeMemoryCacheIndividualNeighbourRoleSetHash* neighbourRoleSetHash2 = assData2->getNeighbourRoleSetHash();
									if (neighbourRoleSetHash2) {

										CPROCESSINGLIST<cint64> indi2ExpansionList(calcAlgContext->getUsedTaskProcessorContext());
										// links which point to adding individual node
										CConnectionSuccessorSetIterator conn1It = connSuccSet1->getConnectionSuccessorIterator();
										while (conn1It.hasNext()) {
											cint64 conn1ID = conn1It.next();

											if (conn1ID == indi1ID) {
												if (!indi2->hasSuccessorIndividualNode(indi2ID)) {
													if (neighbourRoleSetHash2->getNeighbourRoleSetLabel(indi2ID)) {
														indi2ExpansionList.append(indi2ID);
													}
												}
											} else if (conn1ID <= 0) {
												if (!indi2->hasSuccessorIndividualNode(conn1ID)) {
													if (neighbourRoleSetHash2->getNeighbourRoleSetLabel(conn1ID)) {
														indi2ExpansionList.append(conn1ID);
													}
												}
											}

										}

										bool expanded = false;
										for (CPROCESSINGLIST<cint64>::const_iterator indi2ExpIt = indi2ExpansionList.constBegin(), indi2ExpItEnd = indi2ExpansionList.constEnd(); indi2ExpIt != indi2ExpItEnd; ++indi2ExpIt) {
											cint64 indi2ExpIndiId = *indi2ExpIt;
											expanded |= expandIndividualNeighbourNodeFromBackendCache(indi2, indi2ExpIndiId, calcAlgContext);
										}
										return expanded;

									}
								}
							}
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodesMergeable(CIndividualProcessNode* indi1, CIndividualProcessNode* indi2, CClashedDependencyDescriptor*& clashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODESMERGEABLETESTCOUNT,calcAlgContext);
					CDistinctHash* disHash = indi1->getDistinctHash(false);
					STATINC(INDINODESMERGEABLEDISTINCTTESTCOUNT,calcAlgContext);

					expandBackendCacheIndividualNodesNominalMerging(indi1, indi2, calcAlgContext);

					if (disHash) {
						CDistinctEdge* disEdge = disHash->getIndividualDistinctEdge(indi2->getIndividualNodeID());
						if (disEdge) {
							clashDescriptors = createClashedIndividualDistinctDescriptor(clashDescriptors,disEdge,disEdge->getDependencyTrackPoint(),calcAlgContext);
							return false;
						}
					}

					if (mConfUniqueNameAssumption) {
						if (indi1->isNominalIndividualNode() && indi2->isNominalIndividualNode()) {
							if (indi1->getNominalIndividual() != indi2->getNominalIndividual()) {
								// TODO: clashes correct?
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors,indi1,nullptr,indi1->getDependencyTrackPoint(),calcAlgContext);
								clashDescriptors = createClashedConceptDescriptor(clashDescriptors,indi2,nullptr,indi2->getDependencyTrackPoint(),calcAlgContext);
								return false;
							}
						}
					}


					if (isLabelConceptClashSet(indi1,indi2,clashDescriptors,calcAlgContext)) {
						return false;
					}

					if (!areIndividualNodesDisjointRolesMergeable(indi1,indi2,clashDescriptors,calcAlgContext)) {
						return false;
					}

					STATINC(INDINODESMERGEABLETESTSUCCESSCOUNT,calcAlgContext);
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::areIndividualNodesDisjointRolesMergeable(CIndividualProcessNode* indi1, CIndividualProcessNode* indi2, CClashedDependencyDescriptor*& clashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (indi1->hasDisjointRoleConnections() || indi2->hasDisjointRoleConnections()) {
						if (!isIndividualNodeDisjointRolesMergeable(indi1,indi2,clashDescriptors,calcAlgContext)) {
							return false;
						}
						if (!isIndividualNodeDisjointRolesMergeable(indi2,indi1,clashDescriptors,calcAlgContext)) {
							return false;
						}
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeDisjointRolesMergeable(CIndividualProcessNode* indi1, CIndividualProcessNode* indi2, CClashedDependencyDescriptor*& clashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODESMERGEABLEDISJOINTROLETESTCOUNT,calcAlgContext);
					CConnectionSuccessorSet* connSuccSet1 = indi1->getConnectionSuccessorSet(false);
					CIndividualProcessNode* indi = indi1;
					CIndividualProcessNode* othIndi = indi2;
					CConnectionSuccessorSet* connSuccSet = connSuccSet1;

					cint64 indiID = indi->getIndividualNodeID();
					cint64 othIndiID = othIndi->getIndividualNodeID();

					if (connSuccSet) {
						// links which point to adding individual node
						CConnectionSuccessorSetIterator connIt = connSuccSet->getConnectionSuccessorIterator();
						while (connIt.hasNext()) {
							cint64 connID = connIt.next();

							if (connID == indiID) {
								// test self links
								CDisjointSuccessorRoleIterator connDisSuccRoleIt(indi->getDisjointSuccessorRoleIterator(indi));
								while (connDisSuccRoleIt.hasNext()) {
									CNegationDisjointEdge* disNegLink = connDisSuccRoleIt.next();
									CRole* role = disNegLink->getLinkRole();
									CIndividualLinkEdge* link = othIndi->getRoleSuccessorToIndividualLink(role,othIndi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
								}
							} else if (othIndiID == connID) {
								// test ancestor/successor merging link clashes
								CDisjointSuccessorRoleIterator connDisSuccRoleIt(othIndi->getDisjointSuccessorRoleIterator(indi));
								while (connDisSuccRoleIt.hasNext()) {
									CNegationDisjointEdge* disNegLink = connDisSuccRoleIt.next();
									CRole* role = disNegLink->getLinkRole();
									CIndividualLinkEdge* link = nullptr;
									// ancestor self test
									link = othIndi->getRoleSuccessorToIndividualLink(role,othIndi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
									// successor self test
									link = indi->getRoleSuccessorToIndividualLink(role,indi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
									// ancestor to successor test
									link = othIndi->getRoleSuccessorToIndividualLink(role,indi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
									// successor to ancestor test
									link = indi->getRoleSuccessorToIndividualLink(role,othIndi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
								}

							} else {

								CIndividualProcessNode* connIndi = getUpToDateIndividual(connID,calcAlgContext);

								CDisjointSuccessorRoleIterator connDisSuccRoleIt(connIndi->getDisjointSuccessorRoleIterator(indi));
								while (connDisSuccRoleIt.hasNext()) {
									CNegationDisjointEdge* disNegLink = connDisSuccRoleIt.next();
									CRole* role = disNegLink->getLinkRole();
									CIndividualLinkEdge* link = connIndi->getRoleSuccessorToIndividualLink(role,othIndi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
								}
								CDisjointSuccessorRoleIterator disSuccRoleIt(indi->getDisjointSuccessorRoleIterator(connIndi));
								while (disSuccRoleIt.hasNext()) {
									CNegationDisjointEdge* disNegLink = disSuccRoleIt.next();
									CRole* role = disNegLink->getLinkRole();
									CIndividualLinkEdge* link = othIndi->getRoleSuccessorToIndividualLink(role,connIndi,false);
									if (link) {
										clashDescriptors = createClashedIndividualLinkDescriptor(clashDescriptors,link,link->getDependencyTrackPoint(),calcAlgContext);
										clashDescriptors = createClashedNegationDisjointDescriptor(clashDescriptors,disNegLink,disNegLink->getDependencyTrackPoint(),calcAlgContext);
										return false;
									}
								}
							}
						}
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isLabelConceptClashSet(CIndividualProcessNode* subSetIndi, CIndividualProcessNode* superSetIndi, CClashedDependencyDescriptor*& clashDescriptors, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODESMERGEABLECONCEPTSETTESTCOUNT,calcAlgContext);

					CReapplyConceptLabelSet* subConceptSet = subSetIndi->getReapplyConceptLabelSet(false);
					CReapplyConceptLabelSet* superConceptSet = superSetIndi->getReapplyConceptLabelSet(false);
					if (superConceptSet->getConceptCount() < subConceptSet->getConceptCount()) {
						CReapplyConceptLabelSet* tmpConSet = subConceptSet;
						subConceptSet = superConceptSet;
						superConceptSet = tmpConSet;
						CIndividualProcessNode* tmpIndi = subSetIndi;
						subSetIndi = superSetIndi;
						superSetIndi = tmpIndi;
					}

					cint64 subConSetCount = subConceptSet->getConceptCount();
					cint64 superConSetCount = superConceptSet->getConceptCount();
					cint64 thresholdFactor = mMapComparisonDirectLookupFactor;
					if (subConSetCount * thresholdFactor < superConSetCount) {
						CReapplyConceptLabelSetIterator subConSetIt = subConceptSet->getConceptLabelSetIterator(true, false, false);
						while (subConSetIt.hasValue()) {
							CConceptDescriptor* subConDes = subConSetIt.getConceptDescriptor();
							CDependencyTrackPoint* subDepTrackPoint = subConSetIt.getDependencyTrackPoint();
							CConceptDescriptor* superConDes = nullptr;
							CDependencyTrackPoint* superDepTrackPoint = nullptr;
							if (superConceptSet->getConceptDescriptor(subConDes->getConcept(), superConDes, superDepTrackPoint)) {
								if (superConDes->getNegation() != subConDes->getNegation()) {
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors, subSetIndi, subConDes, subDepTrackPoint, calcAlgContext);
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors, superSetIndi, superConDes, superDepTrackPoint, calcAlgContext);
								}
							}
							subConSetIt.moveNext();
						}
					} else {

						CReapplyConceptLabelSetIterator conSet1It = subConceptSet->getConceptLabelSetIterator(true, false, false);
						CReapplyConceptLabelSetIterator conSet2It = superConceptSet->getConceptLabelSetIterator(true, false, false);
						CConceptDescriptor* conDes2 = conSet2It.getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint2 = conSet2It.getDependencyTrackPoint();
						cint64 conTag2 = conDes2->getConceptTag();
						conSet2It.moveNext();
						while (conSet1It.hasValue()) {
							CConceptDescriptor* conDes1 = conSet1It.getConceptDescriptor();
							CDependencyTrackPoint* depTrackPoint1 = conSet1It.getDependencyTrackPoint();
							cint64 conTag1 = conDes1->getConceptTag();

							while (conTag2 < conTag1) {
								if (!conSet2It.hasValue()) {
									return false;
								}
								conDes2 = conSet2It.getConceptDescriptor();
								depTrackPoint2 = conSet2It.getDependencyTrackPoint();
								conTag2 = conDes2->getConceptTag();
								conSet2It.moveNext();
							}
							if (conTag1 == conTag2) {
								if (conDes1->isNegated() != conDes2->isNegated()) {
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors, subSetIndi, conDes1, depTrackPoint1, calcAlgContext);
									clashDescriptors = createClashedConceptDescriptor(clashDescriptors, superSetIndi, conDes2, depTrackPoint2, calcAlgContext);
									return true;
								}
							}
							conSet1It.moveNext();
						}
					}
					return false;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getMergedIndividualNodes(CIndividualProcessNode*& preferedMergeIntoIndividualNode, CIndividualProcessNode*& individual2, CDependencyTrackPoint* mergeDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {


					CIndividualProcessNode* mergedIndividual = nullptr;
					CIndividualProcessNode* addingIndividual = nullptr;
					bool switchNodes = false;
					CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();

					bool individualComputation = calcAlgContext->getUsedSatisfiableCalculationTask()->getSatisfiableRepresentativeBackendCacheUpdatingAdapter() != nullptr;

					if (!individualComputation && !mOptMergeConstructedIndividualNode && procDataBox->getConstructedIndividualNode()->getIndividualNodeID() == preferedMergeIntoIndividualNode->getIndividualNodeID()) {
						switchNodes = false;
					} else if (!individualComputation && !mOptMergeConstructedIndividualNode &&  !individual2->getNominalIndividual() && procDataBox->getConstructedIndividualNode()->getIndividualNodeID() == individual2->getIndividualNodeID()) {
						switchNodes = true;
					} else if (preferedMergeIntoIndividualNode->isNominalIndividualNode() && individual2->isNominalIndividualNode()) {
						if (individual2->getIndividualNominalLevel() < preferedMergeIntoIndividualNode->getIndividualNominalLevel()) {
							switchNodes = true;
						} else if (individual2->getIndividualNominalLevel() == preferedMergeIntoIndividualNode->getIndividualNominalLevel()) {
							if (individual2->getIndividualNodeID() > preferedMergeIntoIndividualNode->getIndividualNodeID()) {
								switchNodes = true;
							}
						}
					} else if (preferedMergeIntoIndividualNode->isNominalIndividualNode()) {
						switchNodes = false;
					} else if (individual2->isNominalIndividualNode()) {
						switchNodes = true;
					} else if (preferedMergeIntoIndividualNode->isIndividualAncestor(individual2)) {
						switchNodes = false;
					} else if (individual2->isIndividualAncestor(preferedMergeIntoIndividualNode)) {
						switchNodes = true;
					} else {
						if (individual2->getIndividualAncestorDepth() < preferedMergeIntoIndividualNode->getIndividualAncestorDepth()) {
							switchNodes = true;
						} 
						// TODO: check is this if useful?
						//else if (individual2->getIndividualID() < preferedMergeIntoIndividualNode->getIndividualID()) {
						//	switchNodes = true;
						//}
					}

					if (!switchNodes) {
						mergedIndividual = preferedMergeIntoIndividualNode;
						addingIndividual = individual2;
					} else {
						mergedIndividual = individual2;
						addingIndividual = preferedMergeIntoIndividualNode;
					}
					mergeIndividualNodeInto(mergedIndividual,addingIndividual,mergeDepTrackPoint,calcAlgContext);
					return mergedIndividual;
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getIntoEmptyMergedIndividualNode(CIndividualProcessNode*& mergingIndividualNode, bool createAsNominal, CIndividualProcessNode* mergerNode, CDependencyTrackPoint* mergeDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* newEmptyIndiNode = createNewEmptyIndividual(calcAlgContext);
					if (!createAsNominal) {
						newEmptyIndiNode->setIndividualNominalLevel(mergingIndividualNode->getIndividualNominalLevel());
						newEmptyIndiNode->setIndividualAncestorDepth(mergingIndividualNode->getIndividualAncestorDepth());
						if (mergingIndividualNode->isNominalIndividualNode()) {
							newEmptyIndiNode->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
						} else {
							newEmptyIndiNode->setIndividualType(CIndividualProcessNode::BLOCKABLEINDIVIDUALTYPE);
						}
					} else {
						newEmptyIndiNode->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
						newEmptyIndiNode->setIndividualNominalLevel(mergerNode->getIndividualNominalLevel()+1);
					}
					mergeIndividualNodeInto(newEmptyIndiNode,mergingIndividualNode,mergeDepTrackPoint,calcAlgContext);
					return newEmptyIndiNode;
				}

				
	
				void CCalculationTableauCompletionTaskHandleAlgorithm::mergeIndividualNodeInto(CIndividualProcessNode*& mergeIntoIndividualNode, CIndividualProcessNode*& individual, CDependencyTrackPoint* mergeDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					STATINC(INDINODEMERGECOUNT,calcAlgContext);


					KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mBeforeMergingTaskDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

					//mMergedStringList.append(QString("merged %1 into %2").arg(individual->getIndividualID()).arg(mergeIntoIndividualNode->getIndividualID()));

					//if (individual->isNominalIndividual()) {
					//	++mNominalMergedCount;
					//	cout << " start-nominal-merge ";

					KONCLUCE_TASK_ALGORITHM_MERGING_DEBUGGING_INSTRUCTION(
						mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						QFile file(QString("./Debugging/CompletionTasks/merging-step-start-%1-%2-%3.txt").arg(mNominalMergedCount).arg(individual->getIndividualNodeID()).arg(mergeIntoIndividualNode->getIndividualNodeID()));
						if (file.open(QIODevice::WriteOnly)) {
							file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
							file.close();
						}
					);

					//}


					//if (debugSameIndiExp || debugIncExpChecking || mergeIntoIndividualNode->getIndividualMergingHash() && (mergeIntoIndividualNode->getIndividualMergingHash()->contains(individual->getIndividualNodeID()) || mergeIntoIndividualNode->getIndividualMergingHash()->contains(-individual->getIndividualNodeID()))) {
					//	mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//	QFile file(QString("./Debugging/CompletionTasks/merging-step-start-%1-%2-%3.txt").arg(mNominalMergedCount).arg(individual->getIndividualNodeID()).arg(mergeIntoIndividualNode->getIndividualNodeID()));
					//	if (file.open(QIODevice::WriteOnly)) {
					//		file.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
					//		file.close();
					//	}
					//	bool debug = true;
					//}

					markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(mergeIntoIndividualNode, calcAlgContext);
					markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(individual, calcAlgContext);




					if (mCompGraphCacheHandler && mConfCompletionGraphCaching && individual->isNominalIndividualNode() && !mergeIntoIndividualNode->isNominalIndividualNode()) {
						if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED) && individual->getIndividualNodeID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
							individual->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHEDNODELOCATED);

							if (individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED)) {
								individual->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED);
							}

							clearCompletionGraphCaching(individual, calcAlgContext);

						}
					}




					mergeIntoIndividualNode->setLastMergedIntoIndividualNode(individual);
					individual->setMergedDependencyTrackPoint(mergeDepTrackPoint);

					bool newLinksAdded = false;

					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					// merge concept label set
					CReapplyConceptLabelSet* addingConceptLabelSet = individual->getReapplyConceptLabelSet(false);
					CConceptProcessingQueue* mergeIntoConProQueue = mergeIntoIndividualNode->getConceptProcessingQueue(true);
					if (addingConceptLabelSet) {
						CReapplyConceptLabelSet* mergeIntoConceptLabelSet = mergeIntoIndividualNode->getReapplyConceptLabelSet(true);

						cint64 thresholdFactor = mMapComparisonDirectLookupFactor;
						if (addingConceptLabelSet->getConceptCount() * thresholdFactor < mergeIntoConceptLabelSet->getConceptCount()) {

							CReapplyConceptLabelSetIterator conSetIt = addingConceptLabelSet->getConceptLabelSetIterator(true, true, false);
							cint64 prevDataTag = 0;
							while (conSetIt.hasNext()) {

								cint64 conTag = conSetIt.getDataTag();
								CConceptDescriptor* conDes = conSetIt.getConceptDescriptor();
								CDependencyTrackPoint* depTrackPoint = conSetIt.getDependencyTrackPoint();
								if (conDes) {
									if (!mergeIntoConceptLabelSet->containsConcept(conDes->getConcept(), nullptr)) {
										STATINC(INDINODEMERGECONCEPTSADDCOUNT, calcAlgContext);

										// create dependency
										CDependencyTrackPoint* newDepTrackPoint = nullptr;
										CMERGEDCONCEPTDependencyNode* mergedConDepNode = createMERGEDCONCEPTDependency(newDepTrackPoint, mergeIntoIndividualNode, conDes, mergeDepTrackPoint, depTrackPoint, calcAlgContext);

										addConceptToIndividual(conDes->getConcept(), conDes->getNegation(), mergeIntoIndividualNode, newDepTrackPoint, false, true, calcAlgContext);
									}
								}
								conSetIt.moveNext();
							}

						} else {

							CReapplyConceptLabelSetIterator prevSetIt = mergeIntoConceptLabelSet->getConceptLabelSetIterator(true,true,false);
							CReapplyConceptLabelSetIterator conSetIt = addingConceptLabelSet->getConceptLabelSetIterator(true,true,false);
							cint64 prevDataTag = 0;
							bool hasPrevData = false;
							if (prevSetIt.hasNext()) {
								prevDataTag = prevSetIt.getDataTag();
								hasPrevData = true;
								prevSetIt.moveNext();
							}
							while (conSetIt.hasNext()) {

								cint64 conTag = conSetIt.getDataTag();
								CConceptDescriptor* conDes = conSetIt.getConceptDescriptor();
								CDependencyTrackPoint* depTrackPoint = conSetIt.getDependencyTrackPoint();
								if (conDes) {
									while (hasPrevData && prevDataTag < conTag) {
										if (prevSetIt.hasNext()) {
											prevDataTag = prevSetIt.getDataTag();
											hasPrevData = true;
											prevSetIt.moveNext();
										} else {
											hasPrevData = false;
										}
									}
									if (!hasPrevData || (hasPrevData && prevDataTag != conTag)) {
										STATINC(INDINODEMERGECONCEPTSADDCOUNT,calcAlgContext);

										// create dependency
										CDependencyTrackPoint* newDepTrackPoint = nullptr;
										CMERGEDCONCEPTDependencyNode* mergedConDepNode = createMERGEDCONCEPTDependency(newDepTrackPoint,mergeIntoIndividualNode,conDes,mergeDepTrackPoint,depTrackPoint,calcAlgContext);

										addConceptToIndividual(conDes->getConcept(),conDes->getNegation(),mergeIntoIndividualNode,newDepTrackPoint,false,true,calcAlgContext);
									}
								}
								conSetIt.moveNext();
							}
						}
					}


					CPROCESSINGHASH<CDependencyTrackPoint*,CDependencyTrackPoint*> depTrackPointHash(calcAlgContext->getUsedTaskProcessorContext());

					// move all connected incoming links
					CConnectionSuccessorSet* connSuccSet = individual->getConnectionSuccessorSet(false);
					if (connSuccSet) {

						// links which point to adding individual node
						CConnectionSuccessorSetIterator connIt = connSuccSet->getConnectionSuccessorIterator();
						while (connIt.hasNext()) {
							cint64 connID = connIt.next();
							if (connID == individual->getIndividualNodeID()) {

								CSuccessorRoleIterator connRoleIt(individual->getSuccessorRoleIterator(individual));
								while (connRoleIt.hasNext()) {
									CIndividualLinkEdge* link = connRoleIt.next();
									CRole* role = link->getLinkRole();

									if (!mergeIntoIndividualNode->hasRoleSuccessorToIndividual(role, mergeIntoIndividualNode, true)) {
										STATINC(INDINODEMERGELINKSADDCOUNT, calcAlgContext);

										// create dependency
										CDependencyTrackPoint* newDepTrackPoint = nullptr;
										CDependencyTrackPoint* prevLinkDepTrackPoint = link->getDependencyTrackPoint();
										if (depTrackPointHash.contains(prevLinkDepTrackPoint)) {
											newDepTrackPoint = depTrackPointHash.value(prevLinkDepTrackPoint);
										} else {
											CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, prevLinkDepTrackPoint, calcAlgContext);
											depTrackPointHash.insert(prevLinkDepTrackPoint, newDepTrackPoint);
										}

										// generate new link
										newLinksAdded = true;
										createNewIndividualsLinkReapplyed(mergeIntoIndividualNode, mergeIntoIndividualNode, mergeIntoIndividualNode, role, newDepTrackPoint, calcAlgContext);
									}
								}

							} else {
								CIndividualProcessNode* locConnIndi = getLocalizedIndividual(connID,calcAlgContext);
								if (individual->isNominalIndividualNode() || locConnIndi->isNominalIndividualNode() || individual->isIndividualAncestor(locConnIndi) || mergeIntoIndividualNode->hasSuccessorIndividualNode(locConnIndi)) {

									if (!individual->isNominalIndividualNode() || !locConnIndi->isIndividualAncestor(individual)) {

										if (individual->getNominalIndividual() && locConnIndi->getNominalIndividual() && mergeIntoIndividualNode->getNominalIndividual()) {
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locConnIndi, calcAlgContext);
											CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
											CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locBackendSyncData->getAssocitaionData();

											cint64 mergedIntoNeighbourIndiId = mergeIntoIndividualNode->getNominalIndividual()->getIndividualID();
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[mergedIntoNeighbourIndiId];
											if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
												CDependencyTrackPoint* backDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
												expandIndividualNeighbourNodeFromBackendCache(locConnIndi, assocData, mergedIntoNeighbourIndiId, neighbourExpansionData, false, false, nullptr, backDepTrackPoint, calcAlgContext);
											}
										}

										// links from connected individual node
										CSuccessorRoleIterator connRoleIt(locConnIndi->getSuccessorRoleIterator(individual));
										while (connRoleIt.hasNext()) {
											CIndividualLinkEdge* link = connRoleIt.next();
											CRole* role = link->getLinkRole();
											CIndividualProcessNode* creatorIndiNode = mergeIntoIndividualNode;
											if (link->isCreatorIndividualID(locConnIndi)) {
												creatorIndiNode = locConnIndi;
											}
											if (!locConnIndi->hasRoleSuccessorToIndividual(role,mergeIntoIndividualNode,true)) {
												STATINC(INDINODEMERGELINKSADDCOUNT,calcAlgContext);

												// create dependency
												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CDependencyTrackPoint* prevLinkDepTrackPoint = link->getDependencyTrackPoint();
												if (depTrackPointHash.contains(prevLinkDepTrackPoint)) {
													newDepTrackPoint = depTrackPointHash.value(prevLinkDepTrackPoint);
												} else {
													CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,prevLinkDepTrackPoint,calcAlgContext);
													depTrackPointHash.insert(prevLinkDepTrackPoint,newDepTrackPoint);
												}

												// generate new link
												newLinksAdded = true;
												createNewIndividualsLinkReapplyed(creatorIndiNode,locConnIndi,mergeIntoIndividualNode,role,newDepTrackPoint,calcAlgContext);
											}
											locConnIndi->removeIndividualLink(link);
										}
										// and reverse
										CSuccessorRoleIterator succRoleIt(individual->getSuccessorRoleIterator(locConnIndi));
										while (succRoleIt.hasNext()) {
											CIndividualLinkEdge* link = succRoleIt.next();
											CIndividualProcessNode* creatorIndiNode = mergeIntoIndividualNode;
											if (link->isCreatorIndividualID(locConnIndi)) {
												creatorIndiNode = locConnIndi;
											}
											CRole* role = link->getLinkRole();
											if (!mergeIntoIndividualNode->hasRoleSuccessorToIndividual(role,locConnIndi,true)) {
												STATINC(INDINODEMERGELINKSADDCOUNT,calcAlgContext);

												// create dependency
												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CDependencyTrackPoint* prevLinkDepTrackPoint = link->getDependencyTrackPoint();
												if (depTrackPointHash.contains(prevLinkDepTrackPoint)) {
													newDepTrackPoint = depTrackPointHash.value(prevLinkDepTrackPoint);
												} else {
													CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,link->getDependencyTrackPoint(),calcAlgContext);
													depTrackPointHash.insert(prevLinkDepTrackPoint,newDepTrackPoint);
												}

												// generate new link
												newLinksAdded = true;
												createNewIndividualsLinkReapplyed(creatorIndiNode,mergeIntoIndividualNode,locConnIndi,role,newDepTrackPoint,calcAlgContext);
											}
										}


										// neg/disjoint links from connected individual node
										CDisjointSuccessorRoleIterator connNegDisIt(locConnIndi->getDisjointSuccessorRoleIterator(individual));
										while (connNegDisIt.hasNext()) {
											CNegationDisjointEdge* negDisLink = connNegDisIt.next();
											CRole* role = negDisLink->getLinkRole();
											if (!locConnIndi->hasNegationDisjointToIndividual(role,mergeIntoIndividualNode)) {
												// TODO: change stat to neg/dis link
												STATINC(INDINODEMERGELINKSADDCOUNT,calcAlgContext);

												// create dependency
												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,negDisLink->getDependencyTrackPoint(),calcAlgContext);

												// generate new negation link
												createIndividualNodeNegationLink(locConnIndi,mergeIntoIndividualNode,role,newDepTrackPoint,calcAlgContext);
											}
										}
										locConnIndi->removeDisjointLinks(individual->getIndividualNodeID());
										// and reverse
										CDisjointSuccessorRoleIterator succNegDisIt(individual->getDisjointSuccessorRoleIterator(locConnIndi));
										while (succNegDisIt.hasNext()) {
											CNegationDisjointEdge* negDisLink = succNegDisIt.next();
											CRole* role = negDisLink->getLinkRole();
											if (!mergeIntoIndividualNode->hasNegationDisjointToIndividual(role,locConnIndi)) {
												// TODO: change stat to neg/dis link
												STATINC(INDINODEMERGELINKSADDCOUNT,calcAlgContext);

												// create dependency
												CDependencyTrackPoint* newDepTrackPoint = nullptr;
												CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,negDisLink->getDependencyTrackPoint(),calcAlgContext);

												// generate new negation link
												createIndividualNodeNegationLink(mergeIntoIndividualNode,locConnIndi,role,newDepTrackPoint,calcAlgContext);
											}
										}


										locConnIndi->removeIndividualConnection(individual);
									}
								}
							}
						}
					}

					if (individual->isNominalIndividualNode()) {
						CIndividual* nominalIndividual = individual->getNominalIndividual();
						if (!mergeIntoIndividualNode->isNominalIndividualNode()) {
							mergeIntoIndividualNode->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
							mergeIntoIndividualNode->setNominalIndividual(nominalIndividual);
						}

						if (nominalIndividual) {

							CIndividualMergingHash* otherIndiMergingHash = individual->getIndividualMergingHash(false);
							CIndividualMergingHash* indiMergingHash = mergeIntoIndividualNode->getIndividualMergingHash(true);
							if (otherIndiMergingHash) {
								if (indiMergingHash->isEmpty()) {
									indiMergingHash->initIndividualMergingHash(otherIndiMergingHash);
									for (CIndividualMergingHash::iterator it = indiMergingHash->begin(), itEnd = indiMergingHash->end(); it != itEnd; ++it) {
										cint64 individualId = it.key();
										CIndividualMergingHashData& mergingData = it.value();
										mergingData.getReapplyQueue()->initReapplyQueue(nullptr);
										if (mergingData.isMergedWithIndividual()) {
											CDependencyTrackPoint* indiDepTrackPoint = mergingData.getDependencyTrackPoint();
											// create dependency
											if (indiDepTrackPoint) {
												CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
												CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, indiDepTrackPoint, calcAlgContext);
												mergingData.setDependencyTrackPoint(newIndiDepTrackPoint);
											}
										}

									}
								} else {
									for (CIndividualMergingHash::iterator it = otherIndiMergingHash->begin(), itEnd = otherIndiMergingHash->end(); it != itEnd; ++it) {
										cint64 individualId = it.key();
										CIndividualMergingHashData& mergingData = it.value();
										CDependencyTrackPoint* indiDepTrackPoint = mergingData.getDependencyTrackPoint();

										if (mergingData.isMergedWithIndividual()) {
											CXLinker<cint64>* individualMergingLinker = CObjectAllocator< CXLinker<cint64> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
											individualMergingLinker->initLinker(individualId);
											indiMergingHash->addMergedIndividualLinker(individualMergingLinker);

											// create dependency
											CIndividualMergingHashData& mergeIntoMergingData = (*indiMergingHash)[individualId];
											mergeIntoMergingData.setMergedWithIndividual(true);
											if (indiDepTrackPoint) {
												CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
												CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, indiDepTrackPoint, calcAlgContext);
												mergeIntoMergingData.setDependencyTrackPoint(newIndiDepTrackPoint);
											}
											if (!mergeIntoMergingData.getReapplyQueue()->isEmpty()) {
												CCondensedReapplyQueueIterator reapplyIt = mergeIntoMergingData.getReapplyQueue()->getIterator(true, true);
												applyReapplyQueueConcepts(mergeIntoIndividualNode, &reapplyIt, calcAlgContext);
												mergeIntoMergingData.getReapplyQueue()->initReapplyQueue(nullptr);
											}
										}
									}
								}
							}

							if (nominalIndividual->getIndividualID() == -individual->getIndividualNodeID()) {
								CDependencyTrackPoint* indiDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
								// create dependency
								CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
								CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,indiDepTrackPoint,calcAlgContext);

								CIndividualMergingHashData& mergeIntoMergingData = (*indiMergingHash)[nominalIndividual->getIndividualID()];
								mergeIntoMergingData.setDependencyTrackPoint(newIndiDepTrackPoint);
								mergeIntoMergingData.setMergedWithIndividual(true);

								CXLinker<cint64>* individualMergingLinker = CObjectAllocator< CXLinker<cint64> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								individualMergingLinker->initLinker(nominalIndividual->getIndividualID());
								indiMergingHash->addMergedIndividualLinker(individualMergingLinker);


								if (!mergeIntoMergingData.getReapplyQueue()->isEmpty()) {
									CCondensedReapplyQueueIterator reapplyIt = mergeIntoMergingData.getReapplyQueue()->getIterator(true, true);
									applyReapplyQueueConcepts(mergeIntoIndividualNode, &reapplyIt, calcAlgContext);
									mergeIntoMergingData.getReapplyQueue()->initReapplyQueue(nullptr);
								}
							}
						}
					}

					if (!mergeIntoIndividualNode->getDependencyTrackPoint()) {
						mergeIntoIndividualNode->setDependencyTrackPoint(depTrackPointHash.value(individual->getDependencyTrackPoint()));
					}
					if (mConfMinimizeMerging) {
						if (mergeIntoIndividualNode->isBlockableIndividual() && !mergeIntoIndividualNode->hasIndividualAncestor() && mergeIntoIndividualNode->getIndividualAncestorDepth() >= individual->getIndividualAncestorDepth()) {
							CIndividualLinkEdge* ancLink = individual->getAncestorLink();
							if (ancLink) {
								CIndividualProcessNode* ancIndiNode = getAncestorIndividual(individual,calcAlgContext);
								CIndividualLinkEdge* mergedNewAncLink = ancIndiNode->getRoleSuccessorToIndividualLink(ancLink->getLinkRole(),mergeIntoIndividualNode,false);
								mergeIntoIndividualNode->setAncestorLink(mergedNewAncLink);
							}
						}
					}


					// add distinct information
					bool mergedNodeDatatypeDistinctChangeNotified = false;
					CDistinctHash* addDisHash = individual->getDistinctHash(false);
					if (addDisHash) {
						CDistinctHash* mergeDisHash = mergeIntoIndividualNode->getDistinctHash(true);
						CDistinctIterator disIt = addDisHash->getDistinctIterator();
						while (disIt.hasNext()) {
							CDependencyTrackPoint* depTrackPoint = nullptr;
							cint64 disIndiID = disIt.nextDistinctIndividualID(depTrackPoint);
							CIndividualProcessNode* locDisIndiNode = getLocalizedIndividual(disIndiID,calcAlgContext);
							CDistinctHash* disHash = locDisIndiNode->getDistinctHash(true);
							disHash->removeDistinctIndividual(individual->getIndividualNodeID());
							if (!mergeDisHash->isIndividualDistinct(disIndiID)) {
								STATINC(INDINODEMERGEDISTINCTADDCOUNT,calcAlgContext);
								STATINC(DISTINCTCREATIONCOUNT,calcAlgContext);

								// create dependency
								CDependencyTrackPoint* newDepTrackPoint = nullptr;
								CMERGEDLINKDependencyNode* mergedLinkDepNode = createMERGEDLINKDependency(newDepTrackPoint,mergeIntoIndividualNode,mergeDepTrackPoint,depTrackPoint,calcAlgContext);


								CDistinctEdge* disEdge = CObjectParameterizingAllocator< CDistinctEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
								disEdge->initDistinctEdge(locDisIndiNode,mergeIntoIndividualNode,newDepTrackPoint);

								mergeDisHash->insertDistinctIndividual(disIndiID,disEdge);
								disHash->insertDistinctIndividual(mergeIntoIndividualNode->getIndividualNodeID(),disEdge);

								if (mDatatypeHandler) {
									mDatatypeHandler->notifyDistinctChanges(locDisIndiNode,calcAlgContext);
									if (!mergedNodeDatatypeDistinctChangeNotified) {
										mergedNodeDatatypeDistinctChangeNotified = true;
										mDatatypeHandler->notifyDistinctChanges(mergeIntoIndividualNode,calcAlgContext);
									}
								}

							}
						}
					}

					// prune nodes
					individual->setMergedIntoIndividualNodeID(mergeIntoIndividualNode->getIndividualNodeID());
					pruneSuccessors(individual,nullptr,false,calcAlgContext);


					if (individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING)) {
						mergeIntoIndividualNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING);
					}


					if (mConfExactNominalDependencyTracking) {
						if (individual->isNominalIndividualNode() && mergeIntoIndividualNode->isNominalIndividualNode()) {
							CSuccessorConnectedNominalSet* copySuccConnNomSet = individual->getSuccessorNominalConnectionSet(false);
							if (copySuccConnNomSet) {
								for (CSuccessorConnectedNominalSet::const_iterator it = copySuccConnNomSet->constBegin(), itEnd = copySuccConnNomSet->constEnd(); it != itEnd; ++it) {
									cint64 nominalID = *it;
									mergeIntoIndividualNode->addSuccessorConnectionToNominal(nominalID);
								}
							}
							CIndividual* nominalIndi = individual->getNominalIndividual();
							if (nominalIndi) {
								cint64 nominalID = -nominalIndi->getIndividualID();
								mergeIntoIndividualNode->addSuccessorConnectionToNominal(nominalID);
							}
						}
					}

					// is not necessary since rules are applied again for new added concepts
					//if (individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSUCCESSORNOMINALCONNECTION)) {
					//	propagateIndividualNodeNominalConnectionToAncestors(mergeIntoIndividualNode,calcAlgContext);
					//}



					//if (individual->isNominalIndividual()) {
					//	++mNominalMergedCount;
					//	cout<<" end-nominal-merge ";

					KONCLUCE_TASK_ALGORITHM_MERGING_DEBUGGING_INSTRUCTION(
						mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						QFile fileend(QString("./Debugging/CompletionTasks/merging-step-stop-%1-%2-%3.txt").arg(mNominalMergedCount).arg(individual->getIndividualNodeID()).arg(mergeIntoIndividualNode->getIndividualNodeID()));
						if (fileend.open(QIODevice::WriteOnly)) {
							fileend.write(mEndTaskDebugIndiModelString.replace("<br>", "\r\n").toLocal8Bit());
							fileend.close();
						}
					);

					//}



					CRoleAssertionLinker* roleAssLinker = individual->getAssertionRoleLinker();
					CReverseRoleAssertionLinker* reverseRoleAssLinker = individual->getReverseAssertionRoleLinker();
					if (roleAssLinker || reverseRoleAssLinker) {
						CAdditionalProcessRoleAssertionsLinker* additionalRoleAssLinker = CObjectAllocator< CAdditionalProcessRoleAssertionsLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						additionalRoleAssLinker->initAdditionalProcessRoleAssertionsLinker(individual->getNominalIndividual(),roleAssLinker,reverseRoleAssLinker, mergeDepTrackPoint);
						mergeIntoIndividualNode->addAdditionalRoleAssertionsLinker(additionalRoleAssLinker);
						newLinksAdded = true;
					}
					for (CAdditionalProcessRoleAssertionsLinker* additionalRoleAssLinkerIt = individual->getAdditionalRoleAssertionsLinker(); additionalRoleAssLinkerIt; additionalRoleAssLinkerIt = additionalRoleAssLinkerIt->getNext()) {
						CAdditionalProcessRoleAssertionsLinker* additionalRoleAssLinker = CObjectAllocator< CAdditionalProcessRoleAssertionsLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
						CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, additionalRoleAssLinkerIt->getDependencyTrackPoint(), calcAlgContext);
						additionalRoleAssLinker->initAdditionalProcessRoleAssertionsLinker(additionalRoleAssLinkerIt->getIndividual(),additionalRoleAssLinkerIt->getRoleAssertionLinker(),additionalRoleAssLinkerIt->getReverseRoleAssertionLinker(), newIndiDepTrackPoint);
						mergeIntoIndividualNode->addAdditionalRoleAssertionsLinker(additionalRoleAssLinker);
						newLinksAdded = true;
					}


					for (CXSortedNegLinker<CConcept*>* initLinker = individual->getProcessInitializingConceptLinker(); initLinker; initLinker = initLinker->getNext()) {
						CXSortedNegLinker<CConcept*>* newInitLinker = CObjectAllocator< CXSortedNegLinker<CConcept*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						newInitLinker->initNegLinker(initLinker->getData(), initLinker->getNegation());
						mergeIntoIndividualNode->addInitializingConceptLinker(newInitLinker);
					}


					CDataAssertionLinker* dataAssLinker = individual->getAssertionDataLinker();
					if (dataAssLinker) {
						CAdditionalProcessDataAssertionsLinker* additionalDataAssLinker = CObjectAllocator< CAdditionalProcessDataAssertionsLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						additionalDataAssLinker->initAdditionalProcessDataAssertionsLinker(individual->getNominalIndividual(), dataAssLinker, mergeDepTrackPoint);
						mergeIntoIndividualNode->addAdditionalDataAssertionsLinker(additionalDataAssLinker);
						newLinksAdded = true;
					}
					for (CAdditionalProcessDataAssertionsLinker* additionalDataAssLinkerIt = individual->getAdditionalDataAssertionsLinker(); additionalDataAssLinkerIt; additionalDataAssLinkerIt = additionalDataAssLinkerIt->getNext()) {
						CAdditionalProcessDataAssertionsLinker* additionalDataAssLinker = CObjectAllocator< CAdditionalProcessDataAssertionsLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
						CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, additionalDataAssLinkerIt->getDependencyTrackPoint(), calcAlgContext);
						additionalDataAssLinker->initAdditionalProcessDataAssertionsLinker(additionalDataAssLinkerIt->getIndividual(), additionalDataAssLinkerIt->getDataAssertionLinker(), newIndiDepTrackPoint);
						mergeIntoIndividualNode->addAdditionalDataAssertionsLinker(additionalDataAssLinker);
						newLinksAdded = true;
					}


					for (CProcessAssertedDataLiteralLinker* assertedDataLiteralLinkerIt = individual->getAssertedDataLiteralLinker(); assertedDataLiteralLinkerIt; assertedDataLiteralLinkerIt = assertedDataLiteralLinkerIt->getNext()) {
						CProcessAssertedDataLiteralLinker* additionalDataLitLinker = CObjectAllocator< CProcessAssertedDataLiteralLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						CDependencyTrackPoint* newIndiDepTrackPoint = nullptr;
						CMERGEDIndividualDependencyNode* mergedIndiDepNode = createMERGEDINDIVIDUALDependency(newIndiDepTrackPoint, mergeIntoIndividualNode, mergeDepTrackPoint, assertedDataLiteralLinkerIt->getDependencyTrackPoint(), calcAlgContext);
						additionalDataLitLinker->initProcessDataLiteralLinker(assertedDataLiteralLinkerIt->getData(), newIndiDepTrackPoint);
						mergeIntoIndividualNode->addAssertedDataLiteralLinker(additionalDataLitLinker);
						newLinksAdded = true;
					}

					if (mergeIntoIndividualNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED) 
							|| individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENNEIGHBOURDPARTIALEXPANSION | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED)) {
						newLinksAdded = true;
					}


					if (individual->getIndividualBackendCacheSynchronisationData(false) && !mergeIntoIndividualNode->getIndividualBackendCacheSynchronisationData(false)) {
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = CObjectParameterizingAllocator< CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
						backendSyncData->initSynchronisationData((CBackendRepresentativeMemoryCacheIndividualAssociationData*)((CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)individual->getIndividualBackendCacheSynchronisationData(false))->getAssocitaionData());
						backendSyncData->setBackendCacheSynchron(false);
						mergeIntoIndividualNode->setIndividualBackendCacheSynchronisationData(backendSyncData);
						addIndividualToBackendIndirectCompatibilityExpansionQueue(mergeIntoIndividualNode, calcAlgContext);
					}


					if (newLinksAdded) {
						propagateIndividualNodeModified(mergeIntoIndividualNode, calcAlgContext);
					}
					addIndividualToProcessingQueue(mergeIntoIndividualNode, calcAlgContext);


					KONCLUCE_TASK_ALGORITHM_MODEL_STRING_INSTRUCTION(mAfterMergingTaskDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext));

				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::tryExtendFunctionalSuccessorIndividual(CIndividualProcessNode*& indi, CConceptDescriptor* conDes, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CSortedNegLinker<CConcept*>* conceptLinkerIt, bool negate, CDependencyTrackPoint* depTrackPoint, CIndividualSaturationProcessNode* saturationIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualProcessNode* succIndi = nullptr;
					

					// TODO: test super roles for functional
					CReapplyRoleSuccessorHash* roleSucc = indi->getReapplyRoleSuccessorHash(false);
					CIndividualLinkEdge* mergeLink = nullptr;
					if (roleSucc) {
						CSortedNegLinker<CRole*>* funTestRoleLinkerIt = roleLinkerIt;
						while (funTestRoleLinkerIt && !succIndi) {
							CRole* role = funTestRoleLinkerIt->getData();
							bool invRole = funTestRoleLinkerIt->isNegated();
							bool functionalRole = !invRole && role->isFunctional();
							if (functionalRole) {
								CRoleSuccessorLinkIterator roleSuccIt = roleSucc->getRoleSuccessorLinkIterator(role);
								if (roleSuccIt.hasNext()) {
									CIndividualLinkEdge* link = roleSuccIt.next(false);
									succIndi = getLocalizedSuccessorIndividual(indi,link,calcAlgContext);
									mergeLink = link;
								}
							}
							funTestRoleLinkerIt = funTestRoleLinkerIt->getNext();
						}
					}
					if (succIndi) {
						// create dependency
						CDependencyTrackPoint* nextAllDepTrackPoint = nullptr;
						CALLDependencyNode* allDepNode = createALLDependency(nextAllDepTrackPoint,indi,conDes,depTrackPoint,mergeLink->getDependencyTrackPoint(),calcAlgContext);

						bool satCachingPossible;
						CConceptDescriptor* lastSatCachPossibleConDes = nullptr;
						if (mConfExpandCreatedSuccessorsFromSaturation) {
							tryExpansionFromSaturatedData(indi,succIndi,conDes,nextAllDepTrackPoint,saturationIndiNode,&satCachingPossible,&lastSatCachPossibleConDes,calcAlgContext);
						}
						// update successor links
						bool newLinksAdded = false;
						CSortedNegLinker<CRole*>* tmpRoleLinkerIt = roleLinkerIt;
						while (tmpRoleLinkerIt) {
							CRole* role = tmpRoleLinkerIt->getData();
							bool invRole = tmpRoleLinkerIt->isNegated();
							if (!invRole) {
								if (!hasIndividualsLink(indi,succIndi,role,true,calcAlgContext)) {
									// add link
									createNewIndividualsLinkReapplyed(indi,indi,succIndi,role,nextAllDepTrackPoint,calcAlgContext);
									newLinksAdded = true;
								}
							} else {
								if (!hasIndividualsLink(succIndi,indi,role,true,calcAlgContext)) {
									// add link
									createNewIndividualsLinkReapplyed(indi,succIndi,indi,role,nextAllDepTrackPoint,calcAlgContext);
									newLinksAdded = true;
								}
							}
							tmpRoleLinkerIt = tmpRoleLinkerIt->getNext();
						}
						if (newLinksAdded) {
							propagateIndividualNodeModified(succIndi,calcAlgContext);
						}

						addConceptsToIndividual(conceptLinkerIt,negate,succIndi,nextAllDepTrackPoint,true,true,nullptr,calcAlgContext);
						if (mConfCachingBlockingFromSaturation) {
							tryEstablishSaturationCaching(indi,succIndi,saturationIndiNode,&satCachingPossible,&lastSatCachPossibleConDes,calcAlgContext);
						}
					}
					return succIndi;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::createSuccessorIndividual(CIndividualProcessNode*& indi, CConceptDescriptor* conDes, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CSortedNegLinker<CConcept*>* conceptLinkerIt, bool negate, CDependencyTrackPoint* depTrackPoint, CIndividualSaturationProcessNode* saturationIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualProcessNode* succIndi = nullptr;

					// create dependency
					CDependencyTrackPoint* nextDepTrackPoint = nullptr;
					CSOMEDependencyNode* someDepNode = createSOMEDependency(nextDepTrackPoint,indi,conDes,depTrackPoint,calcAlgContext);

					// generate new role successor
					succIndi = createNewIndividual(nextDepTrackPoint,ancRole->isDataRole(),calcAlgContext);

					bool satCachingPossible = true;
					CConceptDescriptor* lastSatCachPossibleConDes = nullptr;
					if (mConfExpandCreatedSuccessorsFromSaturation) {
						tryExpansionFromSaturatedData(indi,succIndi,conDes,nextDepTrackPoint,saturationIndiNode,&satCachingPossible,&lastSatCachPossibleConDes,calcAlgContext);
					}
					CIndividualLinkEdge* ancLink = createNewIndividualsLinksReapplyed(indi,succIndi,roleLinkerIt,ancRole,nextDepTrackPoint,false,calcAlgContext);
					succIndi->setAncestorLink(ancLink);
					succIndi->setIndividualAncestorDepth(indi->getIndividualAncestorDepth()+1);
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);
					}
					if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
						succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
					}

					addConceptsToIndividual(conceptLinkerIt,negate,succIndi,nextDepTrackPoint,true,true,nullptr,calcAlgContext);
					if (mConfCachingBlockingFromSaturation) {
						tryEstablishSaturationCaching(indi,succIndi,saturationIndiNode,&satCachingPossible,&lastSatCachPossibleConDes,calcAlgContext);
					}
					return succIndi;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryEstablishSaturationCaching(CIndividualProcessNode*& indi, CIndividualProcessNode* succIndi, CIndividualSaturationProcessNode* saturationIndiNode, bool* satCachingPossible, CConceptDescriptor** lastSatCachPossibleConDes, CCalculationAlgorithmContextBase* calcAlgContext) {

					if (saturationIndiNode && saturationIndiNode->isInitialized() && saturationIndiNode->isCompleted()) {
						bool cachingEstablishmentPossible = false;

						CIndividualSaturationProcessNodeStatusFlags* flags = saturationIndiNode->getIndirectStatusFlags();
						if (!flags->hasFlags(CIndividualSaturationProcessNodeStatusFlags::INDSATFLAGINSUFFICIENT | CIndividualSaturationProcessNodeStatusFlags::INDSATFLAGCLASHED,false)) {
							if (validateSaturationCachingPossible(succIndi,saturationIndiNode,satCachingPossible,lastSatCachPossibleConDes,nullptr,false,calcAlgContext)) {

								bool nominalNodesCompatible = true;

								if (flags->hasFlags(CIndividualSaturationProcessNodeStatusFlags::INDSATFLAGNOMINALCONNECTION,false)) {
									if (!mConfSaturationCachingWithNominals) {
										nominalNodesCompatible = false;
									}
									CSuccessorConnectedNominalSet* succConnNominalSet = saturationIndiNode->getSuccessorConnectedNominalSet(false);
									if (!succConnNominalSet) {
										nominalNodesCompatible = false;
									} else if (!tryInstallSaturationCachingReactivation(succIndi,succConnNominalSet,calcAlgContext)) {
										nominalNodesCompatible = false;
									}
								}

								if (nominalNodesCompatible) {
									cachingEstablishmentPossible = true;
								}
							}
						}

						cint64 succIndiConCount = succIndi->getReapplyConceptLabelSet(false)->getConceptCount();
						CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
						CIndividualNodeSaturationBlockingData* satBlockingData = CObjectAllocator< CIndividualNodeSaturationBlockingData >::allocateAndConstruct(taskMemMan);
						satBlockingData->initSaturationBlockingData(succIndiConCount,*lastSatCachPossibleConDes,saturationIndiNode);
						succIndi->setIndividualSaturationBlockingData(satBlockingData);

						if (cachingEstablishmentPossible) {
							STATINC(SATURATIONCACHEESTABLISHCOUNT,calcAlgContext);
							succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED);
							propagateIndirectSuccessorSaturationBlocked(succIndi,calcAlgContext);

							if (!flags->hasFlags(CIndividualSaturationProcessNodeStatusFlags::INDSATFLAGCARDINALITYPROPLEMATIC,false)) {
								succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONSUCCESSORCREATIONBLOCKINGCACHED);
							}
							return true;
						}
					}


					return false;
				}













				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryInitalizingFromSaturatedData(CIndividualProcessNode*& indi, CXSortedNegLinker<CConcept*>* initConceptLinker, CDependencyTrackPoint* depTrackPoint, bool allowPreprocess, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (initConceptLinker) {
						CConcept* concept = initConceptLinker->getData();
						bool conceptNegation = initConceptLinker->isNegated();
						CConceptData* conceptData = concept->getConceptData();
						CIndividualSaturationProcessNode* baseSatIndiNode = nullptr;
						if (conceptData) {
							CConceptProcessData* conProcData = (CConceptProcessData*)conceptData;
							CConceptReferenceLinking* conRefLinking = conProcData->getConceptReferenceLinking();
							if (conRefLinking) {
								CConceptSaturationReferenceLinkingData* confSatRefLinkingData = (CConceptSaturationReferenceLinkingData*)conRefLinking;
								CSaturationConceptReferenceLinking* extSatCalcRefLinkData = confSatRefLinkingData->getConceptSaturationReferenceLinkingData(conceptNegation);
								if (extSatCalcRefLinkData) {
									baseSatIndiNode = (CIndividualSaturationProcessNode*)extSatCalcRefLinkData->getIndividualProcessNodeForConcept();
								}
							}
						}

						if (baseSatIndiNode && baseSatIndiNode->isInitialized()) {
							CIndividualSaturationProcessNode* satIndiNode = baseSatIndiNode;
							while (satIndiNode->hasSubstituteIndividualNode()) {
								satIndiNode = satIndiNode->getSubstituteIndividualNode();
							}
							CReapplyConceptSaturationLabelSet* satConSet = satIndiNode->getReapplyConceptSaturationLabelSet(false);
							if (satConSet) {
								if (satIndiNode->getIndirectStatusFlags()->hasClashedFlag() || baseSatIndiNode->getIndirectStatusFlags()->hasClashedFlag()) {
									CClashedDependencyDescriptor* clashDes = nullptr;
									addConceptToIndividualSkipANDProcessing(concept,conceptNegation,indi,depTrackPoint,false,false, true,calcAlgContext);
									CConceptDescriptor* clashedConDes = nullptr;
									CDependencyTrackPoint* clashedDepTrackPoint = nullptr;
									indi->getReapplyConceptLabelSet(false)->getConceptDescriptor(concept,clashedConDes,clashedDepTrackPoint);
									clashDes = createClashedConceptDescriptor(clashDes,indi,clashedConDes,clashedDepTrackPoint,calcAlgContext);
									throw CCalculationClashProcessingException(clashDes);
								} else {

									bool nominalConnectionFlag = satIndiNode->getIndirectStatusFlags()->hasNominalConnectionFlag();
									if (nominalConnectionFlag) {
										propagateIndividualNodeNominalConnectionToAncestors(indi,calcAlgContext);
										if (mConfExactNominalDependencyTracking) {
											CSuccessorConnectedNominalSet* satSuccConnNomSet = satIndiNode->getSuccessorConnectedNominalSet(false);
											if (satSuccConnNomSet) {
												CSuccessorConnectedNominalSet* succConnNomSet = indi->getSuccessorNominalConnectionSet(true);
												for (CSuccessorConnectedNominalSet::const_iterator it = satSuccConnNomSet->constBegin(), itEnd = satSuccConnNomSet->constEnd(); it != itEnd; ++it) {
													cint64 nominalID = -*it;
													succConnNomSet->insert(nominalID);
												}
											}
										}
									}

									bool satCachingPossible = true;
									CConceptDescriptor* lastSatCachPossibleConDes = nullptr;

									if (satIndiNode = baseSatIndiNode) {
										addConceptToIndividualSkipANDProcessing(concept,conceptNegation,indi,depTrackPoint,allowPreprocess,false, true,calcAlgContext);
									} else {
										addConceptToIndividual(concept,conceptNegation,indi,depTrackPoint,allowPreprocess,false,calcAlgContext);
									}
									CConceptDescriptor* conDes = nullptr;
									CDependencyTrackPoint* conDepTrackPoint = nullptr;
									indi->getReapplyConceptLabelSet(false)->getConceptDescriptor(concept,conDes,conDepTrackPoint);

									CDependencyTrackPoint* expandDepTrackPoint = nullptr;
									CANDDependencyNode* andDepNode = createANDDependency(expandDepTrackPoint,indi,conDes,conDepTrackPoint,calcAlgContext);

									for (CConceptSaturationDescriptor* conSatDesIt = satConSet->getConceptSaturationDescriptionLinker(); conSatDesIt; conSatDesIt = conSatDesIt->getNext()) {
										CConcept* satConcept = conSatDesIt->getConcept();
										bool satConceptNegation = conSatDesIt->isNegated();
										STATINC(SATURATIONCACHECONCEPTEXPANSIONCOUNT,calcAlgContext);
										if (satConcept != concept || conceptNegation != satConceptNegation) {
											addConceptToIndividualSkipANDProcessing(satConcept,satConceptNegation,indi,expandDepTrackPoint,allowPreprocess,false, true,calcAlgContext);
											validateSaturationCachingPossible(indi,satIndiNode,&satCachingPossible,&lastSatCachPossibleConDes,satConcept,satConceptNegation,calcAlgContext);
										}
									}

									CSaturationNodeAssociatedDeterministicConceptExpansion* detExpansion = nullptr;
									CSaturationNodeExpansionCacheHandler* satCacheHandler = calcAlgContext->getUsedSaturationNodeExpansionCacheHandler();
									if (satCacheHandler) {
										if (satCacheHandler->getCachedDeterministicExpansion(baseSatIndiNode,detExpansion,calcAlgContext)) {
											if (detExpansion && (mConfSaturationIncompleteExpansionFromCache || !detExpansion->requiresNonDeterministicExpansion())) {
												for (CSaturationNodeAssociatedConceptLinker* conceptExpansionLinkerIt = detExpansion->getConceptExpansionLinker(); conceptExpansionLinkerIt; conceptExpansionLinkerIt = conceptExpansionLinkerIt->getNext()) {
													CCacheValue* cacheValue = conceptExpansionLinkerIt->getCacheValue();

													CConcept* expansionConcept = (CConcept*)cacheValue->getIdentification();
													bool expansionConceptNeg = cacheValue->getCacheValueIdentifier() == CCacheValue::CACHEVALTAGANDNEGATEDCONCEPT;
													addConceptToIndividualSkipANDProcessing(expansionConcept,expansionConceptNeg,indi,expandDepTrackPoint,allowPreprocess,false, true,calcAlgContext);
												}
											}
										}
									}



									cint64 indiConCount = indi->getReapplyConceptLabelSet(false)->getConceptCount();
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									CIndividualNodeSaturationBlockingData* satBlockingData = CObjectAllocator< CIndividualNodeSaturationBlockingData >::allocateAndConstruct(taskMemMan);
									satBlockingData->initSaturationBlockingData(indiConCount,lastSatCachPossibleConDes,baseSatIndiNode);
									indi->setIndividualSaturationBlockingData(satBlockingData);

								}

								CXSortedNegLinker<CConcept*>* nextInitConceptLinker = initConceptLinker;
								if (baseSatIndiNode == satIndiNode) {
									nextInitConceptLinker = initConceptLinker->getNext();
								}
								for (CXSortedNegLinker<CConcept*>* nextInitConceptLinkerIt = nextInitConceptLinker; nextInitConceptLinkerIt; nextInitConceptLinkerIt = nextInitConceptLinkerIt->getNext()) {
									CConcept* nextConcept = nextInitConceptLinkerIt->getData();
									bool nextConceptNegation = nextInitConceptLinkerIt->isNegated();
									addConceptToIndividual(nextConcept,nextConceptNegation,indi,depTrackPoint,allowPreprocess,true,calcAlgContext);
								}
								return true;
							}
						}						
					}
					return false;
				}








				void CCalculationTableauCompletionTaskHandleAlgorithm::propagateIndirectSuccessorSaturationBlocked(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateAddingBlockedProcessingRestrictionToSuccessors(indi,CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED,true,CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::validateSaturationCachingPossible(CIndividualProcessNode* indi, CIndividualSaturationProcessNode*& saturationIndiNode, bool* satCachingPossible, CConceptDescriptor** lastSatCachPossibleConDes, CConcept* addedConcept, bool addedConceptNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool satCachingStillPossible = true;
					if (satCachingPossible) {
						satCachingStillPossible = *satCachingPossible;
					}
					if (satCachingStillPossible) {
						if (!saturationIndiNode->isCompleted()) {
							satCachingStillPossible = false;
						} else {
							CReapplyConceptLabelSet* conSet = indi->getReapplyConceptLabelSet(false);
							CReapplyConceptSaturationLabelSet* satConSet = saturationIndiNode->getReapplyConceptSaturationLabelSet(false);
							if (conSet && satConSet) {
								CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
								CConceptDescriptor* conDesIt = conDesLinker;
								CConceptDescriptor* lastTestedConDesIt = nullptr;
								if (lastSatCachPossibleConDes) {
									lastTestedConDesIt = *lastSatCachPossibleConDes;
								}
								if (addedConcept && conDesIt != lastTestedConDesIt) {
									if (conDesIt->getConcept() == addedConcept || conDesIt->isNegated() == addedConceptNegation) {
										conDesIt = conDesIt->getNext();
									}
								}
								//while (conDesIt != lastTestedConDesIt && fromSatDataConceptsAddedCount > 0) {
								//	--fromSatDataConceptsAddedCount;
								//	conDesIt = conDesIt->getNext();
								//}
								while (conDesIt != lastTestedConDesIt && satCachingStillPossible) {
									if (!satConSet->hasConcept(conDesIt->getConcept(),conDesIt->isNegated())) {
										satCachingStillPossible = false;
									}
									conDesIt = conDesIt->getNext();
								}
								if (lastSatCachPossibleConDes) {
									*lastSatCachPossibleConDes = conDesLinker;
								}
							} else {
								satCachingStillPossible = false;
							}
						}
					}
					if (satCachingPossible) {
						*satCachingPossible = satCachingStillPossible;
					}
					return satCachingStillPossible;
				}





				CIndividualSaturationProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getCreationSuccessorSaturationNode(CIndividualProcessNode*& indi, CConceptDescriptor* conDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConcept* concept = conDes->getConcept();
					bool conceptNegation = conDes->isNegated();
					CConceptData* conceptData = concept->getConceptData();
					CIndividualSaturationProcessNode* existIndiNode = nullptr;
					if (conceptData) {
						CConceptProcessData* conProcData = (CConceptProcessData*)conceptData;
						CConceptReferenceLinking* conRefLinking = conProcData->getConceptReferenceLinking();
						if (conRefLinking) {
							CConceptSaturationReferenceLinkingData* confSatRefLinkingData = (CConceptSaturationReferenceLinkingData*)conRefLinking;
							CSaturationConceptReferenceLinking* extSatCalcRefLinkData = confSatRefLinkingData->getExistentialSuccessorConceptSaturationReferenceLinkingData();
							if (extSatCalcRefLinkData) {
								existIndiNode = (CIndividualSaturationProcessNode*)extSatCalcRefLinkData->getIndividualProcessNodeForConcept();
							}
						}
					}

					if (!existIndiNode) {
						CSortedNegLinker<CConcept*>* conceptOpLinker = concept->getOperandList();
						if (conceptOpLinker && !conceptOpLinker->hasNext()) {
							CConcept* opConcept = conceptOpLinker->getData();
							bool opConNegation = conceptOpLinker->isNegated()^conceptNegation;
							CConceptData* opConceptData = opConcept->getConceptData();
							if (opConceptData) {
								CConceptProcessData* conProcData = (CConceptProcessData*)opConceptData;
								CConceptReferenceLinking* conRefLinking = conProcData->getConceptReferenceLinking();
								if (conRefLinking) {
									CConceptSaturationReferenceLinkingData* confSatRefLinkingData = (CConceptSaturationReferenceLinkingData*)conRefLinking;
									CSaturationConceptReferenceLinking* satCalcRefLinkData = confSatRefLinkingData->getConceptSaturationReferenceLinkingData(opConNegation);
									if (satCalcRefLinkData) {
										existIndiNode = (CIndividualSaturationProcessNode*)satCalcRefLinkData->getIndividualProcessNodeForConcept();
									}	
								}
							}
						}
					}

					if (mConfSuccessorSaturationExpansionRestrictionsResolving && existIndiNode) {
						CSaturationIndividualNodeSuccessorExtensionData* extensionData = existIndiNode->getSuccessorExtensionData(false);
						if (extensionData) {
							CSaturationIndividualNodeExtensionResolveData* resolveData = extensionData->getExtensionResolveData();
							if (resolveData) {


								STATINC(NODESUCCESSOREXPANSIONSATURATIONRESOLVINGTRYINGCOUNT, calcAlgContext);
								// collect universal restrictions from predecessor
								CPROCESSINGHASH<cint64, CConceptNegationPair>* conExtensionMap = nullptr;
								CReapplyRoleSuccessorHash* roleSuccHash = indi->getReapplyRoleSuccessorHash(false);
								CRole* creationRole = conDes->getConcept()->getRole();
								CSortedNegLinker<CRole*>* roleLinkerIt = creationRole->getIndirectSuperRoleList();
								CReapplyConceptSaturationLabelSet* conSet = existIndiNode->getReapplyConceptSaturationLabelSet(false);

								while (roleSuccHash && roleLinkerIt) {
									CRole* role = roleLinkerIt->getData();
									bool invRole = roleLinkerIt->isNegated();
									if (!invRole) {
										CReapplyQueueIterator reapplyQueueIt = roleSuccHash->getRoleReapplyIterator(role, false);

										while (reapplyQueueIt.hasNext()) {
											CReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt.next();
											CConceptDescriptor* reaConDes = reapplyConceptDes->getConceptDescriptor();

											CDependencyTrackPoint* depTrackPoint = reapplyConceptDes->getDependencyTrackPoint();
											CProcessingRestrictionSpecification* procRest = reapplyConceptDes->getReapplyProcessingRestriction();

											bool nondeterministically = true;
											if (depTrackPoint->getBranchingTag() <= calcAlgContext->getProcessingDataBox()->getMaximumDeterministicBranchTag() || depTrackPoint == conDes->getDependencyTrackPoint()) {
												nondeterministically = false;
											}

											if (!nondeterministically) {
												CConcept* reaConcept = reaConDes->getConcept();
												cint64 reaConceptCode = reaConcept->getOperatorCode();
												bool reaConNegation = reaConDes->isNegated();
												collectReapplyAutomatTransactionsRestrictions(indi, role, reaConcept, reaConNegation, conExtensionMap, conSet, calcAlgContext);
											}

										}

									}

									roleLinkerIt = roleLinkerIt->getNext();
								}


								CIndividualSaturationProcessNode* resolvedIndiNode = getSaturationResolvedIndividualNodeExtension(resolveData, conExtensionMap, calcAlgContext);
								if (resolvedIndiNode && resolvedIndiNode != existIndiNode) {
									STATINC(NODESUCCESSOREXPANSIONSATURATIONRESOLVEDCOUNT, calcAlgContext);
									existIndiNode = resolvedIndiNode;
								}

							}
						}
					}

					return existIndiNode;
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::collectReapplyAutomatTransactionsRestrictions(CIndividualProcessNode*& processIndi, CRole* collectingRole, CConcept* concept, bool negated, CPROCESSINGHASH<cint64, CConceptNegationPair>*& conExtensionMap, CReapplyConceptSaturationLabelSet* conSet, CCalculationAlgorithmContextBase* calcAlgContext) {

					cint64 opCode = concept->getOperatorCode();
					CSortedNegLinker<CConcept*>* opConcepts = concept->getOperandList();
					if (mConfSpecializedAutomateRules && !negated && concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_AQAND_TYPE)) {
						while (opConcepts) {
							CConcept* opCon = opConcepts->getData();
							bool opConNeg = opConcepts->isNegated();
							collectReapplyAutomatTransactionsRestrictions(processIndi, collectingRole, opCon, opConNeg, conExtensionMap, conSet, calcAlgContext);
							opConcepts = opConcepts->getNext();
						}
					} else if (!negated && concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE) || negated  && concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_SOME_TYPE)) {
						CRole* role = concept->getRole();
						if (role == collectingRole) {
							if ((!negated && concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE)) || (negated && concept->getConceptOperator()->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_SOME_TYPE))) {
								for (CSortedNegLinker<CConcept*>* reaOpConceptIt = concept->getOperandList(); reaOpConceptIt; reaOpConceptIt = reaOpConceptIt->getNext()) {
									bool reaOpConNegation = reaOpConceptIt->isNegated() ^ negated;

									if (!conSet || !conSet->containsConcept(reaOpConceptIt->getData(), reaOpConNegation)) {
										STATINC(NODESUCCESSOREXPANSIONSATURATIONRESOLVINGCONCEPTCANDIDATECOUNT, calcAlgContext);
										if (!conExtensionMap) {
											conExtensionMap = CObjectParameterizingAllocator< CPROCESSINGHASH<cint64, CConceptNegationPair>, CContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedTemporaryMemoryAllocationManager(), calcAlgContext->getUsedTaskProcessorContext());
										}
										conExtensionMap->insert(reaOpConceptIt->getData()->getConceptTag(), CConceptNegationPair(reaOpConceptIt->getData(), reaOpConNegation));
									}
								}
							}

						}
					}
				}




				CIndividualSaturationProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getSaturationResolvedIndividualNodeExtension(CSaturationIndividualNodeExtensionResolveData* resolveData, CPROCESSINGHASH<cint64, CConceptNegationPair>* conExtensionMap, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualSaturationProcessNode* lastResolvedIndiNode = resolveData->getProcessingIndividualNode();
					if (conExtensionMap) {

						for (CPROCESSHASH<cint64, CConceptNegationPair>::const_iterator it = conExtensionMap->constBegin(), itEnd = conExtensionMap->constEnd(); it != itEnd; ++it) {
							const CConceptNegationPair& conExtDat(it.value());
							CConcept* concept = conExtDat.first;
							bool negation = conExtDat.second;

							CSaturationIndividualNodeExtensionResolveHashData resolveHashData = resolveData->getIndividualNodeExtensionResolveHash(true)->getNonCreatingResolvedIndividualNodeExtensionData(concept, negation);
							if (resolveHashData.mResolveData) {
								STATINC(NODESUCCESSOREXPANSIONSATURATIONRESOLVEDCONCEPTCANDIDATECOUNT, calcAlgContext);
								resolveData = resolveHashData.mResolveData;
								if (resolveData->hasProcessingIndividualNode()) {
									lastResolvedIndiNode = resolveData->getProcessingIndividualNode();
								}
							}
						}
					}

					return lastResolvedIndiNode;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryExpansionFromSaturatedData(CIndividualProcessNode*& indi, CIndividualProcessNode* createdSuccIndi, CConceptDescriptor* conDes, CDependencyTrackPoint* depTrackPoint, CIndividualSaturationProcessNode*& saturationIndiNode, bool* satCachingPossible, CConceptDescriptor** lastSatCachPossibleConDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (saturationIndiNode && saturationIndiNode->isInitialized()) {
						CReapplyConceptSaturationLabelSet* satConSet = saturationIndiNode->getReapplyConceptSaturationLabelSet(false);
						if (satConSet) {
							bool nominalConnectionFlag = saturationIndiNode->getIndirectStatusFlags()->hasNominalConnectionFlag();
							if (saturationIndiNode->getIndirectStatusFlags()->hasClashedFlag()) {
								if (!nominalConnectionFlag || !mOptIncrementalExpansion) {
									CClashedDependencyDescriptor* clashDes = nullptr;
									clashDes = createClashedConceptDescriptor(clashDes,indi,conDes,depTrackPoint,calcAlgContext);
									throw CCalculationClashProcessingException(clashDes);
								}
							} else {
								if (!mOptIncrementalExpansion || !nominalConnectionFlag) {

									if (nominalConnectionFlag) {
										propagateIndividualNodeNominalConnectionToAncestors(createdSuccIndi,calcAlgContext);
										if (mConfExactNominalDependencyTracking) {
											CSuccessorConnectedNominalSet* satSuccConnNomSet = saturationIndiNode->getSuccessorConnectedNominalSet(false);
											if (satSuccConnNomSet) {
												CSuccessorConnectedNominalSet* succConnNomSet = createdSuccIndi->getSuccessorNominalConnectionSet(true);
												for (CSuccessorConnectedNominalSet::const_iterator it = satSuccConnNomSet->constBegin(), itEnd = satSuccConnNomSet->constEnd(); it != itEnd; ++it) {
													cint64 nominalID = -*it;
													succConnNomSet->insert(nominalID);
												}
											}
										}
										propagateIndividualNodeNominalConnectionStatusToAncestors(indi,createdSuccIndi,calcAlgContext);
									}

									for (CConceptSaturationDescriptor* conSatDesIt = satConSet->getConceptSaturationDescriptionLinker(); conSatDesIt; conSatDesIt = conSatDesIt->getNext()) {
										CConcept* satConcept = conSatDesIt->getConcept();
										bool satConceptNegation = conSatDesIt->isNegated();
										STATINC(SATURATIONCACHECONCEPTEXPANSIONCOUNT,calcAlgContext);
										addConceptToIndividualSkipANDProcessing(satConcept,satConceptNegation,createdSuccIndi,depTrackPoint,true,false, true,calcAlgContext);
										validateSaturationCachingPossible(createdSuccIndi,saturationIndiNode,satCachingPossible,lastSatCachPossibleConDes,satConcept,satConceptNegation,calcAlgContext);
									}

									CSaturationNodeAssociatedDeterministicConceptExpansion* detExpansion = nullptr;
									CSaturationNodeExpansionCacheHandler* satCacheHandler = calcAlgContext->getUsedSaturationNodeExpansionCacheHandler();
									if (satCacheHandler) {
										if (satCacheHandler->getCachedDeterministicExpansion(saturationIndiNode,detExpansion,calcAlgContext)) {
											if (detExpansion && (mConfSaturationIncompleteExpansionFromCache || !detExpansion->requiresNonDeterministicExpansion())) {
												for (CSaturationNodeAssociatedConceptLinker* conceptExpansionLinkerIt = detExpansion->getConceptExpansionLinker(); conceptExpansionLinkerIt; conceptExpansionLinkerIt = conceptExpansionLinkerIt->getNext()) {
													CCacheValue* cacheValue = conceptExpansionLinkerIt->getCacheValue();

													CConcept* expansionConcept = (CConcept*)cacheValue->getIdentification();
													bool expansionConceptNeg = cacheValue->getCacheValueIdentifier() == CCacheValue::CACHEVALTAGANDNEGATEDCONCEPT;
													addConceptToIndividualSkipANDProcessing(expansionConcept,expansionConceptNeg,createdSuccIndi,depTrackPoint,true,false, true,calcAlgContext);

												}
											}
										}
									}
									return true;
								}
							}
						}
					}
					return false;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::createDistinctSuccessorIndividuals(CIndividualProcessNode*& indi, CConceptDescriptor* conDes, CPROCESSINGLIST<CIndividualProcessNode*>& indiList, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CSortedNegLinker<CConcept*>* conceptLinkerIt, bool negate, CDependencyTrackPoint* depTrackPoint, cint64 succCardCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					for (cint64 i = 0; i < succCardCount; ++i) {
						CIndividualProcessNode* succIndi = nullptr;
						succIndi = createNewIndividual(depTrackPoint,ancRole->isDataRole(),calcAlgContext);
						indiList.append(succIndi);
					}

					CIndividualSaturationProcessNode* saturationIndiNode = getCreationSuccessorSaturationNode(indi, conDes, calcAlgContext);

					createIndividualsDistinct(indiList,depTrackPoint,calcAlgContext);

					for (CPROCESSINGLIST<CIndividualProcessNode*>::const_iterator it = indiList.constBegin(), itEnd = indiList.constEnd(); it != itEnd; ++it) {
						CIndividualProcessNode* succIndi = *it;

						bool satCachingPossible = true;
						CConceptDescriptor* lastSatCachPossibleConDes = nullptr;
						if (mConfExpandCreatedSuccessorsFromSaturation && saturationIndiNode) {
							tryExpansionFromSaturatedData(indi, succIndi, conDes, depTrackPoint, saturationIndiNode, &satCachingPossible, &lastSatCachPossibleConDes, calcAlgContext);
						}


						CIndividualLinkEdge* ancLink = createNewIndividualsLinksReapplyed(indi,succIndi,roleLinkerIt,ancRole,depTrackPoint,false,calcAlgContext);
						succIndi->setAncestorLink(ancLink);
						succIndi->setIndividualAncestorDepth(indi->getIndividualAncestorDepth()+1);
						if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED | CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
							succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED);
						}
						if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
							succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED);
						}
						if (indi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATURATIONBLOCKINGCACHED | CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
							succIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED);
						}
						addConceptsToIndividual(conceptLinkerIt,negate,succIndi,depTrackPoint,true,true,nullptr,calcAlgContext);

						if (mConfCachingBlockingFromSaturation && saturationIndiNode) {
							tryEstablishSaturationCaching(indi, succIndi, saturationIndiNode, &satCachingPossible, &lastSatCachPossibleConDes, calcAlgContext);
						}

					}
				}





				void CCalculationTableauCompletionTaskHandleAlgorithm::createNominalsSuccessorIndividuals(CIndividualProcessNode*& indi, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CSortedNegLinker<CConcept*>* conceptLinkerIt, bool negate, CDependencyTrackPoint* depTrackPoint, cint64 succCardCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					for (cint64 i = 0; i < succCardCount; ++i) {
						STATINC(NOMINALSUCCESSORINDINODECREATIONCOUNT,calcAlgContext);
						CIndividualProcessNode* succIndi = nullptr;
						succIndi = createNewIndividual(depTrackPoint,false,calcAlgContext);
						CIndividualLinkEdge* ancLink = createNewIndividualsLinksReapplyed(indi,succIndi,roleLinkerIt,ancRole,depTrackPoint,false,calcAlgContext);
						succIndi->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
						succIndi->setIndividualNominalLevel(indi->getIndividualNominalLevel()+1);

						addIndividualToProcessingQueue(succIndi,calcAlgContext);
					}
				}





				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::createNewIndividualsLinks(CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualLinkEdge* ancRoleLink = nullptr;
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool generatedInvLink = false;
					while (roleLinkerIt) {
						CRole* role = roleLinkerIt->getData();
						bool invRole = roleLinkerIt->isNegated();
						STATINC(LINKSCREATIONCOUNT,calcAlgContext);
						CIndividualLinkEdge* individualLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
						if (!invRole) {
							createIndividualNodeDisjointRolesLinks(indiSource,indiDestination,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
							individualLink->initIndividualLinkEdge(indiSource,indiSource,indiDestination,role,depTrackPoint);
							//indiSource->installIndividualLink(individualLink);
							installIndividualNodeRoleLink(indiSource,indiDestination,individualLink,calcAlgContext);
						} else {
							generatedInvLink = true;
							createIndividualNodeDisjointRolesLinks(indiDestination,indiSource,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
							individualLink->initIndividualLinkEdge(indiSource,indiDestination,indiSource,role,depTrackPoint);
							//indiDestination->installIndividualLink(individualLink);
							installIndividualNodeRoleLink(indiDestination,indiSource,individualLink,calcAlgContext);
						}
						if (ancRole == role) {
							ancRoleLink = individualLink;
						}
						roleLinkerIt = roleLinkerIt->getNext();
					}
					if (generatedInvLink || indiDestination->isNominalIndividualNode()) {
						indiSource->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiDestination->getIndividualNodeID());
					}
					indiDestination->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiSource->getIndividualNodeID());
					if (mOptIncrementalCompatibleExpansion) {
						linkCreationDirectlyChangedNeighbourConnectionUpdate(indiDestination,indiSource,true,calcAlgContext);
					}
					return ancRoleLink;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::installIndividualNodeRoleLink(CIndividualProcessNode*& sourceIndi, CIndividualProcessNode*& destinationIndi, CIndividualLinkEdge* individualLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CNegationDisjointEdge* negDisEdge = nullptr;
					CDisjointSuccessorRoleHash* disSuccRoleHash = sourceIndi->getDisjointSuccessorRoleHash(false);
					if (disSuccRoleHash) {
						negDisEdge = disSuccRoleHash->getDisjointSuccessorRoleLink(destinationIndi->getIndividualNodeID(),individualLink->getLinkRole());
						if (negDisEdge) {
							CClashedDependencyDescriptor* clashDes = nullptr;
							clashDes = createClashedIndividualLinkDescriptor(clashDes,individualLink,individualLink->getDependencyTrackPoint(),calcAlgContext);
							clashDes = createClashedNegationDisjointDescriptor(clashDes,negDisEdge,negDisEdge->getDependencyTrackPoint(),calcAlgContext);
							throw CCalculationClashProcessingException(clashDes);
						}
					}
					cint64 succLinkCount = sourceIndi->installIndividualLink(individualLink);

					if (mConfOccurrenceStatisticsCollecting && mOptCollectOccurrenceStatistics) {
						bool nondeterministically = hasNondeterministicDependency(individualLink->getDependencyTrackPoint(), calcAlgContext);
						mOccStatsCacheHandler->incRoleInstanceOccurrencceStatistics(individualLink->getLinkRole(), nondeterministically, !sourceIndi->getNominalIndividual(), succLinkCount <= 1);
					}
				}


				CReapplyQueueIterator CCalculationTableauCompletionTaskHandleAlgorithm::installIndividualNodeRoleLinkReapplied(CIndividualProcessNode*& sourceIndi, CIndividualProcessNode*& destinationIndi, CIndividualLinkEdge* individualLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyQueueIterator reapplyIterator;
					CNegationDisjointEdge* negDisEdge = nullptr;
					CDisjointSuccessorRoleHash* disSuccRoleHash = sourceIndi->getDisjointSuccessorRoleHash(false);
					if (disSuccRoleHash) {
						negDisEdge = disSuccRoleHash->getDisjointSuccessorRoleLink(destinationIndi->getIndividualNodeID(),individualLink->getLinkRole());
						if (negDisEdge) {
							CClashedDependencyDescriptor* clashDes = nullptr;
							clashDes = createClashedIndividualLinkDescriptor(clashDes,individualLink,individualLink->getDependencyTrackPoint(),calcAlgContext);
							clashDes = createClashedNegationDisjointDescriptor(clashDes,negDisEdge,negDisEdge->getDependencyTrackPoint(),calcAlgContext);
							throw CCalculationClashProcessingException(clashDes);
						}
					}
					cint64 succLinkCount = sourceIndi->installIndividualLink(individualLink,&reapplyIterator);

					if (mConfOccurrenceStatisticsCollecting && mOptCollectOccurrenceStatistics) {
						bool nondeterministically = hasNondeterministicDependency(individualLink->getDependencyTrackPoint(), calcAlgContext);
						mOccStatsCacheHandler->incRoleInstanceOccurrencceStatistics(individualLink->getLinkRole(), nondeterministically, !sourceIndi->getNominalIndividual(), succLinkCount <= 1);
					}
					return reapplyIterator;
				}


				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::createNewIndividualsLinksReapplyed(CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CSortedNegLinker<CRole*>* roleLinkerIt, CRole* ancRole, CDependencyTrackPoint* depTrackPoint, bool checkRoleExisting, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualLinkEdge* ancRoleLink = nullptr;
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool generatedInvLink = false;
					while (roleLinkerIt) {
						CRole* role = roleLinkerIt->getData();
						bool invRole = roleLinkerIt->isNegated();
						CSortedNegLinker<CConcept *> *rangeConLinkerIt = role->getRangeConceptList();
						STATINC(LINKSCREATIONCOUNT,calcAlgContext);
						CIndividualLinkEdge* individualLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
						if (!invRole) {
							if (!checkRoleExisting || !hasIndividualsLink(indiSource,indiDestination,role,true,calcAlgContext)) {
								createIndividualNodeDisjointRolesLinks(indiSource,indiDestination,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
								individualLink->initIndividualLinkEdge(indiSource,indiSource,indiDestination,role,depTrackPoint);
								CReapplyQueueIterator reapplyIterator;
								reapplyIterator = installIndividualNodeRoleLinkReapplied(indiSource,indiDestination,individualLink,calcAlgContext);
								if (rangeConLinkerIt) {
									addConceptsToIndividual(rangeConLinkerIt,false,indiDestination,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
								CSortedNegLinker<CConcept *> *domainConLinkerIt = role->getDomainConceptList();
								if (domainConLinkerIt) {
									addConceptsToIndividual(domainConLinkerIt,false,indiSource,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
								applyReapplyQueueConceptsRestricted(indiSource,&reapplyIterator,individualLink,calcAlgContext);
							}
						} else {
							if (!checkRoleExisting || !hasIndividualsLink(indiDestination,indiSource,role,true,calcAlgContext)) {
								generatedInvLink = true;
								createIndividualNodeDisjointRolesLinks(indiDestination,indiSource,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
								individualLink->initIndividualLinkEdge(indiSource,indiDestination,indiSource,role,depTrackPoint);
								CReapplyQueueIterator reapplyIterator;
								reapplyIterator = installIndividualNodeRoleLinkReapplied(indiDestination,indiSource,individualLink,calcAlgContext);
								if (rangeConLinkerIt) {
									addConceptsToIndividual(rangeConLinkerIt,false,indiSource,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
								CSortedNegLinker<CConcept *> *domainConLinkerIt = role->getDomainConceptList();
								if (domainConLinkerIt) {
									addConceptsToIndividual(domainConLinkerIt,false,indiDestination,depTrackPoint,true,false,nullptr,calcAlgContext);
								}
								applyReapplyQueueConceptsRestricted(indiDestination,&reapplyIterator,individualLink,calcAlgContext);
							}
						}
						if (ancRole == role) {
							ancRoleLink = individualLink;
						}
						roleLinkerIt = roleLinkerIt->getNext();
					}
					if (generatedInvLink || indiDestination->isNominalIndividualNode()) {
						indiSource->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiDestination->getIndividualNodeID());
					}
					indiDestination->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiSource->getIndividualNodeID());
					if (mOptIncrementalCompatibleExpansion) {
						linkCreationDirectlyChangedNeighbourConnectionUpdate(indiDestination,indiSource,true,calcAlgContext);
					}
					return ancRoleLink;
				}


				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::createNewIndividualsLink(CIndividualProcessNode*& indiCreator, CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CRole* role, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					STATINC(LINKSCREATIONCOUNT,calcAlgContext);
					createIndividualNodeDisjointRolesLinks(indiSource,indiDestination,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
					CIndividualLinkEdge* individualLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
					individualLink->initIndividualLinkEdge(indiCreator,indiSource,indiDestination,role,depTrackPoint);
					//indiSource->installIndividualLink(individualLink);
					installIndividualNodeRoleLink(indiSource,indiDestination,individualLink,calcAlgContext);
					indiDestination->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiSource->getIndividualNodeID());
					if (mOptIncrementalCompatibleExpansion) {
						linkCreationDirectlyChangedNeighbourConnectionUpdate(indiDestination,indiSource,true,calcAlgContext);
					}
					return individualLink;
				}


				CIndividualLinkEdge* CCalculationTableauCompletionTaskHandleAlgorithm::createNewIndividualsLinkReapplyed(CIndividualProcessNode*& indiCreator, CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CRole* role, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					createIndividualNodeDisjointRolesLinks(indiSource,indiDestination,role->getDisjointRoleList(),depTrackPoint,calcAlgContext);
					CReapplyQueueIterator reapplyIterator;
					STATINC(LINKSCREATIONCOUNT,calcAlgContext);
					CIndividualLinkEdge* individualLink = CObjectParameterizingAllocator< CIndividualLinkEdge,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
					individualLink->initIndividualLinkEdge(indiCreator,indiSource,indiDestination,role,depTrackPoint);
					//indiSource->installIndividualLink(individualLink,&reapplyIterator);
					reapplyIterator = installIndividualNodeRoleLinkReapplied(indiSource,indiDestination,individualLink,calcAlgContext);
					CSortedNegLinker<CConcept *> *rangeConLinkerIt = role->getRangeConceptList();
					if (rangeConLinkerIt) {
						// no preprocessing, because of possible not intercepted clashes while merging
						addConceptsToIndividual(rangeConLinkerIt,false,indiDestination,depTrackPoint,false,false,nullptr,calcAlgContext);
					}
					CSortedNegLinker<CConcept *> *domainConLinkerIt = role->getDomainConceptList();
					if (domainConLinkerIt) {
						// no preprocessing, because of possible not intercepted clashes while merging
						addConceptsToIndividual(domainConLinkerIt,false,indiSource,depTrackPoint,false,false,nullptr,calcAlgContext);
					}
					applyReapplyQueueConceptsRestricted(indiSource,&reapplyIterator,individualLink,calcAlgContext);
					indiDestination->getConnectionSuccessorSet(true)->insertConnectionSuccessor(indiSource->getIndividualNodeID());
					if (mOptIncrementalCompatibleExpansion) {
						linkCreationDirectlyChangedNeighbourConnectionUpdate(indiDestination,indiSource,true,calcAlgContext);
					}
					return individualLink;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::createIndividualsDistinct(CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(DISTINCTCREATIONCOUNT,calcAlgContext);

					CDistinctEdge* disEdge = CObjectParameterizingAllocator< CDistinctEdge,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getUsedProcessContext());
					disEdge->initDistinctEdge(indiSource,indiDestination,depTrackPoint);

					indiSource->getDistinctHash(true)->insertDistinctIndividual(indiDestination->getIndividualNodeID(),disEdge);
					indiDestination->getDistinctHash(true)->insertDistinctIndividual(indiSource->getIndividualNodeID(),disEdge);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::createIndividualsDistinct(CPROCESSINGLIST<CIndividualProcessNode*>& indiList, CDependencyTrackPoint* depTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					for (CPROCESSINGLIST<CIndividualProcessNode*>::const_iterator it = indiList.constBegin(), itEnd = indiList.constEnd(); it != itEnd; ++it) {
						CIndividualProcessNode* indi1 = *it;
						CDistinctHash* disHash1 = indi1->getDistinctHash(true);
						CPROCESSINGLIST<CIndividualProcessNode*>::const_iterator it2 = it;
						for (++it2; it2 != itEnd; ++it2) {
							CIndividualProcessNode* indi2 = *it2;
							CDistinctHash* disHash2 = indi2->getDistinctHash(true);
							STATINC(DISTINCTCREATIONCOUNT,calcAlgContext);

							CDistinctEdge* disEdge = CObjectParameterizingAllocator< CDistinctEdge,CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(),calcAlgContext->getUsedProcessContext());
							disEdge->initDistinctEdge(indi1,indi2,depTrackPoint);

							disHash1->insertDistinctIndividual(indi2->getIndividualNodeID(),disEdge);
							disHash2->insertDistinctIndividual(indi1->getIndividualNodeID(),disEdge);
						}
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasIndividualsLink(CIndividualProcessNode*& indiSource, CIndividualProcessNode*& indiDestination, CRole* role, bool locateable, CCalculationAlgorithmContextBase* calcAlgContext) {
					return indiSource->hasRoleSuccessorToIndividual(role,indiDestination,locateable);
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::createNewEmptyIndividual(CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					STATINC(SUCCESSORINDINODECREATIONCOUNT,calcAlgContext);
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
					CIndividualProcessNode* newIndividual = CObjectParameterizingAllocator< CIndividualProcessNode,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
					cint64 newIndividualID = calcAlgContext->getProcessingDataBox()->getNextIndividualNodeID();
					newIndividualID = qMax(indiProcNodeVec->getItemMaxIndex()+1,newIndividualID);
					newIndividual->setIndividualNodeID(newIndividualID);
					indiProcNodeVec->setLocalData(newIndividualID,newIndividual);

					if (mOptConsistenceNodeMarking) {
						newIndividual->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCONSNODEPREPARATIONINDINODE);
					}
					if (mOptIncrementalCompatibleExpansion) {
						newIndividual->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANDING);
						newIndividual->setIncrementalExpansionID(calcAlgContext->getProcessingDataBox()->getIncrementalExpansionID());
					}
					return newIndividual;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::createNewIndividual(CDependencyTrackPoint* depTrackPoint, bool dataNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* newIndividual = createNewEmptyIndividual(calcAlgContext);
					newIndividual->initDependencyTracker(depTrackPoint);
					if (!dataNode) {
						CConcept* topConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopConcept();
						addConceptToIndividual(topConcept,false,newIndividual,depTrackPoint,true,false,calcAlgContext);
					} else {
						newIndividual->setExtendedQueueProcessing(true);
						CConcept* topDataRangeConcept = calcAlgContext->getProcessingDataBox()->getOntologyTopDataRangeConcept();
						addConceptToIndividual(topDataRangeConcept,false,newIndividual,depTrackPoint,true,false,calcAlgContext);
						newIndividual->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCONCRETEDATAINDINODE);
					}
					return newIndividual;
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAvailableUpToDateIndividual(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (isNominalIndividualNodeAvailable(indiID,calcAlgContext)) {
						return getUpToDateIndividual(indiID,calcAlgContext);
					}
					return nullptr;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getUpToDateIndividual(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!indi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag()) && indi->isRelocalized()) {
						STATINC(INDINODEUPDATELOADCOUNT,calcAlgContext);
						CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
						CIndividualProcessNode* upToDateIndi = indiProcNodeVec->getData(indi->getIndividualNodeID());
						return upToDateIndi;
					}
					return indi;
				}



				CIndividual* CCalculationTableauCompletionTaskHandleAlgorithm::createNewTemporaryNominalIndividual(cint64 indiId, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualVector* indiVector = calcAlgContext->getProcessingDataBox()->getIndividualVector(true);
					CIndividual* newIndi = CObjectAllocator<CIndividual>::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
					newIndi->initIndividual(indiId);
					newIndi->setTemporaryIndividual(true);
					indiVector->setLocalData(indiId, newIndi);
					return newIndi;
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getUpToDateIndividual(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(INDINODEUPDATELOADCOUNT,calcAlgContext);
					CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
					CIndividualProcessNode* upToDateIndi = indiProcNodeVec->getData(indiID);
					if (!upToDateIndi) {
						CIndividualVector* indiVec = calcAlgContext->getProcessingDataBox()->getIndividualVector(false);
						if (indiVec) {
							if (indiID <= 0) {
								CIndividual* individual = indiVec->getData(-(indiID));
								if (!individual) {
									individual = createNewTemporaryNominalIndividual(-(indiID), calcAlgContext);
								}
								if (individual) {

									trackIndividualReferredDependence(indiID,calcAlgContext);

									STATINC(INDINODELOCALIZEDLOADCOUNT,calcAlgContext);
									CMemoryAllocationManager* taskMemMan = nullptr;
									taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
									CIndividualProcessNode* localicedIndi = CObjectParameterizingAllocator< CIndividualProcessNode,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
									CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
									localicedIndi->initDependencyTracker(depTrackPoint);
									localicedIndi->setNominalIndividual(individual);
									localicedIndi->setIndividualType(CIndividualProcessNode::NOMINALINDIVIDUALTYPE);
									localicedIndi->setIndividualNodeID(indiID);
									indiProcNodeVec->setLocalData(localicedIndi->getIndividualNodeID(),localicedIndi);

									localicedIndi->setAssertionRoleLinker(individual->getAssertionRoleLinker());
									localicedIndi->setReverseAssertionRoleLinker(individual->getReverseAssertionRoleLinker());
									localicedIndi->setAssertionDataLinker(individual->getAssertionDataLinker());
									localicedIndi->setRoleAssertionCreationID(calcAlgContext->getUsedProcessingDataBox()->getNextRoleAssertionCreationID());
									localicedIndi->setNominalIndividualTriplesAssertions(true);


									CConcept* univConnNomValueConcept = calcAlgContext->getProcessingDataBox()->getOntology()->getTBox()->getUniversalConnectionNominalValueConcept();
									if (univConnNomValueConcept) {
										addConceptToIndividual(univConnNomValueConcept,false,localicedIndi,depTrackPoint,true,true,calcAlgContext);
									}
									CConcept* nominalConcept = individual->getIndividualNominalConcept();
									if (nominalConcept) {
										addConceptToIndividual(nominalConcept,false,localicedIndi,depTrackPoint,true,true,calcAlgContext);
									}

									if (mOptConsistenceNodeMarking) {
										localicedIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCONSNODEPREPARATIONINDINODE);
									}

									if (!mOptIncrementalCompatibleExpansion) {

										bool expansionBlocked = false;
										if (loadIndividualNodeDataFromBackendCache(localicedIndi,calcAlgContext)) {
											localicedIndi->setNominalIndividualRepresentativeBackendDataLoaded(true);
											initializeIndividualNodeWithBackendCache(localicedIndi, calcAlgContext);
											expansionBlocked = tryEstablishExpansionBlockingWithBackendCacheSynchronisation(localicedIndi,calcAlgContext);
										}

										if (!expansionBlocked) {
											addIndividualToProcessingQueue(localicedIndi,calcAlgContext);
										}
									} else {
										localicedIndi->setAssertionConceptLinker(individual->getAssertionConceptLinker());
										localicedIndi->setIncrementalExpansionID(calcAlgContext->getProcessingDataBox()->getIncrementalExpansionID());
										localicedIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFINCREMENTALEXPANDING);

										CIndividualNodeIncrementalExpansionData* expData = localicedIndi->getIncrementalExpansionData(true);
										expData->setExpansionID(calcAlgContext->getProcessingDataBox()->getNextIncrementalIndividualExpansionID(true));

									}

									upToDateIndi = localicedIndi;

								}
							}
						}
					}
					return upToDateIndi;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryEstablishExpansionBlockingWithBackendCacheSynchronisation(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool expansionBlocked = false;
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						if (assocData) {
							bool backendExpBlocking = assocData->isCompletelyHandled() && !assocData->hasRepresentativeSameIndividualMerging();
							if (backendExpBlocking && assocData->getDeterministicMergedSameConsideredLabelCacheEntry() != assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL)) {
								backendExpBlocking = false;
							}
							if (backendExpBlocking && testIndividualNodeBackendCacheConceptsSynchronization(indiNode, calcAlgContext)) {
								if (!indiNode->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFINVALIDBLOCKINGORCACHING) && mConfAllowBackendSuccessorExpansionBlocking) {
									indiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED | CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDINDIRECTNOMINALEXPANSIONBLOCKED);
								}
								expansionBlocked = true;
							}
							if (mConfAllowBackendNeighbourExpansionBlocking) {
								indiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDNEIGHBOUREXPANSIONBLOCKED | CIndividualProcessNode::PRFRETESTBACKENDSYNCHRONIZATIONDUEDIRECTMODIFIED);
							}
						}
					}

					return expansionBlocked;
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::loadIndividualNodeDataFromBackendCache(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividual* individual = indiNode->getNominalIndividual();
					if (mConfIndividualsBackendCacheLoading && mBackendCacheHandler && individual) {


						if (!indiNode->getIndividualBackendCacheSynchronisationData(false)) {


							bool scheduled = false;
							CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repBackUpdAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
							if (repBackUpdAdapter) {
								CIndividualPrecomputationCoordinationHash* indiCompCoordHash = repBackUpdAdapter->getIndividualComputationCoordinationHash();
								if (indiCompCoordHash) {
									CBackendIndividualRetrievalComputationUpdateCoordinationHashData* coordData = indiCompCoordHash->value(individual->getIndividualID());
									if (coordData && !coordData->isComputationIntegrated()) {
										coordData->setComputationIntegrated(true);
										scheduled = true;
									}
								}
							}

							CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData = mBackendCacheHandler->getIndividualAssociationData(individual, calcAlgContext);
							if (indiAssData) {



								CXLinker<CIndividualProcessNode*>* lastBackendCacheIntegratedIndividualNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								lastBackendCacheIntegratedIndividualNodeLinker->initLinker(indiNode);
								calcAlgContext->getProcessingDataBox()->addLastBackendCacheIntegratedIndividualNodeLinker(lastBackendCacheIntegratedIndividualNodeLinker);

								if (indiAssData->hasRepresentativeSameIndividualMerging()) {
									calcAlgContext->getProcessingDataBox()->incBackendCacheIntegratedSameIndividualNodeCount();
								}

								//if (CIRIName::getRecentIRIName(individual->getIndividualNameLinker()) == "http://www.Department0.University0.edu/StudentWhoLikesTennisAndBasketBallAndBaseBallAndShouldHaveManyHobbies") {
								//	bool debug = true;
								//}
								//cint64 currentExpansionCount = mProcessingDataBox->getBackendCacheIntegratedIndividualNodeCount();
								//if (currentExpansionCount > 1000) {
								//	bool debug = true;
								//}
								//cint64 currExpSameCount = mProcessingDataBox->getBackendCacheIntegratedSameIndividualNodeCount();
								//if (currentExpansionCount > debugExpansionCount) {
								//	bool debug = true;
								//}
								//if (currentExpansionCount - currExpSameCount > debugExpansionCount) {
								//	bool debug = true;
								//}
								//bool writeCache = false;
								//if (writeCache) {
								//	mBackendCacheHandler->getCache()->writeStringifiedRepresentativeCacheToFile();
								//}
								//bool writeCompletionGraph = false;
								//if (writeCompletionGraph) {
								//	QString fileName = QString("Debugging/CompletionTasks/expansion.txt");
								//	mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList(fileName, calcAlgContext);
								//}

								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = CObjectParameterizingAllocator< CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
								backendSyncData->initSynchronisationData(indiAssData);
								backendSyncData->setBackendCacheSynchron(true);
								indiNode->setIndividualBackendCacheSynchronisationData(backendSyncData);
								backendSyncData->setScheduledIndividual(scheduled);

								return true;
							} else {
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = CObjectParameterizingAllocator< CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
								backendSyncData->initSynchronisationData((CBackendRepresentativeMemoryCacheIndividualAssociationData*)nullptr);
								backendSyncData->setBackendCacheSynchron(false);
								indiNode->setIndividualBackendCacheSynchronisationData(backendSyncData);
								backendSyncData->setScheduledIndividual(scheduled);
								return true;
							}
						} else {
							return true;
						}
					}
					return false;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::initializeIndividualNodeWithBackendCache(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividual* individual = indiNode->getNominalIndividual();

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);
					if (backendSyncData) {
						if (!locBackendSyncData) {
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						}

						CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData = locBackendSyncData->getAssocitaionData();
						if (indiAssData) {

							CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

							CBackendRepresentativeMemoryLabelCacheItem* conceptSetLabelItem = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);

							mBackendCacheHandler->visitConceptsOfAssociatedFullConceptSetLabel(indiAssData, conceptSetLabelItem, [&](CConcept* concept, bool conNegation, bool deterministic)->bool {
								addConceptToIndividualSkipANDProcessing(concept, conNegation, indiNode, depTrackPoint, true, false, false, calcAlgContext);
								validateBackendSynchronisationContinued(indiNode, backendSyncData, concept, conNegation, calcAlgContext);
								return true;
							}, true, false, calcAlgContext);

							for (CConceptAssertionLinker* conAssLinkerIt = individual->getAssertionConceptLinker(); conAssLinkerIt; conAssLinkerIt = conAssLinkerIt->getNext()) {
								CConcept* concept = conAssLinkerIt->getData();
								bool negation = conAssLinkerIt->isNegated();
								if (concept->getOperatorCode() == CCNOMINAL && (concept->getNominalIndividual() == individual || negation)) {
									addConceptToIndividualSkipANDProcessing(concept, negation, indiNode, depTrackPoint, true, false, false, calcAlgContext);
								}
							}

							CIndividual* nominalIndi = indiNode->getNominalIndividual();
							if (nominalIndi) {
								CConcept* nominalConcept = nominalIndi->getIndividualNominalConcept();
								if (nominalConcept) {
									addConceptToIndividualSkipANDProcessing(nominalConcept, false, indiNode, depTrackPoint, true, true, false, calcAlgContext);
								}
							}

							locBackendSyncData->setBackendConceptSetInitialized(true);

							if (indiAssData->isCompletelyHandled()) {
								bool hasReuseableElements = false;
								if (!hasReuseableElements) {
									CBackendRepresentativeMemoryLabelCacheItem* conLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
									if (conLabel->hasNondeterministicElements()) {
										hasReuseableElements = true;
									}
								}
								if (!hasReuseableElements) {
									CBackendRepresentativeMemoryLabelCacheItem* roleNighLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL);
									if (roleNighLabel) {
										hasReuseableElements = true;
									}
								}
								if (!hasReuseableElements) {
									CBackendRepresentativeMemoryLabelCacheItem* sameIndiLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
									if (sameIndiLabel) {
										hasReuseableElements = true;
									}
								}
								if (!hasReuseableElements) {
									CBackendRepresentativeMemoryLabelCacheItem* diffIndiLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL);
									if (diffIndiLabel) {
										hasReuseableElements = true;
									}
								}

								bool reuse = mOptBackendExpansionReuse;
								if (hasReuseableElements && !reuse && mConfBackendExpansionLateDynamicReuseActivation && mConfBackendExpansionNeighbourIndividualCountReuseActivation > 0) {
									CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
									CBackendRepresentativeMemoryLabelCacheItem* nonDetSameIndiLabel = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
									cint64 sameCount = 0;
									if (detSameIndiLabel) {
										sameCount += detSameIndiLabel->getCacheValueCount();
									}
									if (nonDetSameIndiLabel) {
										sameCount += nonDetSameIndiLabel->getCacheValueCount();
									}
									if (sameCount > mConfBackendExpansionNeighbourIndividualCountReuseActivation) {
										reuse = true;
									}
								}
								if (hasReuseableElements && !reuse && mConfBackendExpansionLateDynamicReuseActivation && mConfBackendExpansionSameIndividualCountReuseActivation > 0) {
									CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = indiAssData->getRoleSetNeighbourArray();
									cint64 neighbourCount = 0;
									if (neighbourRoleSetArray) {
										CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
										for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
											neighbourCount += neighbourRoleSetArray->at(i).getIndividualCount();
										}
									}
									if (neighbourCount > mConfBackendExpansionSameIndividualCountReuseActivation) {
										reuse = true;
									}
								}
								if (reuse && hasReuseableElements) {
									if (!mOptBackendExpansionReuse) {
										calcAlgContext->getProcessingDataBox()->setBackendIndividualLateReuseExpansionActivated(true);
									}
									addIndividualToBackendReuseExpansionQueue(indiNode, calcAlgContext);
								}
							}

							addIndividualToBackendIndirectCompatibilityExpansionQueue(indiNode, calcAlgContext);

							registerProcessedIndividualForBackendConceptSetLabel(indiNode, locBackendSyncData, indiAssData, calcAlgContext);

							return true;
						}
					}
					return false;
				}


				CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBackendRepresentativeMemoryLabelCacheItem* conceptSetLabelItem = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
					CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetCombinationLabelItem = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NEIGHBOUR_INSTANTIATED_ROLE_SET_COMBINATION_LABEL);
					// TODO: also consider outgoing data property set labels to hasher
					CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher(conceptSetLabelItem, neighbourRoleSetCombinationLabelItem);
					return hasher;
				}

				CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher CCalculationTableauCompletionTaskHandleAlgorithm::getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData = backendSyncData->getAssocitaionData();					
					return getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(indiAssData, calcAlgContext);
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetRelatedProcessing(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && !backendSyncData->hasNonConceptSetBackendLabelRelatedProcessing() && backendSyncData->getAssocitaionData()) {

						CIndividualProcessNode* locIndiNode = getLocalizedIndividual(indiNode, false, calcAlgContext);

						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locIndiNode, calcAlgContext);
						locBackendSyncData->setNonConceptSetBackendLabelRelatedProcessing(true);

						if (mOptDelayedBackendInitializiation) {
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(true);

							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(indiNode, calcAlgContext);
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& processingData = (*useBackendConceptSetLabelProcessingHash)[hasher];
							processingData.decOnlyConceptSetProcessedCount(1);

							if (processingData.getOnlyConceptSetProcessedCount() <= 0) {
								CIndividualDelayedBackendInitializationProcessingQueue* delayedBackendInitProcessingQueue = calcAlgContext->getProcessingDataBox()->getDelayedBackendConceptSetLabelProcessingInitializationQueue(true);

								CXLinker<CIndividualProcessNode*>* branchQueryingNodeLinker = processingData.getBranchQueuingNodeLinker();
								CIndividualRepresentativeBackendCacheConceptSetLabelNodeQueuingLinker* rootQueringNodeLinker = processingData.getRootQueuingNodeLinker();
								while ((rootQueringNodeLinker || branchQueryingNodeLinker) && processingData.getQueuedNodeInitializingCount() <= 0) {
									if (rootQueringNodeLinker) {
										if (!rootQueringNodeLinker->isQueued()) {
											CIndividualProcessNode* queuingIndiNode = rootQueringNodeLinker->getIndividualProcessNode();
											queuingIndiNode = getUpToDateIndividual(queuingIndiNode, calcAlgContext);
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* queuingIndiNodeBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)queuingIndiNode->getIndividualBackendCacheSynchronisationData(false);
											if (queuingIndiNodeBackendSyncData && queuingIndiNodeBackendSyncData->isBackendConceptSetInitialized()) {
												rootQueringNodeLinker = rootQueringNodeLinker->getNext();
												processingData.setRootQueuingNodeLinker(rootQueringNodeLinker);
											} else {
												if (!queuingIndiNodeBackendSyncData->isBackendConceptSetInitializationQueued() && !queuingIndiNodeBackendSyncData->isBackendConceptSetInitialized()) {
													if (delayedBackendInitProcessingQueue->addIndividualNodeQueuingLinker(rootQueringNodeLinker)) {
														queuingIndiNode = getLocalizedIndividual(queuingIndiNode, true, calcAlgContext);
														CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(queuingIndiNode, calcAlgContext);
														locBackendSyncData->setBackendConceptSetInitializationQueued(true);
														rootQueringNodeLinker->setQueued(true);
														processingData.incQueuedNodeInitializingCount(1);
														rootQueringNodeLinker = rootQueringNodeLinker->getNext();
														processingData.setRootQueuingNodeLinker(rootQueringNodeLinker);
													}
												}
											}
										} else {
											CIndividualProcessNode* queuingIndiNode = rootQueringNodeLinker->getIndividualProcessNode();
											queuingIndiNode = getUpToDateIndividual(queuingIndiNode, calcAlgContext);
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* queuingIndiNodeBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)queuingIndiNode->getIndividualBackendCacheSynchronisationData(false);
											if (queuingIndiNodeBackendSyncData && !queuingIndiNodeBackendSyncData->isBackendConceptSetInitialized() && !queuingIndiNodeBackendSyncData->isBackendConceptSetInitializationQueued()) {
												processingData.incQueuedNodeInitializingCount(1);
												queuingIndiNode = getLocalizedIndividual(queuingIndiNode, true, calcAlgContext);
												CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(queuingIndiNode, calcAlgContext);
												locBackendSyncData->setBackendConceptSetInitializationQueued(true);
											}
											rootQueringNodeLinker = rootQueringNodeLinker->getNext();
											processingData.setRootQueuingNodeLinker(rootQueringNodeLinker);

										}
									} else {
										CIndividualProcessNode* queuingIndiNode = branchQueryingNodeLinker->getData();
										queuingIndiNode = getUpToDateIndividual(queuingIndiNode, calcAlgContext);
										CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* queuingIndiNodeBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)queuingIndiNode->getIndividualBackendCacheSynchronisationData(false);
										if (!queuingIndiNodeBackendSyncData->isBackendConceptSetInitializationQueued() && !queuingIndiNodeBackendSyncData->isBackendConceptSetInitialized()) {
											//processingData.mLastInitScheduledIndiNodeId = queuingIndiNode->getIndividualNodeID();
											queuingIndiNode = getLocalizedIndividual(queuingIndiNode, true, calcAlgContext);
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(queuingIndiNode, calcAlgContext);
											locBackendSyncData->setBackendConceptSetInitializationQueued(true);
											processingData.incQueuedNodeInitializingCount(1);
											delayedBackendInitProcessingQueue->insertIndiviudalProcessNode(queuingIndiNode);
										}
										branchQueryingNodeLinker = branchQueryingNodeLinker->getNext();
										processingData.setBranchQueuingNodeLinker(branchQueryingNodeLinker);
									}
								}
							}
						}
						return true;
					}
					return false;
				}











				bool CCalculationTableauCompletionTaskHandleAlgorithm::tryDelayIndividualNodeInitializationWithBackendConceptSetLabel(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividual* individual = indiNode->getNominalIndividual();

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData = backendSyncData->getAssocitaionData();
					if (indiAssData->hasIndirectlyConnectedIndividualIntegration()) {
						return false;
					}

					CBackendRepresentativeMemoryLabelCacheItem* conSetLabelItem = indiAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
					CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData* cardExtData = (CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData*)conSetLabelItem->getExtensionData(CBackendRepresentativeMemoryLabelCacheItemExtensionData::CARDINALITY_HASH);
					if (cardExtData) {
						return false;
					}

					if (!backendSyncData->isBackendConceptSetInitializationDelayingRegistered()) {
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						locBackendSyncData->setBackendConceptSetInitializationDelayingRegistered(true);


						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(true);

						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(indiNode, calcAlgContext);
						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& processingData = (*useBackendConceptSetLabelProcessingHash)[hasher];

						if (processingData.getOnlyConceptSetProcessedCount() <= 0 && processingData.getQueuedNodeInitializingCount() <= 0) {
							return false;
						} else {
							// queuing, make sure queue is initialized so the same atomic pointer is used
							CIndividualDelayedBackendInitializationProcessingQueue* delayedBackendInitProcessingQueue = calcAlgContext->getProcessingDataBox()->getDelayedBackendConceptSetLabelProcessingInitializationQueue(true);
							if (mOptDelayedBackendInitializiationWithRootLinkers && delayedBackendInitProcessingQueue->isRoot()) {
								CIndividualRepresentativeBackendCacheConceptSetLabelNodeQueuingLinker* queuingNodeLinker = CObjectAllocator< CIndividualRepresentativeBackendCacheConceptSetLabelNodeQueuingLinker >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								queuingNodeLinker->setIndividualProcessNode(indiNode);
								processingData.appendRootQueuingNodeLinker(queuingNodeLinker);
							} else {
								CXLinker<CIndividualProcessNode*>* indiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
								indiNodeLinker->initLinker(indiNode);
								processingData.appendBranchQueuingNodeLinker(indiNodeLinker);
							}

							return true;
						}
					}
					return false;

				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::registerProcessedIndividualForBackendConceptSetLabel(CIndividualProcessNode* individual, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CBackendRepresentativeMemoryCacheIndividualAssociationData* indiAssData, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mOptDelayedBackendInitializiation) {
						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(true);

						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(individual, calcAlgContext);
						CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& processingData = (*useBackendConceptSetLabelProcessingHash)[hasher];
						CXLinker<CIndividualProcessNode*>* individualNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
						individualNodeLinker->initLinker(individual);
						locBackendSyncData->setConceptSetLabelProcessedNodeLinker(individualNodeLinker);
						processingData.appendInitializedNodeLinker(individualNodeLinker);
						processingData.incOnlyConceptSetProcessedCount();
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::visitIndividualsRelevantBackendSynchronisationDataIndividuals(CIndividualProcessNode* indiNode, bool localize, function<bool(CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)> visitFunc, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool visited = false;
					bool continueVisiting = true;
					CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData) {
						continueVisiting = visitFunc(indiNode, indiNode, depTrackPoint);
						visited = true;
					}
					cint64 baseIndiId = indiNode->getNominalIndividual()->getIndividualID();
					CIndividualMergingHash* mergingHash = indiNode->getIndividualMergingHash(false);
					if (mergingHash) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						CBackendRepresentativeMemoryLabelCacheItem* detSameIndiSetLabel = nullptr;
						if (assocData) {
							//detSameIndiSetLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
							detSameIndiSetLabel = assocData->getDeterministicMergedSameConsideredLabelCacheEntry();
						}
						for (CIndividualMergingHash::const_iterator it = mergingHash->constBegin(), itEnd = mergingHash->constEnd(); it != itEnd && continueVisiting; ++it) {
							cint64 mergedIndiId = it.key();
							if (baseIndiId != mergedIndiId && it.value().isMergedWithIndividual() && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiSetLabel, mergedIndiId)) {
								CIndividualMergingHashData mergingData = it.value();
								CDependencyTrackPoint* backSyncDepTrackPoint = mergingData.getDependencyTrackPoint();

								CIndividualProcessNode* backendSyncDataIndiNode = getUpToDateIndividual(-mergedIndiId, calcAlgContext);
								if (backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false)) {
									CIndividualProcessNode* locBackendSyncDataIndiNode = backendSyncDataIndiNode;
									if (localize) {
										locBackendSyncDataIndiNode = getLocalizedIndividual(backendSyncDataIndiNode, false, calcAlgContext);
									}
									continueVisiting = visitFunc(indiNode, locBackendSyncDataIndiNode, backSyncDepTrackPoint);
									visited = true;
								}
							}
						}
					}
					return visited;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::hasNondeterministicDependency(CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool nondeterministically = true;
					if (dependencyTrackPoint && dependencyTrackPoint->getBranchingTag() <= calcAlgContext->getProcessingDataBox()->getMaximumDeterministicBranchTag()) {
						nondeterministically = false;
					}
					return nondeterministically;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::visitIndividualsRelevantMergingsBackendSynchronisationDataIndividuals(CIndividualProcessNode* indiNode, CXLinker<cint64>* mergedIndiLinker, CXLinker<cint64>* lastProcessedMergedIndiLinker, bool localize, function<bool(CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)> visitFunc, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool visited = false;
					bool continueVisiting = true;
					CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					cint64 baseIndiId = indiNode->getNominalIndividual()->getIndividualID();
					CIndividualMergingHash* mergingHash = indiNode->getIndividualMergingHash(false);
					if (mergingHash && mergedIndiLinker != lastProcessedMergedIndiLinker) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						CBackendRepresentativeMemoryLabelCacheItem* detSameIndiSetLabel = nullptr;
						CBackendRepresentativeMemoryLabelCacheItem* nondetSameIndiSetLabel = nullptr;
						if (assocData) {
							//detSameIndiSetLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
							detSameIndiSetLabel = assocData->getDeterministicMergedSameConsideredLabelCacheEntry();
							if (assocData->isCompletelyHandled()) {
								nondetSameIndiSetLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
							}
						}
						for (CXLinker<cint64>* mergedIndiLinkerIt = mergedIndiLinker; mergedIndiLinkerIt && mergedIndiLinkerIt != lastProcessedMergedIndiLinker; mergedIndiLinkerIt = mergedIndiLinkerIt->getNext()) {
							cint64 mergedIndiId = mergedIndiLinkerIt->getData();
							const CIndividualMergingHashData& mergingData = mergingHash->value(mergedIndiId);
							if (baseIndiId != mergedIndiId && mergingData.isMergedWithIndividual()) {
								bool nondeterministically = hasNondeterministicDependency(mergingData.getDependencyTrackPoint(), calcAlgContext);
								if (nondeterministically && !backendSyncData->hasNonDeterministicallyMergedIndividuals()) {
									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);
									locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
									locBackendSyncData->setNonDeterministicallyMergedIndividuals(true);
									backendSyncData = locBackendSyncData;
								}

								if (!nondeterministically && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiSetLabel, mergedIndiId) || nondeterministically && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, nondetSameIndiSetLabel, mergedIndiId)) {
									CDependencyTrackPoint* backSyncDepTrackPoint = mergingData.getDependencyTrackPoint();

									CIndividualProcessNode* backendSyncDataIndiNode = getUpToDateIndividual(-mergedIndiId, calcAlgContext);
									if (backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false)) {
										CIndividualProcessNode* locBackendSyncDataIndiNode = backendSyncDataIndiNode;
										if (localize) {
											locBackendSyncDataIndiNode = getLocalizedIndividual(backendSyncDataIndiNode, false, calcAlgContext);
										}
										continueVisiting = visitFunc(indiNode, locBackendSyncDataIndiNode, backSyncDepTrackPoint);
										visited = true;
									}
								}
							}
						}
					}
					return visited;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::visitNewlyMergedIndividualsBackendSynchronisationData(CIndividualProcessNode* indiNode, CPROCESSHASH<CIndividualProcessNode*, CDependencyTrackPoint*>* newIndiMergedHash, bool visitBaseIndividual, function<bool(CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)> visitFunc, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool visited = false;
					bool continueVisiting = true;
					CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && visitBaseIndividual) {
						continueVisiting = visitFunc(indiNode, indiNode, depTrackPoint);
						visited = true;
					}
					if (newIndiMergedHash) {
						for (CPROCESSHASH<CIndividualProcessNode*, CDependencyTrackPoint*>::const_iterator it = newIndiMergedHash->constBegin(), itEnd = newIndiMergedHash->constEnd(); it != itEnd && continueVisiting; ++it) {
							CIndividualProcessNode* backendSyncDataIndiNode = it.key();
							CDependencyTrackPoint* backSyncDepTrackPoint = it.value();

							if (backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false)) {
								continueVisiting = visitFunc(indiNode, backendSyncDataIndiNode, backSyncDepTrackPoint);
								visited = true;
							}
						}
					}
					return visited;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::visitNewlyMergedIndividualsBackendSynchronisationData(CIndividualProcessNode* indiNode, CXLinker<CIndividualProcessNode*>* newIndiMergedLinker, CXLinker<CIndividualProcessNode*>* prevIndiMergedLinker, bool visitBaseIndividual, function<bool(CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)> visitFunc, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool visited = false;
					bool continueVisiting = true;
					CDependencyTrackPoint* depTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && visitBaseIndividual) {
						continueVisiting = visitFunc(indiNode, indiNode, depTrackPoint);
						visited = true;
					}
					if (newIndiMergedLinker != prevIndiMergedLinker) {
						CIndividualMergingHash* mergingHash = indiNode->getIndividualMergingHash(false);
						for (CXLinker<CIndividualProcessNode*>* newIndiMergedLinkerIt = newIndiMergedLinker; newIndiMergedLinkerIt && newIndiMergedLinkerIt != prevIndiMergedLinker && continueVisiting; newIndiMergedLinkerIt = newIndiMergedLinkerIt->getNext()) {
							CIndividualProcessNode* backendSyncDataIndiNode = newIndiMergedLinkerIt->getData();
							backendSyncDataIndiNode = getUpToDateIndividual(backendSyncDataIndiNode, calcAlgContext);
							CIndividualMergingHashData mergingData = mergingHash->value(backendSyncDataIndiNode->getNominalIndividual()->getIndividualID());
							CDependencyTrackPoint* backSyncDepTrackPoint = mergingData.getDependencyTrackPoint();

							if (backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false)) {
								continueVisiting = visitFunc(indiNode, backendSyncDataIndiNode, backSyncDepTrackPoint);
								visited = true;
							}
						}
					}
					return visited;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(CIndividualProcessNode* indiNode, CXLinker<CIndividualProcessNode*>* newIndiMergedLinker, CXLinker<CIndividualProcessNode*>* prevIndiMergedLinker, bool visitBaseIndividual, function<bool(CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)> visitFunc, CCalculationAlgorithmContextBase* calcAlgContext) {
					return visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, newIndiMergedLinker, prevIndiMergedLinker, visitBaseIndividual, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
						if (mConfOnlyDeterministicRepresentativeBackendIndividualDataConsideration && mergedBackendSyncData) {
							CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = mergedBackendSyncData->getAssocitaionData();
							if (mergedAssocData && mergedAssocData->hasDeterministicSameIndividualMerging()) {
								return true;
							}
						}
						return visitFunc(baseIndiNode, locBackendSyncDataIndiNode, backSyncDepTrackPoint);
					}, calcAlgContext);
				}



				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getBackendCacheRoleRepresentativeNeighbourCount(CIndividualProcessNode* indiNode, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {
					cint64 linkCount = 0;
					CPROCESSHASH< CRole*, cint64 >* roleRepresentativeNeighbourCountHash = backendSyncData->getRoleRepresentativeNeighbourCountHash(false);
					if (roleRepresentativeNeighbourCountHash && roleRepresentativeNeighbourCountHash->contains(role)) {
						linkCount = roleRepresentativeNeighbourCountHash->value(role);
					} else {

						linkCount = mBackendCacheHandler->getNeighbourCountForRole(assocData, role, calcAlgContext);
						if (!mConfCardinalityNeighbourExpansionRepresentativeCounting || linkCount <= 1) {
							return linkCount;
						} else {
							CPROCESSHASH< CRole*, cint64 >* roleRepresentativeNeighbourCountHash = backendSyncData->getRoleRepresentativeNeighbourCountHash(false);
							if (!roleRepresentativeNeighbourCountHash || !roleRepresentativeNeighbourCountHash->contains(role)) {
								cint64 repNeighbourLinkCount = 0;
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								roleRepresentativeNeighbourCountHash = locBackendSyncData->getRoleRepresentativeNeighbourCountHash(true);
								mBackendCacheHandler->visitNeighbourIndividualIdsForRole(assocData, role, [&](cint64 neighbourIndiId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool deterministic)->bool {
									CBackendRepresentativeMemoryCacheIndividualAssociationData* detNeighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, false, calcAlgContext);
									if (!detNeighbourAssData || !detNeighbourAssData->hasDeterministicSameIndividualMerging()) {
										repNeighbourLinkCount++;
									}
									return true;
								}, false, calcAlgContext);
								roleRepresentativeNeighbourCountHash->insert(role, repNeighbourLinkCount);
								if (linkCount != repNeighbourLinkCount) {
									linkCount = repNeighbourLinkCount;
								}

							} else {
								linkCount = roleRepresentativeNeighbourCountHash->value(role);
							}
						}
					}
					return linkCount;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheExpansionBlockingCriticalCardinality(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool expansionBlockingCritical = false;
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);

					if (backendSyncData) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						if (!backendSyncData->isCriticalCardinalityExpansionBlocking() && assocData) {



							testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
							backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);

							if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastCriticalNeighboursTestedMergedNodeLinker()) {
								visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastCriticalNeighboursTestedMergedNodeLinker(), false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {
									expansionBlockingCritical = true;
									return false;
								}, calcAlgContext);
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setLastCriticalNeighboursTestedMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
							}



							CBackendRepresentativeMemoryLabelCacheItem* fullConSetLabelCacheItem = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
							if (fullConSetLabelCacheItem && !expansionBlockingCritical) {
								CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData* cardExtensionData = (CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData*)fullConSetLabelCacheItem->getExtensionData(CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData::CARDINALITY_HASH);
								
								CReapplyRoleSuccessorHash* roleSuccHash = indiNode->getReapplyRoleSuccessorHash(false);
								if (roleSuccHash && cardExtensionData) {
									CIndividualLinkEdge* lastAddedLinkEdge = indiNode->getLastAddedRoleLink();
									CIndividualLinkEdge* lastTestedLinkEdge = backendSyncData->getLastCriticalCardinalityLinkEdge();
									CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();


									if (lastTestedLinkEdge != lastAddedLinkEdge || !assocData->isCompletelyHandled() && !backendSyncData->hasCriticalCardinalityInitiallyChecked()) {


										CRoleVector* roleVector = calcAlgContext->getProcessingDataBox()->getOntology()->getRBox()->getRoleVector();
										for (CCACHINGHASH<cint64, CBackendRepresentativeMemoryLabelCacheItemCardinalityData*>::const_iterator it = cardExtensionData->getRoleCardinalityDataHash()->constBegin(), itEnd = cardExtensionData->getRoleCardinalityDataHash()->constEnd(); it != itEnd && !expansionBlockingCritical; ++it) {
											CRole* role = roleVector->getData(it.key());
											CBackendRepresentativeMemoryLabelCacheItemCardinalityData* cardData = it.value();

											cint64 linkCount = roleSuccHash->getRoleSuccessorCount(role);
											if (indiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
												linkCount += cardData->getExistentialMaxUsedCardinality();
											}
											if (!backendSyncData->hasAllNeighbourForcedExpansion()) {
												linkCount += getBackendCacheRoleRepresentativeNeighbourCount(indiNode, backendSyncData, assocData, role, calcAlgContext);
											}

											cint64 minCard = cardData->getMinimumRestrictingCardinality();
											if (linkCount > minCard) {
												expansionBlockingCritical = true;
											}
										}

										locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
										locBackendSyncData->setLastCriticalCardinalityLinkEdge(lastAddedLinkEdge);
										locBackendSyncData->setCriticalCardinalityInitiallyChecked(true);


									}
								}
							}


							if (expansionBlockingCritical) {
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setCriticalCardinalityExpansionBlocking(expansionBlockingCritical);
							}
						} else {
							expansionBlockingCritical = true;
						}
					}


					return expansionBlockingCritical;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndirectCompatibleRequiredIndividualNeighbourNodesFromBackendCache(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					// TODO: try non-deterministic reusing first



					//CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					//CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);



					//locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);

					testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);

					//if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastIndirectCompatibilityExpansionHandledMergedNodeLinker()) {

					//	markIndividualNodeBackendNonConceptSetRelatedProcessing(indiNode, calcAlgContext);

					//	CPROCESSSET<cint64>* remCheckingIndiSet = locBackendSyncData->getRemainingIndirectCompatibilityMergedIndividualCheckingSet(true);


					//	visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastIndirectCompatibilityExpansionHandledMergedNodeLinker(), !backendSyncData->hasMergedIndirectlyConnectedNominalIndividuals(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
					//		remCheckingIndiSet->insert(mergedLocBackendSyncDataIndiNode->getIndividualNodeID);
					//	}, calcAlgContext);

					//	locBackendSyncData->setLastIndirectCompatibilityExpansionHandledMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
					//}


					//CPROCESSSET<cint64>* remCheckingIndiSet = locBackendSyncData->getRemainingIndirectCompatibilityMergedIndividualCheckingSet(true);
					//if (remCheckingIndiSet) {
					//	for (CPROCESSSET<cint64>::iterator it = remCheckingIndiSet->begin(), itEnd = remCheckingIndiSet->end(); it != itEnd; ) {
					//		cint64 mergedIndNodeiId(*it);
					//		CIndividualProcessNode* backendSyncDataIndiNode = getUpToDateIndividual(mergedIndNodeiId, calcAlgContext);
					//		if (expandIndirectCompatibleRequiredIndividualNeighbourNodesFromBackendCache(indiNode, backendSyncDataIndiNode, calcAlgContext)) {
					//			++it;
					//		} else {
					//			it = remCheckingIndiSet->erase(it);
					//		}
					//	}
					//}
					expandIndirectCompatibleRequiredIndividualNeighbourNodesFromBackendCache(indiNode, indiNode, calcAlgContext);

					expandIndirectlyConnectedIndividuals(indiNode, true, calcAlgContext);

					return true;
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndirectCompatibleRequiredIndividualNeighbourNodesFromBackendCache(CIndividualProcessNode* indiNode, CIndividualProcessNode* checkingBackendSyncDataIndiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool requiredCheckingContinuation = false;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)checkingBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)checkingBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(true);


					CDependencyTrackPoint* backSyncDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

					CIndividualMergingHash* mergingHash = indiNode->getIndividualMergingHash(false);
					if (mergingHash && indiNode->getIndividualNodeID() != checkingBackendSyncDataIndiNode->getIndividualNodeID()) {
						CIndividualMergingHashData mergingData = mergingHash->value(checkingBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID());
						backSyncDepTrackPoint = mergingData.getDependencyTrackPoint();
					}



					// neighbours have to be integrated if
					// - there is a non-deterministic concept in the cache that is not in the current label
					// - there is a non-deterministic link in the cache to a neighbour node that is not in the completion graph
					// - there is a non-deterministic different/same individual reference that does not exist in the current completion graph

					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
					CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
					bool requiredAllNeighbourExpansion = backendSyncData->hasAllNeighbourExpansionScheduled();
					bool requiredAllNeighbourForcedExpansion = backendSyncData->hasAllNeighbourForcedExpansionScheduled();
					bool nonDeterministicConsequencesMissing = true;

					function<void(CBackendRepresentativeMemoryLabelCacheItem* conSetLabel)> nonDetConTestingFunction = [&](CBackendRepresentativeMemoryLabelCacheItem* conSetLabel) {
						if (!requiredAllNeighbourExpansion && conSetLabel && conSetLabel->hasNondeterministicElements()) {
							mBackendCacheHandler->visitConceptsOfAssociatedFullConceptSetLabel(assocData, conSetLabel, [&](CConcept* concept, bool negation, bool nondeterministic)->bool {
								if (!conSet->containsConcept(concept, negation)) {
									// only expand to those neighbours that are completely handled
									requiredAllNeighbourExpansion = true;
									nonDeterministicConsequencesMissing = true;
									return false;
								}
								return true;
							}, false, true, calcAlgContext);
						}
					};

					if (!requiredAllNeighbourExpansion && assocData) {
						nonDetConTestingFunction(assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL));
					}




					// TODO: optimize by only expand to those neighbours that have cardinality restrictions
					function<void(CBackendRepresentativeMemoryLabelCacheItem* conSetLabel)> nonDetSameTestingFunction = [&](CBackendRepresentativeMemoryLabelCacheItem* indiSetLabel) {
						if (!requiredAllNeighbourForcedExpansion && indiSetLabel) {
							mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, indiSetLabel, [&](cint64 indiId)->bool {
								if (indiId != indiNode->getNominalIndividual()->getIndividualID()) {
									if (!mergingHash || !mergingHash->contains(indiId)) {
										requiredAllNeighbourExpansion = true;
										requiredAllNeighbourForcedExpansion = true;
										nonDeterministicConsequencesMissing = true;
										return false;
									}
								}
								return true;
							}, calcAlgContext);
						}
					};

					if (!requiredAllNeighbourForcedExpansion && assocData) {
						nonDetSameTestingFunction(assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL));
					}





					// TODO: optimize by only expand to those neighbours that have cardinality restrictions
					function<void(CBackendRepresentativeMemoryLabelCacheItem* conSetLabel)> nonDetDiffTestingFunction = [&](CBackendRepresentativeMemoryLabelCacheItem* diffSetLabel) {
						if (!requiredAllNeighbourForcedExpansion && diffSetLabel) {
							CDistinctHash* distinctHash = indiNode->getDistinctHash(false);
							mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, diffSetLabel, [&](cint64 indiId)->bool {
								if (indiId != indiNode->getNominalIndividual()->getIndividualID()) {
									if (!distinctHash || !distinctHash->contains(indiId)) {
										requiredAllNeighbourExpansion = true;
										requiredAllNeighbourForcedExpansion = true;
										nonDeterministicConsequencesMissing = true;
										return false;
									}
								}
								return true;
							}, calcAlgContext);
						}
					};

					if (!requiredAllNeighbourForcedExpansion && assocData) {
						nonDetDiffTestingFunction(assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL));
					}


					if (!requiredAllNeighbourExpansion && assocData) {
						// for non-deterministically merged nodes, it is anyway required to expand all neighbours, so this check is not executed
						if (assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NEIGHBOUR_INSTANTIATED_ROLE_SET_COMBINATION_LABEL)->hasNondeterministicElements()) {

							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(checkingBackendSyncDataIndiNode, calcAlgContext);

							requiredCheckingContinuation = true;


							CRole* topRole = calcAlgContext->getProcessingDataBox()->getOntology()->getRBox()->getTopObjectRole();
							CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
							CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = assocData->getRoleSetNeighbourArray();
							if (neighbourRoleSetArray) {
								CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
								for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
									CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);
									bool nondeterministic = neighbourRoleSetLabel->hasNondeterministicElements();
									if (nondeterministic && (neighbourRoleSetLabel->getCacheValueCount() >= 1 || neighbourRoleSetLabel->getCacheValueLinker()->getCacheValue().getTag() != topRole->getRoleTag())) {
										markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);
										initializeNeighbourExpansionWithPropagation(indiNode, checkingBackendSyncDataIndiNode, locBackendSyncData, backSyncDepTrackPoint, i, nullptr, false, true, nullptr, true, false, true, calcAlgContext);
									}
								}
							}



							//CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
							//CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = assocData->getRoleSetNeighbourArray();
							//if (neighbourRoleSetArray) {
							//	CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							//	for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
							//		CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);

							//		 //check whether neighbour role label has non-deterministic role
							//		 //TODO: make check more efficient with label extension data

							//		mBackendCacheHandler->visitRolesOfAssociatedNeigbourRoleSetLabel(assocData, neighbourRoleSetlabel, [&](CRole* role, bool inversed, bool assertionLinkBase, bool nominalLinkBase, bool nondeterministic)->bool {
							//			if (nondeterministic) {

							//				markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);
							//				neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 neighbourIndiId)->bool {

							//					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
							//					if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {

							//						bool requiredNeighbourExpansion = false;

							//						// check whether non-deterministic role link is present in completion graph
							//						if (!isNominalIndividualNodeAvailable(-neighbourIndiId, calcAlgContext)) {
							//							requiredNeighbourExpansion = true;
							//						} else {
							//							CIndividualProcessNode* neighbourNode = getCorrectedNominalIndividualNode(-neighbourIndiId, calcAlgContext);

							//							if (!neighbourNode) {
							//								requiredNeighbourExpansion = true;
							//							} else {
							//								if (!inversed) {
							//									if (!indiNode->getRoleSuccessorToIndividualLink(role, neighbourNode, true)) {
							//										requiredNeighbourExpansion = true;
							//									}
							//								} else {
							//									CRole* inverseRole = role->getInverseRole();
							//									if (inverseRole) {
							//										if (!indiNode->getRoleSuccessorToIndividualLink(inverseRole, neighbourNode, true)) {
							//											requiredNeighbourExpansion = true;
							//										}
							//									} else {
							//										if (!neighbourNode->getRoleSuccessorToIndividualLink(role, indiNode, false)) {
							//											requiredNeighbourExpansion = true;
							//										}
							//									}
							//								}
							//							}
							//						}

							//						
							//						if (requiredNeighbourExpansion) {
							//							expandIndividualNeighbourNodeFromBackendCache(indiNode, assocData, neighbourIndiId, neighbourExpansionData, false, false, nullptr, backSyncDepTrackPoint, calcAlgContext);
							//						}
							//					}

							//					return true;
							//				});

							//			}
							//			return true;
							//		});

							//	
							//	}
							//}
						}
					}

					//if (!requiredAllNeighbourExpansion) {
					//	// check whether there are new links to neighbours, e.g., due to merging
					//	CIndividualLinkEdge* lastAddedLinkEdge = indiNode->getLastAddedRoleLink();

					//	CIndividualLinkEdge* lastTestedLinkEdge = backendSyncData->getLastNewNeighbourLinkEdge();

					//	CBackendRepresentativeMemoryCacheIndividualNeighbourRoleSetHash* assoNeighbourRoleSetHash = assocData->getNeighbourRoleSetHash();
					//	CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
					//	if (lastTestedLinkEdge != lastAddedLinkEdge) {

					//		CIndividualLinkEdge* linkEdgeIt = lastAddedLinkEdge;
					//		while (linkEdgeIt != lastTestedLinkEdge) {


					//			CRole* role = linkEdgeIt->getLinkRole();
					//			CIndividualProcessNode* succNode = getSuccessorIndividual(indiNode, linkEdgeIt, calcAlgContext);
					//			CIndividual* neighbourIndi = succNode->getNominalIndividual();
					//			bool deterministicRole = true;
					//			bool roleAssertion = true;
					//			CDependencyTrackPoint* linkDepTrackPoint = linkEdgeIt->getDependencyTrackPoint();
					//			if (!linkDepTrackPoint || linkDepTrackPoint->getDependencyNode()->getDependencyType() != CDependencyNode::DNTROLEASSERTIONDEPENDENCY) {
					//				roleAssertion = false;
					//			}
					//			if (!linkDepTrackPoint || linkDepTrackPoint->getBranchingTag() > calcAlgContext->getProcessingDataBox()->getMaximumDeterministicBranchTag()) {
					//				deterministicRole = false;
					//			}
					//			if (neighbourIndi) {
					//				cint64 neighbourIndiId = neighbourIndi->getIndividualID();

					//				CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
					//				if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {

					//					bool requiredNeighbourExpansion = false;
					//					if (!assoNeighbourRoleSetHash) {
					//						requiredNeighbourExpansion = true;
					//					} else {
					//						CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel = assoNeighbourRoleSetHash->getNeighbourRoleSetLabel(neighbourIndiId);
					//						if (!neighbourRoleSetLabel) {
					//							requiredNeighbourExpansion = true;
					//						} else if (!mBackendCacheHandler->hasRoleInAssociatedNeigbourRoleSetLabel(assocData, neighbourRoleSetLabel, role, false, deterministicRole)) {
					//							requiredNeighbourExpansion = true;
					//						}
					//					}

					//					if (requiredNeighbourExpansion) {
					//						expandIndividualNeighbourNodeFromBackendCache(indiNode, assocData, neighbourIndiId, neighbourExpansionData, false, nullptr, backSyncDepTrackPoint, calcAlgContext);
					//					}

					//				}

					//			}

					//			linkEdgeIt = linkEdgeIt->getNext();
					//		}

					//		locBackendSyncData->setLastNewNeighbourLinkEdge(lastAddedLinkEdge);
					//	}
					//}



					if (requiredAllNeighbourExpansion && !backendSyncData->hasAllNeighbourExpansionScheduled() || requiredAllNeighbourForcedExpansion && !backendSyncData->hasAllNeighbourForcedExpansionScheduled()) {
						expandIndividualAllNeighboursFromBackendCache(indiNode, checkingBackendSyncDataIndiNode, requiredAllNeighbourForcedExpansion, nonDeterministicConsequencesMissing, backSyncDepTrackPoint, calcAlgContext);

					}

					return requiredCheckingContinuation;

				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndividualInferringNeighboursFromBackendCache(CIndividualProcessNode* indiNode, CIndividualProcessNode* backendSyncDataIndiNode, bool forceExpansion, CDependencyTrackPoint* backSyncDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* indiBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);
					indiBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = indiBackendSyncData->getAssocitaionData();

					CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = indiBackendSyncData->getNeighbourExpansionDataHash(true);

					CIndividualProcessNodeVector* indiNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();

					CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = ((CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false))->getAssocitaionData();
					if (mergedAssocData) {
						CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = mergedAssocData->getRoleSetNeighbourArray();
						if (neighbourRoleSetArray) {
							CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
								CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);
								neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 neighbourIndiId)->bool {
									bool neighbourPotentiallyInfluenced = false;
									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
									if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
										if (isNominalIndividualNodeAvailable(-neighbourIndiId, calcAlgContext)) {
											neighbourPotentiallyInfluenced = true;
										}
										if (!neighbourExpansionData.getRoleSetLabel()) {
											neighbourExpansionData.setRoleSetLabel(neighbourRoleSetlabel);
										} else if (neighbourExpansionData.getRoleSetLabel() != neighbourRoleSetlabel) {
											neighbourPotentiallyInfluenced = true;
										}

										if (neighbourPotentiallyInfluenced) {

											visitIndividualsRelevantBackendSynchronisationDataIndividuals(indiNode, true, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
												CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)mergedLocBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
												//expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedSyncData->getAssocitaionData(), neighbourIndiId, neighbourExpansionData, true, nullptr, mergedBackSyncDepTrackPoint, calcAlgContext);

												expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedSyncData->getAssocitaionData(), neighbourIndiId, neighbourExpansionData, true, false, nullptr, mergedBackSyncDepTrackPoint, calcAlgContext);

												return true;
											}, calcAlgContext);
										}

									} else {
										CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedLocBackendSyncDataIndiNode = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(true);
										mergedLocBackendSyncDataIndiNode = getLocalizedIndividualBackendCacheSnychronisationData(backendSyncDataIndiNode, calcAlgContext);
										expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedLocBackendSyncDataIndiNode->getAssocitaionData(), neighbourIndiId, neighbourExpansionData, true, false, nullptr, backSyncDepTrackPoint, calcAlgContext);
									}
									return true;
								});

							}
						}
					}

					return true;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndividualAllNeighboursFromBackendCache(CIndividualProcessNode* indiNode, CIndividualProcessNode* backendSyncDataIndiNode, bool forceExpansion, bool nonDeterministicConsequencesMissingExpansion, CDependencyTrackPoint* backSyncDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)backendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(true);
					locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(backendSyncDataIndiNode, calcAlgContext);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locBackendSyncData->getAssocitaionData();
					locBackendSyncData->setAllNeighbourExpansionScheduled(true);
					if (forceExpansion) {
						locBackendSyncData->setAllNeighbourForcedExpansionScheduled(true);
					}
					markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);

					//QString indiName = CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker());					
					//if (indiName.contains("#Baseball") || indiName.contains("#BasketBall") || indiName.contains("#Tennis")) {
					//	bool debug = true;
					//}


					if (assocData) {
						CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);

						CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = assocData->getRoleSetNeighbourArray();
						if (neighbourRoleSetArray) {
							CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
								CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);

								initializeNeighbourExpansionWithPropagation(indiNode, backendSyncDataIndiNode, locBackendSyncData, backSyncDepTrackPoint, i, nullptr, false, false, nullptr, forceExpansion, false, nonDeterministicConsequencesMissingExpansion, calcAlgContext);

							}
						}



						function<void(CBackendRepresentativeMemoryLabelCacheItem* indiSetLabel)> expandRelatedIndividualFunction = [&](CBackendRepresentativeMemoryLabelCacheItem* indiSetLabel) {
							if (indiSetLabel) {
								mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, indiSetLabel, [&](cint64 neighbourIndiId)->bool {
									if (neighbourIndiId != indiNode->getNominalIndividual()->getIndividualID()) {
										CIndividualProcessNode* neighbourNode = getCorrectedNominalIndividualNode(-neighbourIndiId, calcAlgContext);
										if (neighbourNode != indiNode) {
											CIndividualProcessNode* locNominalIndi = getLocalizedIndividual(neighbourNode, false, calcAlgContext);
											if (locNominalIndi->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
												locNominalIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
												addIndividualToProcessingQueue(locNominalIndi, calcAlgContext);
											}
										}
									}
									return true;
								}, calcAlgContext);
							}
						};

						expandRelatedIndividualFunction(assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL));
						expandRelatedIndividualFunction(assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL));
					}


					if (indiNode->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
						indiNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
					}

					if (!locBackendSyncData->getBackendNeighbourExpansionQueue(false) || !locBackendSyncData->getBackendNeighbourExpansionQueue(false)->hasQueuedNeighbourExpansions()) {
						locBackendSyncData->setAllNeighbourExpansion(true);
						if (forceExpansion) {
							locBackendSyncData->setAllNeighbourForcedExpansion(true);
						}
					}

					return true;
				}






				CPROCESSHASH< QPair<CRole*, bool>, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationRoleNeighbourExpansionData >* CCalculationTableauCompletionTaskHandleAlgorithm::getBackendSynchronizationFilledRoleNeighbourExpansionDataHash(CIndividualProcessNode* indiNode, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CPROCESSHASH< QPair<CRole*, bool>, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationRoleNeighbourExpansionData >* roleNeighbourExpansionDataHash = locBackendSyncData->getRoleNeighbourExpansionDataHash(false);
					if (!roleNeighbourExpansionDataHash) {
						roleNeighbourExpansionDataHash = locBackendSyncData->getRoleNeighbourExpansionDataHash(true);


						CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = assocData->getRoleSetNeighbourArray();
						if (neighbourRoleSetArray) {
							CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
								CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);
								neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 indiId)->bool {

									mBackendCacheHandler->visitRolesOfAssociatedNeigbourRoleSetLabel(assocData, neighbourRoleSetlabel, [&](CRole* role, bool inversed, bool aboxAsserted, bool nominalConnection, bool nondeterministic)->bool {
										CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationRoleNeighbourExpansionData& roleNeighourExpansionData = (*roleNeighbourExpansionDataHash)[QPair<CRole*, bool>(role, inversed)];

										if (nondeterministic) {
											roleNeighourExpansionData.setPossiblyNondeterministicallyInstantiated(true);
										}
										if (!inversed) {
											CXLinker<cint64>* indiIdLinker = CObjectAllocator< CXLinker<cint64> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
											indiIdLinker->initLinker(indiId);
											roleNeighourExpansionData.addIndividualIdLinker(indiIdLinker);
										}
										return true;
									});

									return true;
								});
							}
						}
					}
					return roleNeighbourExpansionDataHash;

				}









				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndividualNeighbourNodeFromBackendCache(CIndividualProcessNode* indiNode, cint64 neighbourIndiId, CCalculationAlgorithmContextBase* calcAlgContext) {

					markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);

					testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					bool expanded = false;
					CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = backendSyncData->getNeighbourExpansionDataHash(false);

					visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), nullptr, true, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {


						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedBackendSyncData = ((CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)mergedLocBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false));
						CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = mergedBackendSyncData->getAssocitaionData();
						if (mergedAssocData) {
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData neighbourExpansionData;
							if (neighbourExpansionDataHash) {
								neighbourExpansionData = neighbourExpansionDataHash->value(neighbourIndiId);
							}
							if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& locNeighbourExpansionData = (*mergedBackendSyncData->getNeighbourExpansionDataHash(true))[neighbourIndiId];
								expanded |= expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedAssocData, neighbourIndiId, locNeighbourExpansionData, true, true, nullptr, mergedBackSyncDepTrackPoint, calcAlgContext);
							}
						}

						return true;
					}, calcAlgContext);
					
					return expanded;
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndividualNeighbourNodeFromBackendCache(CIndividualProcessNode* indiNode, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, cint64 neighbourIndiId, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData, bool forceExpansion, bool forceProcessing, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData** representativeLabelExpansionData, CDependencyTrackPoint* baseDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					// TODO: find a better strategy, e.g., only expand until to certain number of individuals, maybe also use representative cache updating adapter

					bool expanded = false;
					CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, calcAlgContext);
					if (!forceExpansion && !isNominalIndividualNodeAvailable(-neighbourIndiId, calcAlgContext)) {
						if (!neighbourAssData || !neighbourAssData->isCompletelyHandled()) {
							return false;
						}
					}

					cint64 repNeighbourIndiId = neighbourIndiId;
					if (neighbourAssData) {
						repNeighbourIndiId = neighbourAssData->getRepresentativeSameIndividualId();
					}
					neighbourExpansionData.setNeighbourPossiblyInfluenced(true);
					//add neighbour indi and directly create neighbouring role instantiations
					if (!isNominalIndividualNodeAvailable(-repNeighbourIndiId, calcAlgContext)) {
						expanded = true;
					}
					CIndividualProcessNode* locNominalIndi = getLocalizedForcedBackendInitializedNominalIndividualNode(repNeighbourIndiId, calcAlgContext);

					markIndividualNodeBackendNonConceptSetRelatedProcessing(locNominalIndi, calcAlgContext);
					if (representativeLabelExpansionData) {
						// install representative expansion feedback

						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* nominalBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locNominalIndi->getIndividualBackendCacheSynchronisationData(false);
						if (!nominalBackendSyncData->hasNonConceptSetBackendNeighbourLabelRelatedProcessing()) {
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locNominalBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locNominalIndi, calcAlgContext);
							CXLinker<CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData*>* neighbourLabelRepresentativeExpansionLinker = CObjectAllocator< CXLinker<CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
							neighbourLabelRepresentativeExpansionLinker->initLinker(*representativeLabelExpansionData);
							locNominalBackendSyncData->installNeighbourLabelRepresentativeExpansion(neighbourLabelRepresentativeExpansionLinker);
						} else {
							*representativeLabelExpansionData = nullptr;
						}
					}

					if (locNominalIndi->hasPurgedBlockedProcessingRestrictionFlags()) {
						return false;
					}

					if (forceProcessing && locNominalIndi->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
						locNominalIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
						addIndividualToProcessingQueue(locNominalIndi, calcAlgContext);
					}

					CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
					if (locNominalIndi->getNominalIndividual() && -repNeighbourIndiId != locNominalIndi->getIndividualNodeID() && repNeighbourIndiId != locNominalIndi->getNominalIndividual()->getIndividualID() && locNominalIndi->getIndividualMergingHash(false)) {
						nominalConDepTrackPoint = locNominalIndi->getIndividualMergingHash(false)->value(repNeighbourIndiId).getDependencyTrackPoint();
						if (!nominalConDepTrackPoint || hasNondeterministicDependency(nominalConDepTrackPoint, calcAlgContext)) {
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData tmpNeighbourExpData;
							expanded |= expandIndividualNeighbourNodeFromBackendCache(indiNode, assocData, locNominalIndi->getNominalIndividual()->getIndividualID(), tmpNeighbourExpData, forceExpansion, forceProcessing, nullptr, baseDepTrackPoint, calcAlgContext);
						}
					}

					bool nonDeterministicallyLinked = false;
					mBackendCacheHandler->visitRolesToNeigbourInAssociatedNeighbourRoleSetLabel(assocData, neighbourIndiId, [&](CRole* role, bool inversed, bool aboxAsserted, bool nominalConnection, bool nondeterministic)->bool {
						nonDeterministicallyLinked |= nondeterministic;
						if (!nondeterministic && (aboxAsserted || nominalConnection)) {
							if (!inversed) {
								if (!hasIndividualsLink(indiNode, locNominalIndi, role, true, calcAlgContext)) {
									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									if (aboxAsserted) {
										CROLEASSERTIONDependencyNode* roleAssDepNode = createROLEASSERTIONDependency(nextDepTrackPoint, indiNode, baseDepTrackPoint, nominalConDepTrackPoint, role, indiNode->getNominalIndividual(), calcAlgContext);
									} else if (nominalConnection) {
										// TODO: maybe create separate dependency
										CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint, indiNode, nullptr, baseDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
									}
									// create link
									createNewIndividualsLinksReapplyed(indiNode, locNominalIndi, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, true, calcAlgContext);

									propagateIndividualNodeModified(locNominalIndi, calcAlgContext);
									addIndividualToProcessingQueue(locNominalIndi, calcAlgContext);
									expanded = true;
								}
							} else {
								if (!hasIndividualsLink(locNominalIndi, indiNode, role, true, calcAlgContext)) {
									// create dependency
									CDependencyTrackPoint* nextDepTrackPoint = nullptr;
									if (aboxAsserted) {
										CROLEASSERTIONDependencyNode* roleAssDepNode = createROLEASSERTIONDependency(nextDepTrackPoint, indiNode, baseDepTrackPoint, nominalConDepTrackPoint, role, locNominalIndi->getNominalIndividual(), calcAlgContext);
									} else if (nominalConnection) {
										// TODO: maybe create separate dependency
										CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint, indiNode, nullptr, baseDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
									}

									// create link
									createNewIndividualsLinksReapplyed(locNominalIndi, indiNode, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, true, calcAlgContext);

									propagateIndividualNodeModified(locNominalIndi, calcAlgContext);
									addIndividualToProcessingQueue(locNominalIndi, calcAlgContext);
									expanded = true;
								}
							}


						}
						return true;
					}, calcAlgContext);

					if (nonDeterministicallyLinked && locNominalIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSINGINDIVIDUAL) && !locNominalIndi->isBackendIndirectCompatibilityExpansionQueued()) {
						addIndividualToBackendIndirectCompatibilityExpansionQueue(locNominalIndi, calcAlgContext);
					}


					return expanded;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandIndirectlyConnectedIndividuals(CIndividualProcessNode* indiNode, bool checkExpansionRequired, CCalculationAlgorithmContextBase* calcAlgContext) {
					// activate indirectly nominal connected indis from cache if there is a cardinality restriction to a newly generated nominal node or concept label has changed/is nondeterministic
					bool expanded = false;
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);


					bool requiredIndirectConnectedIndividualExpansion = !checkExpansionRequired || testIndividualNodeBackendCacheNominalIndirectConnectionBlockingCritical(indiNode, calcAlgContext);

					if (requiredIndirectConnectedIndividualExpansion) {
						testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
						backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
						locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						locBackendSyncData->setNominalIndirectConnectionIndividualExpanded(true);

						visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastIndirectlyConnectedNominalIndividualsHandledMergedNodeLinker(), !backendSyncData->hasNominalIndirectConnectionIndividualExpanded(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
	
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
							if (!backendSyncData->hasNominalIndirectConnectionIndividualExpanded()) {
								locBackendSyncDataIndiNode = getLocalizedIndividual(locBackendSyncDataIndiNode, true, calcAlgContext);
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(true);
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								mBackendCacheHandler->visitNominalIndirectlyConnectedIndividualIds(locBackendSyncData->getAssocitaionData(), locBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID(), [&](cint64 connIndiId)->bool {

									expanded = true;
									CIndividualProcessNode* locIndirectlyConnIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(connIndiId, calcAlgContext);

									markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(locIndirectlyConnIndiNode, calcAlgContext);

									if (locIndirectlyConnIndiNode->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
										locIndirectlyConnIndiNode->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED);
										addIndividualToProcessingQueue(locIndirectlyConnIndiNode, calcAlgContext);
									}

									return true;
								}, calcAlgContext);

								locBackendSyncData->setNominalIndirectConnectionIndividualExpanded(true);
							}
							return true;

						}, calcAlgContext);

						locBackendSyncData->setLastIndirectlyConnectedNominalIndividualsHandledMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
						
					}
					return expanded;
				}






				CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedIndividualBackendCacheSnychronisationData(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);
					if (!locBackendSyncData) {
						locBackendSyncData = CObjectParameterizingAllocator< CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData, CProcessContext* >::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
						locBackendSyncData->initSynchronisationData(backendSyncData);
						indiNode->setIndividualBackendCacheSynchronisationData(locBackendSyncData);
					}
					return locBackendSyncData;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandDirectlyInfluencedIndividualNeighbourNodesFromBackendCache(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool lazyNeighboursExpansionSucceded = true;
					if (indiNode->hasPurgedBlockedProcessingRestrictionFlags()) {
						return false;
					}


					//QString indiName = CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker());
					//if (indiName.contains("/StudentWhoLikesTennisAndBasketBallAndBaseBallAndShouldHaveManyHobbies")) {
					//	bool debug = true;
					//}
					//cint64 indiId = indiNode->getNominalIndividual()->getIndividualID();
					//if (mPropCuttedIndiIds.contains(indiId)) {
					//	bool debug = true;
					//	if (!mPropCuttedExpandedIndiIds.contains(indiId)) {
					//		mPropCuttedExpandedIndiIds.insert(indiId);
					//	}
					//}


					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);



					testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
					backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);

					CXLinker<CIndividualProcessNode*>* checkingMergingsLinker = nullptr;

					visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastDirectExpansionHandledMergedNodeLinker(), !backendSyncData->hasDeterministicSameIndividualMerged(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = nullptr;
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();

						if (!backendSyncData->hasDeterministicSameIndividualMerged() && assocData) {
							locBackendSyncDataIndiNode = getLocalizedIndividual(locBackendSyncDataIndiNode, true, calcAlgContext);

							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locBackendSyncDataIndiNode, calcAlgContext);
							CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
							if (detSameIndiLabel) {
								// merge all deterministic same individuals

								cint64 mergingIntoId = assocData->getRepresentativeSameIndividualId();
								CIndividualProcessNode* currIndiNode = getCorrectedMergedIntoIndividualNode(indiNode, calcAlgContext);
								cint64 indiId = currIndiNode->getNominalIndividual()->getIndividualID();
								mergingIntoId = qMin(mergingIntoId, indiId);


								mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, detSameIndiLabel, [&](cint64 sameIndiId)->bool {

									if (sameIndiId != mergingIntoId) {

										CIndividualProcessNode* locMergingIntoIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(mergingIntoId, calcAlgContext);

										CIndividualMergingHash* mergedHash = locMergingIntoIndiNode->getIndividualMergingHash(false);
										if (!mergedHash || !mergedHash->contains(sameIndiId)) {

											CIndividualProcessNode* locMergingSameIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(sameIndiId, calcAlgContext);

											mergedHash = locMergingIntoIndiNode->getIndividualMergingHash(false);
											if (!mergedHash || !mergedHash->contains(sameIndiId)) {

												CClashedDependencyDescriptor* clashDescriptors = nullptr;
												if (isIndividualNodesMergeable(locMergingIntoIndiNode, locMergingSameIndiNode, clashDescriptors, calcAlgContext)) {

													CDependencyTrackPoint* mergingSameIndiDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
													if (-sameIndiId != locMergingSameIndiNode->getIndividualNodeID()) {
														mergingSameIndiDepTrackPoint = locMergingSameIndiNode->getIndividualMergingHash(true)->value(sameIndiId).getDependencyTrackPoint();
													}

													// create dependency
													CDependencyTrackPoint* nextDepTrackPoint = nullptr;
													CSAMEINDIVIDUALSMERGEDependencyNode* mergingSameExpansionDependencyNode = createSAMEINDIVIDUALMERGEDependency(nextDepTrackPoint, locMergingIntoIndiNode, backSyncDepTrackPoint, mergingSameIndiDepTrackPoint, calcAlgContext);

													locMergingIntoIndiNode = getMergedIndividualNodes(locMergingIntoIndiNode, locMergingSameIndiNode, nextDepTrackPoint, calcAlgContext);
												} else {
													clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locBackendSyncDataIndiNode, nullptr, backSyncDepTrackPoint, calcAlgContext);
													if (-mergingIntoId != locMergingIntoIndiNode->getIndividualNodeID()) {
														CDependencyTrackPoint* depTrackPoint = locMergingIntoIndiNode->getIndividualMergingHash(true)->value(mergingIntoId).getDependencyTrackPoint();
														clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locMergingIntoIndiNode, nullptr, depTrackPoint, calcAlgContext);
													}
													if (-sameIndiId != locMergingSameIndiNode->getIndividualNodeID()) {
														CDependencyTrackPoint* depTrackPoint = locMergingSameIndiNode->getIndividualMergingHash(true)->value(sameIndiId).getDependencyTrackPoint();
														clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locMergingSameIndiNode, nullptr, depTrackPoint, calcAlgContext);
													}
													throw CCalculationClashProcessingException(clashDescriptors);
												}
											}
										}
									}
									return true;
								}, calcAlgContext);

							}

							locBackendSyncData->setDeterministicSameIndividualMerged(true);
						}
						return true;
					}, calcAlgContext);


					if (indiNode->hasPurgedBlockedProcessingRestrictionFlags()) {
						locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						locBackendSyncData->setLastDirectExpansionHandledMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
						return false;
					}

					bool newMergingsHandled = false;
					bool nonDeterministicMerged = backendSyncData->hasNonDeterministicallyMergedIndividuals();
					if (mConfAllowBackendNeighbourExpansionBlocking && mConfNewMergingsOnlyInferringExpansion && !nonDeterministicMerged) {
						checkingMergingsLinker = backendSyncData->getLastInferringExpansionHandledMergedNodeLinker();
						newMergingsHandled = true;
						if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastInferringExpansionHandledMergedNodeLinker()) {
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
							markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);

							visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastInferringExpansionHandledMergedNodeLinker(), !backendSyncData->getLastInferringExpansionHandledMergedNodeLinker(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
								mergedLocBackendSyncDataIndiNode = getLocalizedIndividual(mergedLocBackendSyncDataIndiNode, false, calcAlgContext);
								expandIndividualInferringNeighboursFromBackendCache(indiNode, mergedLocBackendSyncDataIndiNode, true, mergedBackSyncDepTrackPoint, calcAlgContext);
								return true;
							}, calcAlgContext);
							locBackendSyncData->setNewlyMergedInferringNeighbourExpansion(true);
							locBackendSyncData->setNewlyMergedIndividuals(true);
						}
					}
					if (!newMergingsHandled && (!mConfAllowBackendNeighbourExpansionBlocking || backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastDirectExpansionHandledMergedNodeLinker())) {
						checkingMergingsLinker = backendSyncData->getLastDirectExpansionHandledMergedNodeLinker();
						newMergingsHandled = true;

						locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);

						//CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
						//visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastDirectExpansionHandledMergedNodeLinker(), !backendSyncData->getLastDirectExpansionHandledMergedNodeLinker(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
						
							// might be incorrect if a node a1 is merged with a2 and b1 with b2 and the link from a1 to b1 has a disjoint role to the link from a2 to b2
							//CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = ((CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false))->getAssocitaionData();
							//if (mergedAssocData) {
							//	CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = mergedAssocData->getRoleSetNeighbourArray();
							//	if (neighbourRoleSetArray) {
							//		CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArrayIndexData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							//		for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
							//			CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);
							//			neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 neighbourIndiId)->bool {
							//				bool neighbourPotentiallyInfluenced = false;
							//				CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
							//				if (!neighbourExpansionData.getRoleSetLabel()) {
							//					neighbourExpansionData.setRoleSetLabel(neighbourRoleSetlabel);
							//				} else if (neighbourExpansionData.getRoleSetLabel() != neighbourRoleSetlabel) {
							//					neighbourPotentiallyInfluenced = true;
							//				}

							//				if (neighbourPotentiallyInfluenced) {

							//					visitIndividualsRelevantBackendSynchronisationDataIndividuals(indiNode, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
							//						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)mergedLocBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
							//						expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedSyncData->getAssocitaionData(), neighbourIndiId, neighbourExpansionData, true, nullptr, mergedBackSyncDepTrackPoint, calcAlgContext);
							//						return true;
							//					}, calcAlgContext);
							//				}

							//				return true;
							//			});

							//		}
							//	}
							//}
							//return true;




							//CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)mergedLocBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
							//CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = mergedSyncData->getAssocitaionData();

							//CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locMergedSyncData = getLocalizedIndividualBackendCacheSnychronisationData(mergedLocBackendSyncDataIndiNode, calcAlgContext);
							//CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* mergedNeighbourExpansionDataHash = locMergedSyncData->getNeighbourExpansionDataHash(true);

							//if (mergedAssocData) {
							//	CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = mergedAssocData->getRoleSetNeighbourArray();
							//	if (neighbourRoleSetArray) {
							//		CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							//		for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
							//			CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);
							//			neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 neighbourIndiId)->bool {
							//				bool neighbourPotentiallyInfluenced = true;
							//				CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& mergedNeighbourExpansionData = (*mergedNeighbourExpansionDataHash)[neighbourIndiId];
							//				if (!mergedNeighbourExpansionData.isNeighbourPossiblyInfluenced()) {
							//					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
							//					if (!neighbourExpansionData.isNeighbourPossiblyInfluenced() || neighbourExpansionData.getRoleSetLabel() != neighbourRoleSetlabel) {
							//						if (!neighbourExpansionData.getRoleSetLabel()) {
							//							neighbourExpansionData.setRoleSetLabel(neighbourRoleSetlabel);
							//						}
							//						expandIndividualNeighbourNodeFromBackendCache(indiNode, mergedSyncData->getAssocitaionData(), neighbourIndiId, neighbourExpansionData, true, true, nullptr, mergedBackSyncDepTrackPoint, calcAlgContext);
							//					}
							//					mergedNeighbourExpansionData.setNeighbourPossiblyInfluenced(true);
							//				}
							//				return true;
							//			});
							//		}
							//	}

							//}

						//	return true;
						//}, calcAlgContext);


						visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastDirectExpansionHandledMergedNodeLinker(), !backendSyncData->getLastDirectExpansionHandledMergedNodeLinker(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {

							mergedLocBackendSyncDataIndiNode = getLocalizedIndividual(mergedLocBackendSyncDataIndiNode, false, calcAlgContext);
							expandIndividualAllNeighboursFromBackendCache(indiNode, mergedLocBackendSyncDataIndiNode, true, false, mergedBackSyncDepTrackPoint, calcAlgContext);

							return true;
						}, calcAlgContext);

						locBackendSyncData->setNewlyMergedAllNeighbourExpansion(true);
						locBackendSyncData->setMergedIndividualsAllNeighbourExpanded(true);
						locBackendSyncData->setAllNeighbourExpansionScheduled(true);
						locBackendSyncData->setAllNeighbourForcedExpansionScheduled(true);
						locBackendSyncData->setNewlyMergedIndividuals(true);


						//CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						//CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
						//CBackendRepresentativeMemoryLabelCacheItem* nonDetSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);

						//bool hasNewMergings = backendSyncData->hasNewlyMergedIndividuals();
						//bool hadNewMergings = hasNewMergings;
						//if (!hasNewMergings) {
						//	visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastNewlyMergedExpansionRequiringCheckingMergedNodeLinker(), false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {
						//		cint64 mergedIndiId = mergedLocBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID();
						//		if (!mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiLabel, mergedIndiId) && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, nonDetSameIndiLabel, mergedIndiId)) {
						//			hasNewMergings = true;
						//			return false;
						//		}
						//		return true;
						//	}, calcAlgContext);
						//}


						//if (hasNewMergings) {
						//	CXLinker<CIndividualProcessNode*>* checkMergedNodleLinker = backendSyncData->getLastNewlyMergedExpansionRequiringCheckingMergedNodeLinker();
						//	if (!hadNewMergings) {
						//		checkMergedNodleLinker = nullptr;
						//	}
						//	visitNewlyMergedIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), checkMergedNodleLinker, !hadNewMergings, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* mergedLocBackendSyncDataIndiNode, CDependencyTrackPoint* mergedBackSyncDepTrackPoint)->bool {

						//		mergedLocBackendSyncDataIndiNode = getLocalizedIndividual(mergedLocBackendSyncDataIndiNode, false, calcAlgContext);
						//		expandIndividualAllNeighboursFromBackendCache(indiNode, mergedLocBackendSyncDataIndiNode, true, mergedBackSyncDepTrackPoint, calcAlgContext);

						//		return true;
						//	}, calcAlgContext);

						//	locBackendSyncData->setMergedIndividualsAllNeighbourExpanded(true);
						//	locBackendSyncData->setAllNeighbourExpansionScheduled(true);
						//	locBackendSyncData->setAllNeighbourForcedExpansionScheduled(true);
						//}
						//locBackendSyncData->setNewlyMergedIndividuals(hasNewMergings);
						//locBackendSyncData->setLastNewlyMergedExpansionRequiringCheckingMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
					}








					visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), checkingMergingsLinker, !backendSyncData->hasDeterministicDifferentIndividualDifferentiated(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {

						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = nullptr;

						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();

						if (!backendSyncData->hasDeterministicDifferentIndividualDifferentiated() && assocData) {
							locBackendSyncDataIndiNode = getLocalizedIndividual(locBackendSyncDataIndiNode, false, calcAlgContext);
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locBackendSyncDataIndiNode, calcAlgContext);
							CBackendRepresentativeMemoryLabelCacheItem* detDiffIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL);
							CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
							if (detDiffIndiLabel) {
								// add distinct links for all deterministic different individuals
								cint64 locBackendSyncIndiId = locBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID();

								mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, detDiffIndiLabel, [&](cint64 diffIndiId)->bool {

									if (diffIndiId != locBackendSyncIndiId && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiLabel, diffIndiId)) {

										CIndividualMergingHash* mergedHash = indiNode->getIndividualMergingHash(false);
										if (mergedHash && mergedHash->hasMergedIndividual(diffIndiId)) {
											// clash

											CClashedDependencyDescriptor* clashDescriptors = nullptr;
											CDependencyTrackPoint* depTrackPoint = mergedHash->value(diffIndiId).getDependencyTrackPoint();
											clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locBackendSyncDataIndiNode, nullptr, backSyncDepTrackPoint, calcAlgContext);
											clashDescriptors = createClashedConceptDescriptor(clashDescriptors, indiNode, nullptr, depTrackPoint, calcAlgContext);
											throw CCalculationClashProcessingException(clashDescriptors);

										} else {

											CIndividualProcessNode* locDifferentIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(diffIndiId, calcAlgContext);

											createIndividualsDistinct(indiNode, locDifferentIndiNode, backSyncDepTrackPoint, calcAlgContext);
										}
									}
									return true;
								}, calcAlgContext);

							}

							locBackendSyncData->setDeterministicDifferentIndividualDifferentiated(true);
						}
						return true;
					}, calcAlgContext);














					visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), checkingMergingsLinker, !backendSyncData->hasPrioritziedPropagationLinksEstablished(), [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {

						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = nullptr;

						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();

						if (!backendSyncData->hasPrioritziedPropagationLinksEstablished() && assocData) {
							locBackendSyncDataIndiNode = getLocalizedIndividual(locBackendSyncDataIndiNode, false, calcAlgContext);
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locBackendSyncDataIndiNode, calcAlgContext);

							CBackendRepresentativeMemoryLabelCacheItem* neighRoleSetCompIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NEIGHBOUR_INSTANTIATED_ROLE_SET_COMBINATION_LABEL);
							if (neighRoleSetCompIndiLabel) {

								CRole* topRole = calcAlgContext->getProcessingDataBox()->getOntology()->getRBox()->getTopObjectRole();
								mBackendCacheHandler->visitNeighbourArrayIdsForRole(assocData, topRole, [&](cint64 neighbourArrayId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic)->bool {
									if (nondeterministic && neighbourRoleSetLabel->getCacheValueCount() == 1) {
										// directly create links to all neighbours since it is a propagation cut
										initializeNeighbourExpansionWithPropagation(indiNode, locBackendSyncDataIndiNode, locBackendSyncData, backSyncDepTrackPoint, neighbourArrayId, nullptr, false, true, nullptr, true, true, false, calcAlgContext);
									}
									return true;
								}, false, calcAlgContext);								

							}

							locBackendSyncData->setPrioritziedPropagationLinksEstablished(true);
						}
						return true;
					}, calcAlgContext);


					//if (CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker()) == "http://semantics.crl.ibm.com/univ-bench-dl.owl#Baseball") {
					//	bool debug = true;
					//}


					if (!backendSyncData->hasAllNeighbourExpansionScheduled()) {
						visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), checkingMergingsLinker, true, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {

							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locSyncBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
							locSyncBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locBackendSyncDataIndiNode, calcAlgContext);

							if (backendSyncData && mBackendCacheHandler && locSyncBackendSyncData->getAssocitaionData()) {
								CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locSyncBackendSyncData->getAssocitaionData();

								bool cardBlockCrit = testIndividualNodeBackendCacheExpansionBlockingCriticalCardinality(indiNode, calcAlgContext);
								if (cardBlockCrit || testIndividualNodeBackendCacheNeighbourExpansionBlockingCritical(indiNode, calcAlgContext)) {
									CConceptDescriptor* lastTestedConDes = locSyncBackendSyncData->getLastNeighbourInfluenceTestedConceptDescriptor();
									CConceptDescriptor* lastNeighbourCriticalConDes = locSyncBackendSyncData->getLastCriticalNeighbourExpansionTestedConceptDescriptor();
									if (cardBlockCrit && !locSyncBackendSyncData->hasNeighbourInfluenceTestingCriticalCardinalityReset()) {
										lastNeighbourCriticalConDes = nullptr;
										lastTestedConDes = nullptr;
									}
									if (indiNode->getIndividualNodeID() != locBackendSyncDataIndiNode->getIndividualNodeID()) {
										if (indiNode->getIndividualNodeID() != locSyncBackendSyncData->getLastMergedIntoIndividualTestingCriticalCardinalityReset()) {
											lastNeighbourCriticalConDes = nullptr;
											lastTestedConDes = nullptr;
										}
									}
									CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
									if (conSet) {
										CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
										if (conDesLinker != lastTestedConDes) {
											CConceptDescriptor* conDesIt = conDesLinker;
											//locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);

											while (conDesIt && conDesIt != lastTestedConDes && conDesIt != lastNeighbourCriticalConDes) {
												CConcept* concept = conDesIt->getConcept();
												bool conNegation = conDesIt->getNegation();

												bool nondeterministic = hasNondeterministicDependency(conDesIt->getDependencyTrackPoint(), calcAlgContext) || hasNondeterministicDependency(backSyncDepTrackPoint, calcAlgContext);

												expandDirectlyInfluencedNeighboursWithPropagation(concept, conNegation, nondeterministic, baseIndiNode, assocData, locBackendSyncDataIndiNode, locSyncBackendSyncData, backSyncDepTrackPoint, calcAlgContext);

												conDesIt = conDesIt->getNext();
											}

											locSyncBackendSyncData->setLastNeighbourInfluenceTestedConceptDescriptor(conDesLinker);
											locSyncBackendSyncData->hasNeighbourInfluenceTestingCriticalCardinalityReset(cardBlockCrit);
											locSyncBackendSyncData->setLastMergedIntoIndividualTestingCriticalCardinalityReset(indiNode->getIndividualNodeID());
										}
									}
								}
							}
							return true;
						}, calcAlgContext);
					}





					if (backendSyncData->getMergedIndividualNodeLinker() != checkingMergingsLinker) {
						locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
						if (backendSyncData->getLastDirectExpansionHandledMergedNodeLinker() == checkingMergingsLinker) {
							locBackendSyncData->setLastDirectExpansionHandledMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
						} else {
							locBackendSyncData->setLastInferringExpansionHandledMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
						}
					}



							
					expandIndirectlyConnectedIndividuals(indiNode, true, calcAlgContext);


						



					return lazyNeighboursExpansionSucceded;
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::queuedIndividualBackendNeighbourExpansion(CIndividualProcessNode*& baseIndiNode, CBackendNeighbourExpansionControllingData* expContData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* indiProcNode = nullptr;

					baseIndiNode = getLocalizedIndividual(baseIndiNode, true, calcAlgContext);
					CIndividualProcessNode* mergedIntoBaseIndiNode = getCorrectedMergedIntoIndividualNode(baseIndiNode, calcAlgContext);
					mergedIntoBaseIndiNode = getLocalizedIndividual(mergedIntoBaseIndiNode, true, calcAlgContext);

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(baseIndiNode, calcAlgContext);
					CBackendNeighbourExpansionQueue* indiNeighbourExpansionQueue = locBackendSyncData->getBackendNeighbourExpansionQueue(true);

					cint64 diffNeighExpCount = 0;
					bool propagationCut = false;

					while (!propagationCut && indiNeighbourExpansionQueue->hasQueuedNeighbourExpansions() && (diffNeighExpCount++ <= mOptQueuedBackendNeighbourExpansionRolesBatchCount || mOptQueuedBackendNeighbourExpansionRolesBatchCount < 0)) {

						CBackendNeighbourExpansionQueueDataLinker* backendNeighbourExpDataLinker = indiNeighbourExpansionQueue->takeNextNeighbourExpansionQueueDataLinker();
						CBackendNeighbourExpansionQueueDataLinker* newBackendNeighbourExpDataLinker = CObjectParameterizingAllocator<CBackendNeighbourExpansionQueueDataLinker, CProcessContext*>::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
						newBackendNeighbourExpDataLinker->initQueueData(backendNeighbourExpDataLinker);

						CIndividualProcessNode* backendSyncDataIndiNode = newBackendNeighbourExpDataLinker->getBackendSyncDataIndividualNode();
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locHandlingBackendSyncData = locBackendSyncData;
						if (backendSyncDataIndiNode->getIndividualNodeID() != baseIndiNode->getIndividualNodeID()) {
							backendSyncDataIndiNode = getLocalizedIndividual(backendSyncDataIndiNode, true, calcAlgContext);
							locHandlingBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(backendSyncDataIndiNode, calcAlgContext);
						}
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locHandlingBackendSyncData->getAssocitaionData();
						CDependencyTrackPoint* backSyncDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
						// TODO/FIX: update dependency track point

						if (backendSyncDataIndiNode->getIndividualNodeID() != mergedIntoBaseIndiNode->getIndividualNodeID()) {
							backSyncDepTrackPoint = mergedIntoBaseIndiNode->getIndividualMergingHash(true)->value(-backendSyncDataIndiNode->getIndividualNodeID()).getDependencyTrackPoint();
						}


						cint64 expansionCount = 0;
						cint64 newCursor = 0;
						cint64 lastCursor = 0;
						cint64 newLastExpandedNeighbourId = -1;

						cint64 currentNeighbourExpansionCount = 0;
						bool maxDirectNeighbourExpansionReached = false;
						cint64 deterministicFoundSkippedNeighbourNodeCount = 0;

						bool oneExpanded = false;
						bool finished = true;
						bool forceReadding = false;


						CPROCESSHASH< CBackendRepresentativeMemoryLabelCacheItem*, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData >* labelNeighbourExpDelayDataHash = nullptr;
						if (mOptNeighbourLabelRepresentativeExpansionDelaying) {
							labelNeighbourExpDelayDataHash = locBackendSyncData->getNeighbourLabelExpansionDataHash(newBackendNeighbourExpDataLinker->getNeighbourArrayId(), true);
						}


						CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
						mBackendCacheHandler->visitNeighbourIndividualIdsForNeighbourArrayIdFromCursor(assocData, newBackendNeighbourExpDataLinker->getNeighbourArrayId(), [&](cint64 neighbourIndiId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic, cint64 nextCursor)->bool {

							bool expanded = false;
							if (canExpansionPotentiallyInfluenceNeighbourWithPotentialPropagation(mergedIntoBaseIndiNode, newBackendNeighbourExpDataLinker->getConcept(), newBackendNeighbourExpDataLinker->getConceptNegation(), newBackendNeighbourExpDataLinker->getConceptNondeterministic(), assocData, neighbourIndiId, calcAlgContext)) {

								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
								if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
									CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, calcAlgContext);

									if (mProcessingDataBox->getBackendCacheIntegratedIndividualNodeCount() >= mOptMaxBackendNeighbourTotalExpansionCount && mOptMaxBackendNeighbourTotalExpansionCount > 0 && (!neighbourAssData || !neighbourAssData->hasProblematicLevel())) {
										maxDirectNeighbourExpansionReached = true;
									}


									if (!maxDirectNeighbourExpansionReached) {
										newLastExpandedNeighbourId = neighbourIndiId;
										newCursor = nextCursor;

										bool representativeExpansion = mOptNeighbourLabelRepresentativeExpansionDelaying;
										bool delaying = false;
										bool expandable = true;
										bool forceExpansion = newBackendNeighbourExpDataLinker->isForceExpansion();
										if (newBackendNeighbourExpDataLinker->getConcept()) {
											expandable = canExpandDirectlyInfluencedNeighbourWithPropagation(mergedIntoBaseIndiNode, locHandlingBackendSyncData, backSyncDepTrackPoint, newBackendNeighbourExpDataLinker->getConcept(), newBackendNeighbourExpDataLinker->getConceptNegation(), newBackendNeighbourExpDataLinker->getConceptNondeterministic(), assocData, neighbourExpansionData, neighbourIndiId, neighbourAssData, calcAlgContext);
											forceExpansion = true;
										}
										bool nonDeterministicConsequencesMissingExpansion = newBackendNeighbourExpDataLinker->isMissingNondeterministicExpansionPropagation();
										if (nonDeterministicConsequencesMissingExpansion) {
											expandable = false;
											CBackendRepresentativeMemoryLabelCacheItem* neighbourConSetLabel = neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
											CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData* cardExtData = (CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData*)neighbourConSetLabel->getExtensionData(CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData::CARDINALITY_HASH);
											if (cardExtData || neighbourConSetLabel->hasNondeterministicElements()) {
												expandable = true;
											}
										}
										if (expandable) {
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData* delayingLabelNeighbourExpansionData = nullptr;
											canDelayRepresentativeNeighbourExpansion(baseIndiNode, newBackendNeighbourExpDataLinker, labelNeighbourExpDelayDataHash, newBackendNeighbourExpDataLinker->getExpandingLabel(), neighbourAssData, newBackendNeighbourExpDataLinker->getNeighbourArrayId(), lastCursor, neighbourIndiId, delayingLabelNeighbourExpansionData, delaying, representativeExpansion, calcAlgContext);

											if (!delaying) {
												CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData* representativeLabelNeighbourExpansionData = delayingLabelNeighbourExpansionData;
												if (!representativeExpansion) {
													representativeLabelNeighbourExpansionData = nullptr;
												}
												if (mergedIntoBaseIndiNode != baseIndiNode && (!backSyncDepTrackPoint || hasNondeterministicDependency(backSyncDepTrackPoint, calcAlgContext))) {
													expanded |= ensureBaseLinkExpansion(mergedIntoBaseIndiNode, mergedIntoBaseIndiNode, neighbourIndiId, calcAlgContext);
												}
												expanded |= expandIndividualNeighbourNodeFromBackendCache(mergedIntoBaseIndiNode, assocData, neighbourIndiId, neighbourExpansionData, forceExpansion, forceExpansion, &representativeLabelNeighbourExpansionData, backSyncDepTrackPoint, calcAlgContext);
												if (!representativeLabelNeighbourExpansionData) {
													representativeExpansion = false;
												}
											}

											delayingRepresentativeNeighbourExpansion(locBackendSyncData, delaying, representativeExpansion, delayingLabelNeighbourExpansionData, lastCursor, neighbourIndiId, calcAlgContext);
										}
										lastCursor = nextCursor;


										if (expanded) {
											// maybe set mIndiNodeFromQueueType
											currentNeighbourExpansionCount++;
											oneExpanded = expanded;
											if (mOptQueuedBackendNeighbourExpansionIndisBatchSize > 0 && currentNeighbourExpansionCount >= mOptQueuedBackendNeighbourExpansionIndisBatchSize) {
												finished = false;
												return false;
											} else {
												return true;
											}
										} else {
											return true;
										}
									} else {
										propagationCut = true;
										calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableRepresentativeBackendCacheUpdatingAdapter()->setExpansionLimitReached();
										CXLinker<CIndividualProcessNode*>* indiLinker = CObjectAllocator<CXLinker<CIndividualProcessNode*>>::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
										indiLinker->initLinker(backendSyncDataIndiNode);
										expContData->addCutBackendNeighbourExpansionIndividualLinker(indiLinker);
										forceReadding = true;
										finished = false;
										return false;
									}
								} else {
									lastCursor = nextCursor;
									newLastExpandedNeighbourId = neighbourIndiId;
									newCursor = nextCursor;
									return true;
								}
							} else {
								lastCursor = nextCursor;
								newLastExpandedNeighbourId = neighbourIndiId;
								newCursor = nextCursor;
								deterministicFoundSkippedNeighbourNodeCount++;
								return true;
							}

						}, newBackendNeighbourExpDataLinker->getNeighbourVisitingCursor(), false, calcAlgContext);

						if (oneExpanded) {
							indiProcNode = mergedIntoBaseIndiNode;
							
						}
						if (!finished && (newCursor || forceReadding)) {
							newBackendNeighbourExpDataLinker->updateNeighbourExpansionCursor(newLastExpandedNeighbourId, newCursor);
							indiNeighbourExpansionQueue->addNeighbourExpansionQueueDataLinker(newBackendNeighbourExpDataLinker, false);
						}

						if (propagationCut && newBackendNeighbourExpDataLinker->isPropagationCutExpansion()) {
							indiNeighbourExpansionQueue->setCuttedPropagationCutPropagation(true);
						}
					}



					if (!indiNeighbourExpansionQueue->hasQueuedNeighbourExpansions() && !locBackendSyncData->hasNeighbourLabelRepresentativeExpansion()) {
						if (locBackendSyncData->hasAllNeighbourExpansionScheduled()) {
							locBackendSyncData->setAllNeighbourExpansion(true);
						}
						if (locBackendSyncData->hasAllNeighbourForcedExpansionScheduled()) {
							locBackendSyncData->setAllNeighbourForcedExpansion(true);
						}
					}


					if (propagationCut || !indiNeighbourExpansionQueue->hasQueuedNeighbourExpansions()) {
						baseIndiNode->setBackendNeighbourExpansionQueued(false);
					} else {
						if (mProcessingDataBox->getBackendCacheIntegratedIndividualNodeCount() >= mOptCriticalBackendNeighbourTotalExpansionCount) {
							mBackendLateNeighbourExpansionQueue = mProcessingDataBox->getBackendLateIndividualNeighbourExpansionQueue(true);
							mBackendLateNeighbourExpansionQueue->insertIndiviudalProcessNode(baseIndiNode);
						} else {
							mBackendNeighbourExpansionQueue->insertIndiviudalProcessNode(baseIndiNode);
						}
					}
					return indiProcNode;
				}












				bool CCalculationTableauCompletionTaskHandleAlgorithm::canDelayRepresentativeNeighbourExpansion(CIndividualProcessNode* expIndiNode, CBackendNeighbourExpansionQueueDataLinker* backendNeighbourExpDataLinker, CPROCESSHASH<CBackendRepresentativeMemoryLabelCacheItem *, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData>* labelNeighbourExpDelayDataHash, CBackendRepresentativeMemoryLabelCacheItem* expandingLabel, CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData, cint64 arrayPos, cint64 lastCursor, cint64 neighbourIndiId, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData*& delayingLabelNeighbourExpansionData, bool& expansionDelaying, bool& representativeExpansion, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (labelNeighbourExpDelayDataHash) {
						CBackendRepresentativeMemoryLabelCacheItem* neighbourConSetLabel = neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
						if (!expandingLabel || expandingLabel == neighbourConSetLabel) {
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData& labelNeighbourExpansionData = (*labelNeighbourExpDelayDataHash)[neighbourConSetLabel];
							delayingLabelNeighbourExpansionData = &labelNeighbourExpansionData;
							if (labelNeighbourExpansionData.getNeighbourExpansionArrayId() < 0) {
								labelNeighbourExpansionData.setNeighbourExpansionArrayId(arrayPos);
								labelNeighbourExpansionData.setConceptSetLabel(neighbourConSetLabel);
								labelNeighbourExpansionData.setExpandingIndividiaulNode(expIndiNode);
								labelNeighbourExpansionData.setExpandingQueueData(backendNeighbourExpDataLinker);
							}
							if (isNominalIndividualNodeAvailable(-neighbourIndiId, calcAlgContext)) {
								expansionDelaying = false;
								representativeExpansion = false;
								++mStatRepresentativeExpansionAlreadyExistingNeighbourIndividualCount;
							} else if (labelNeighbourExpansionData.isNeighbourLabelDelayedRepresentativeExpansion()) {
								expansionDelaying = true;
								representativeExpansion = false;
								++mStatRepresentativeDelayedNeighbourIndividualExpansionCount;
							} else if (!labelNeighbourExpansionData.hasAllLabelNeighbourExpansionScheduled()) {
								expansionDelaying = false;
								representativeExpansion = true;
								++mStatRepresentativeExpansionTryingNeighbourIndividualCount;
							} else {
								expansionDelaying = false;
								representativeExpansion = false;
							}
						} else {
							expansionDelaying = true;
							representativeExpansion = false;
						}
					}
					return true;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::delayingRepresentativeNeighbourExpansion(CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, bool expansionDelaying, bool representativeExpansion, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData* labelNeighbourExpansionData, cint64 lastCursor, cint64 neighbourIndiId, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (labelNeighbourExpansionData) {
						if (representativeExpansion) {
							++mStatRepresentativeExpandedNeighbourIndividualCount;
							if (!labelNeighbourExpansionData->isNeighbourLabelDelayedRepresentativeExpansion()) {
								labelNeighbourExpansionData->setNeighbourLabelDelayedRepresentativeExpansion(true);
								labelNeighbourExpansionData->setRepresentativeExpandedIndividual(neighbourIndiId);
								locBackendSyncData->setNeighbourLabelRepresentativeExpansion(true);
							}
						}
						if (expansionDelaying) {
							if (labelNeighbourExpansionData->getNextLabelNeighbourExpansionIteratorCursor() < 0) {
								labelNeighbourExpansionData->setNextLabelNeighbourExpansionIteratorCursor(lastCursor);
							}
						}
					}
					return false;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool marked = false;
					marked |= markIndividualNodeBackendNonConceptSetRelatedProcessing(indiNode, calcAlgContext);
					marked |= markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);
					return marked;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessingForDisjointRoles(CIndividualProcessNode* indiNode, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {
					for (CSortedNegLinker<CRole*>* supRoleIt = role->getIndirectSuperRoleList(); supRoleIt; supRoleIt = supRoleIt->getNext()) {
						if (supRoleIt->getData()->hasDisjointRoles()) {
							bool marked = false;
							marked |= markIndividualNodeBackendNonConceptSetRelatedProcessing(indiNode, calcAlgContext);
							marked |= markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);
							return marked;
						}
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetRelatedProcessingForDisjointRoles(CIndividualProcessNode* indiNode, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {
					for (CSortedNegLinker<CRole*>* supRoleIt = role->getIndirectSuperRoleList(); supRoleIt; supRoleIt = supRoleIt->getNext()) {
						if (supRoleIt->getData()->hasDisjointRoles()) {
							return markIndividualNodeBackendNonConceptSetRelatedProcessing(indiNode, calcAlgContext);
						}
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessingForDisjointRoles(CIndividualProcessNode* indiNode, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {
					for (CSortedNegLinker<CRole*>* supRoleIt = role->getIndirectSuperRoleList(); supRoleIt; supRoleIt = supRoleIt->getNext()) {
						if (supRoleIt->getData()->hasDisjointRoles()) {
							return markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);							
						}
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::markIndividualNodeBackendNonConceptSetNeighbourLabelRelatedProcessing(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && !backendSyncData->hasNonConceptSetBackendLabelRelatedProcessing() && backendSyncData->getAssocitaionData()) {

						CIndividualProcessNode* locIndiNode = getLocalizedIndividual(indiNode, false, calcAlgContext);

						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(locIndiNode, calcAlgContext);
						locBackendSyncData->setNonConceptSetBackendNeighbourLabelRelatedProcessing(true);

						if (locBackendSyncData->hasNeighbourLabelRepresentativeExpansionInstalled()) {

							CXLinker<CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData*>* neighbourLabelRepresentativeExpansionLinker = locBackendSyncData->getNeighbourLabelRepresentativeExpansionLinker();
							for (CXLinker<CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData*>* neighbourLabelRepresentativeExpansionLinkerIt = neighbourLabelRepresentativeExpansionLinker; neighbourLabelRepresentativeExpansionLinkerIt; neighbourLabelRepresentativeExpansionLinkerIt = neighbourLabelRepresentativeExpansionLinkerIt->getNext()) {
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData* expData = neighbourLabelRepresentativeExpansionLinkerIt->getData();
								CIndividualProcessNode* expBaseIndiNode = expData->getExpandingIndividiaulNode();
								CBackendNeighbourExpansionQueueDataLinker* expQueuData = expData->getExpandingQueueData();


								CBackendNeighbourExpansionQueueDataLinker* newBackendNeighbourExpDataLinker = CObjectParameterizingAllocator<CBackendNeighbourExpansionQueueDataLinker, CProcessContext*>::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
								newBackendNeighbourExpDataLinker->initQueueData(expQueuData);
								newBackendNeighbourExpDataLinker->setExpandingLabel(expData->getConceptSetLabel());
								newBackendNeighbourExpDataLinker->updateNeighbourExpansionCursor(expData->getRepresentativeExpandedIndividual(), expData->getNextLabelNeighbourExpansionIteratorCursor());


								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* expLocBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(expBaseIndiNode, calcAlgContext);
								CBackendNeighbourExpansionQueue* indiNeighbourExpansionQueue = expLocBackendSyncData->getBackendNeighbourExpansionQueue(true);

								CPROCESSHASH< CBackendRepresentativeMemoryLabelCacheItem*, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData >* labelNeighbourExpDelayDataHash = expLocBackendSyncData->getNeighbourLabelExpansionDataHash(expData->getNeighbourExpansionArrayId(), true);
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationLabelNeighbourExpansionData& expHashData = (*labelNeighbourExpDelayDataHash)[expData->getConceptSetLabel()];
								expHashData.setAllLabelNeighbourExpansionScheduled(true);


								indiNeighbourExpansionQueue->addNeighbourExpansionQueueDataLinker(newBackendNeighbourExpDataLinker, false);

								if (indiNeighbourExpansionQueue->hasQueuedNeighbourExpansions() && !expBaseIndiNode->isBackendNeighbourExpansionQueued()) {
									if (mProcessingDataBox->getBackendCacheIntegratedIndividualNodeCount() >= mOptCriticalBackendNeighbourTotalExpansionCount) {
										CIndividualUnsortedProcessingQueue* backendNeighbourExpansionQueue = calcAlgContext->getUsedProcessingDataBox()->getBackendLateIndividualNeighbourExpansionQueue(true);
										backendNeighbourExpansionQueue->insertIndiviudalProcessNode(expBaseIndiNode);
									} else {
										CIndividualLinkerRotationProcessingQueue* backendNeighbourExpansionQueue = calcAlgContext->getUsedProcessingDataBox()->getBackendIndividualNeighbourExpansionQueue(true);
										backendNeighbourExpansionQueue->insertIndiviudalProcessNode(expBaseIndiNode);
									}
								}

							}

							locBackendSyncData->clearNeighbourLabelRepresentativeExpansionLinker();


						}
					}
					return false;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::prepareBackendExpansionReuseBranching(CCalculationAlgorithmContextBase* calcAlgContext) {
					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true);
					CREUSEBACKENDEXPANSIONMODESDependencyNode* reuseModesDepNode = expContData->getReuseModesDependencyNode();
					if (!reuseModesDepNode) {
						
						CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
						CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();


						CREUSEBACKENDEXPANSIONMODESDependencyNode* reuseDepNode = createREUSEBACKENDEXPANSIONMODESDependency(nullptr, calcAlgContext);

						processingDataBox->getBackendNeighbourExpansionControllingData(true)->setReuseModesDependencyNode(reuseDepNode);


						CSatisfiableTaskRepresentativeBackendUpdatingAdapter* repBackCacheUpAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableRepresentativeBackendCacheUpdatingAdapter();
						if (repBackCacheUpAdapter && !repBackCacheUpAdapter->hasExpansionLimitReached()) {
							CBackendNeighbourExpansionControllingData* backendExpControllingData = processingDataBox->getBackendNeighbourExpansionControllingData(true);
							backendExpControllingData->setPrioritizedReuseExpansionMode(true);
							return true;
						} else {

							cint64 taskCreationCount = 2;
							CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(taskCreationCount, calcAlgContext);

							CSatisfiableCalculationTask* newTaskIt = newTaskList;


							for (cint64 i = 0; i < taskCreationCount; ++i) {

								CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;

								bool fixedReusingAlternative = i == 0;


								CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
								CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext, newProcessContext, newSatCalcTask);
								CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();
								CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();
								CBackendNeighbourExpansionControllingData* newBackendExpControllingData = newProcessingDataBox->getBackendNeighbourExpansionControllingData(true);

								CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode, false, newCalcAlgContext);
								if (fixedReusingAlternative) {
									reuseDepNode->setFixedReuseDependencyTrackPoint(newDependencyTrackPoint);
								} else {
									reuseDepNode->setPriorizedReuseDependencyTrackPoint(newDependencyTrackPoint);
								}

								newBackendExpControllingData->setReuseContinuingDependencyTrackPoint(newDependencyTrackPoint);

								if (fixedReusingAlternative) {

									newBackendExpControllingData->setFixedReuseExpansionMode(true);

									CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
									newProcessTagger->incBranchingTag();
									newProcessTagger->incLocalizationTag();

								} else {
									newBackendExpControllingData->setPrioritizedReuseExpansionMode(true);
								}

								// set new task priority
								double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskReusing(newSatCalcTask, calcAlgContext->getUsedSatisfiableCalculationTask(), fixedReusingAlternative);
								newSatCalcTask->setTaskPriority(newTaskPriority);

								newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();

							}


							processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

							throw CCalculationStopProcessingException(true);
						}


					}
					return false;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::prepareBackendIndividualFixedReuseExpansion(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true);
					CREUSEBACKENDEXPANSIONMODESDependencyNode* reuseModesDepNode = expContData->getReuseModesDependencyNode();
					if (reuseModesDepNode) {


						CNonDeterministicDependencyNode* reuseDepNode = createREUSEBACKENDFIXEDINDIVIDUALEXPANSIONDependency(indiProcNode, expContData->getReuseContinuingDependencyTrackPoint(), calcAlgContext);


						CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode, true, calcAlgContext);

						CIndividualProcessNode* newIndiProcNode = getLocalizedIndividual(indiProcNode, false, calcAlgContext);
						newIndiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSINGINDIVIDUAL);
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(newIndiProcNode, calcAlgContext);
						locBackendSyncData->setBackendExpansionReuseDependencyTrackPoint(newDependencyTrackPoint);

						// directly do reuse expansion here, clashes are not problematic


						return true;


					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::prepareBackendIndividualPrioritizedReuseExpansion(CIndividualProcessNode*& indiProcNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					CBackendNeighbourExpansionControllingData* expContData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true);
					CREUSEBACKENDEXPANSIONMODESDependencyNode* reuseModesDepNode = expContData->getReuseModesDependencyNode();
					if (reuseModesDepNode) {

						CTaskProcessorContext* processorContext = calcAlgContext->getUsedTaskProcessorContext();
						CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();

						cint64 taskCreationCount = 2;
						CSatisfiableCalculationTask* newTaskList = createDependendBranchingTaskList(taskCreationCount, calcAlgContext);

						CSatisfiableCalculationTask* newTaskIt = newTaskList;

						CNonDeterministicDependencyNode* reuseDepNode = createREUSEBACKENDPRIORITIZEDINDIVIDUALEXPANSIONDependency(indiProcNode, expContData->getReuseContinuingDependencyTrackPoint(), calcAlgContext);


						for (cint64 i = 0; i < taskCreationCount; ++i) {

							CSatisfiableCalculationTask* newSatCalcTask = newTaskIt;

							bool fixedReusingAlternative = i == 0;

							CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
							CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext, newProcessContext, newSatCalcTask);
							CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();
							CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

							if (fixedReusingAlternative) {

								CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode, false, newCalcAlgContext);


								CProcessingDataBox* newProcessingDataBox = newSatCalcTask->getProcessingDataBox();

								CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
								CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext, newProcessContext, newSatCalcTask);
								CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

								CProcessTagger* newProcessTagger = newCalcAlgContext->getUsedProcessTagger();
								newProcessTagger->incBranchingTag();
								newProcessTagger->incLocalizationTag();


								CIndividualProcessNode* newIndiProcNode = getLocalizedIndividual(indiProcNode, false, newCalcAlgContext);
								newIndiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSINGINDIVIDUAL);
								CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(newIndiProcNode, calcAlgContext);
								locBackendSyncData->setBackendExpansionReuseDependencyTrackPoint(newDependencyTrackPoint);

								// add to reuse queue, don't do reuse expansion here in case of clashes
								newProcessingDataBox->getBackendIndividualReuseExpansionQueue(true)->insertIndiviudalProcessNode(newIndiProcNode);

								prepareBranchedTaskProcessing(newIndiProcNode, newSatCalcTask, newCalcAlgContext);


							} else {

								CNonDeterministicDependencyTrackPoint* newDependencyTrackPoint = createNonDeterministicDependencyTrackPointBranch(reuseDepNode, false, newCalcAlgContext);

								CProcessContext* newProcessContext = newSatCalcTask->getProcessContext(processorContext);
								CCalculationAlgorithmContextBase* newCalcAlgContext = createCalculationAlgorithmContext(processorContext, newProcessContext, newSatCalcTask);
								CMemoryAllocationManager* newAllocMemMan = newCalcAlgContext->getUsedProcessTaskMemoryAllocationManager();

								CIndividualProcessNode* newIndiProcNode = getLocalizedIndividual(indiProcNode, false, newCalcAlgContext);
								// set flag to deactivate reuse
								newIndiProcNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED);
								// add to indirect compatibility checking queue to ensure further expansion is correctly handled
								newProcessingDataBox->getBackendIndirectCompatibilityExpansionQueue(true)->insertIndiviudalProcessNode(newIndiProcNode);
								prepareBranchedTaskProcessing(newIndiProcNode, newSatCalcTask, newCalcAlgContext);

							}

							// set new task priority
							double newTaskPriority = calcAlgContext->getUsedTaskPriorityStrategy()->getPriorityForTaskReusing(newSatCalcTask, calcAlgContext->getUsedSatisfiableCalculationTask(), fixedReusingAlternative);
							newSatCalcTask->setTaskPriority(newTaskPriority);

							newTaskIt = (CSatisfiableCalculationTask*)newTaskIt->getNext();

						}
						

						processorContext->getTaskProcessorCommunicator()->communicateTaskCreation(newTaskList);

						throw CCalculationStopProcessingException(true);


					}
					return false;
				}






				bool CCalculationTableauCompletionTaskHandleAlgorithm::checkIndividualBackendExpansionReuseable(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool reusable = true;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
					if (assocData) {
						CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
						CBackendRepresentativeMemoryLabelCacheItem* conLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
						if (conLabel && conLabel->hasNondeterministicElements()) {
							// check whether non-deterministic concepts from backend cache can be added

							CReapplyConceptLabelSet* conSetLabel = indiNode->getReapplyConceptLabelSet(false);
							if (conSetLabel) {
								mBackendCacheHandler->visitConceptsOfAssociatedFullConceptSetLabel(assocData, conLabel, [&](CConcept* concept, bool negation, bool deterministic)->bool {
									if (!deterministic) {
										CConceptDescriptor* conDes = nullptr;
										CDependencyTrackPoint* depTrackPoint = nullptr;
										if (conSetLabel->getConceptDescriptor(concept, conDes, depTrackPoint)) {
											if (conDes->isNegated() != negation) {
												// negation of concept is already present, reuse not possible
												// disable reuse only if dependency is deterministic in order to ensure that problematic/involved individuals are correctly reported
												bool nondeterministically = hasNondeterministicDependency(depTrackPoint, calcAlgContext);
												if (!nondeterministically) {
													reusable = false;
													return false;
												}
											}
										}
										if (conSetLabel->hasConcept(concept, !negation)) {
											reusable = false;
											return false;
										}
									}
									return true;

								}, false, true, calcAlgContext);
							}
						}




						CBackendRepresentativeMemoryLabelCacheItem* nonDetDiffIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL);
						CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
						if (nonDetDiffIndiLabel) {
							// check whether some merging is possible
							CIndividualMergingHash* mergedHash = indiNode->getIndividualMergingHash(false);

							if (mergedHash) {
								mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, nonDetDiffIndiLabel, [&](cint64 diffIndiId)->bool {
									CIndividualMergingHashData mergingData = mergedHash->value(diffIndiId);
									if (diffIndiId != indiNode->getNominalIndividual()->getIndividualID() && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiLabel, diffIndiId) && mergingData.isMergedWithIndividual()) {
										CDependencyTrackPoint* depTrackPoint = mergingData.getDependencyTrackPoint();
										// disable reuse only if dependency is deterministic in order to ensure that problematic/involved individuals are correctly reported
										bool nondeterministically = hasNondeterministicDependency(depTrackPoint, calcAlgContext);
										if (!nondeterministically) {
											reusable = false;
											return false;
										}
									}
									return true;

								}, calcAlgContext);
							}
						}



					}

					if (!reusable) {
						indiNode->addProcessingRestrictionFlags(CIndividualProcessNode::PRFBACKENDEXPANSIONREUSEDISCARDED);
					}


					return reusable;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::reuseIndividualBackendExpansion(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool lazyNeighboursExpansionSucceded = true;


					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = locBackendSyncData;

					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();



					if (!backendSyncData->hasReuseNonDeterministicSameIndividualMerged() && assocData) {
						CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
						CBackendRepresentativeMemoryLabelCacheItem* nonDetSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
						if (nonDetSameIndiLabel) {
							// merge all nondeterministic possibly same individuals

							cint64 mergingIntoId = assocData->getRepresentativeSameIndividualId();
							mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, nonDetSameIndiLabel, [&](cint64 sameIndiId)->bool {
								if (sameIndiId < mergingIntoId) {
									mergingIntoId = sameIndiId;
								}
								return true;
							}, calcAlgContext);


							mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, nonDetSameIndiLabel, [&](cint64 sameIndiId)->bool {

								if (sameIndiId != mergingIntoId) {

									CIndividualProcessNode* locMergingIntoIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(mergingIntoId, calcAlgContext);

									CIndividualMergingHash* mergedHash = locMergingIntoIndiNode->getIndividualMergingHash(false);
									if (!mergedHash || !mergedHash->contains(sameIndiId)) {

										CIndividualProcessNode* locMergingSameIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(sameIndiId, calcAlgContext);

										mergedHash = locMergingIntoIndiNode->getIndividualMergingHash(false);
										if (!mergedHash || !mergedHash->contains(sameIndiId)) {

											CClashedDependencyDescriptor* clashDescriptors = nullptr;
											if (isIndividualNodesMergeable(locMergingIntoIndiNode, locMergingSameIndiNode, clashDescriptors, calcAlgContext)) {

												CDependencyTrackPoint* mergingSameIndiDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
												if (-sameIndiId != locMergingSameIndiNode->getIndividualNodeID()) {
													mergingSameIndiDepTrackPoint = locMergingSameIndiNode->getIndividualMergingHash(true)->value(sameIndiId).getDependencyTrackPoint();
												}

												// create dependency
												CDependencyTrackPoint* nextDepTrackPoint = nullptr;
												CSAMEINDIVIDUALSMERGEDependencyNode* mergingSameExpansionDependencyNode = createSAMEINDIVIDUALMERGEDependency(nextDepTrackPoint, locMergingIntoIndiNode, reuseExpDepTrackPoint, mergingSameIndiDepTrackPoint, calcAlgContext);

												locMergingIntoIndiNode = getMergedIndividualNodes(locMergingIntoIndiNode, locMergingSameIndiNode, nextDepTrackPoint, calcAlgContext);
											} else {
												clashDescriptors = createClashedConceptDescriptor(clashDescriptors, indiNode, nullptr, reuseExpDepTrackPoint, calcAlgContext);
												if (-mergingIntoId != locMergingIntoIndiNode->getIndividualNodeID()) {
													CDependencyTrackPoint* depTrackPoint = locMergingIntoIndiNode->getIndividualMergingHash(true)->value(mergingIntoId).getDependencyTrackPoint();
													clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locMergingIntoIndiNode, nullptr, depTrackPoint, calcAlgContext);
												}
												if (-sameIndiId != locMergingSameIndiNode->getIndividualNodeID()) {
													CDependencyTrackPoint* depTrackPoint = locMergingSameIndiNode->getIndividualMergingHash(true)->value(sameIndiId).getDependencyTrackPoint();
													clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locMergingSameIndiNode, nullptr, depTrackPoint, calcAlgContext);
												}
												throw CCalculationClashProcessingException(clashDescriptors);
											}
										}
									}
								}
								return true;
							}, calcAlgContext);

						}

						locBackendSyncData->setReuseNonDeterministicSameIndividualMerged(true);
					}



					CIndividualProcessNode* modifingIndiNode = getCorrectedMergedIntoIndividualNode(indiNode, calcAlgContext);


					if (!backendSyncData->hasReuseNonDeterministicConceptsAdded() && assocData) {
						CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
						CBackendRepresentativeMemoryLabelCacheItem* conLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
						if (conLabel && conLabel->hasNondeterministicElements()) {
							// add non-deterministic concepts from backend cache

							CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
							mBackendCacheHandler->visitConceptsOfAssociatedFullConceptSetLabel(assocData, conLabel, [&](CConcept* concept, bool negation, bool deterministic)->bool {

								if (!deterministic) {
									addConceptToIndividual(concept, negation, modifingIndiNode, reuseExpDepTrackPoint, false, false, calcAlgContext);
								}
								return true;

							}, false, true, calcAlgContext);
						}

						locBackendSyncData->setReuseNonDeterministicConceptsAdded(true);
					}





					if (assocData && assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL)) {

						CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
						CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
						CBackendRepresentativeMemoryCacheIndividualRoleSetNeighbourArray* neighbourRoleSetArray = assocData->getRoleSetNeighbourArray();
						if (neighbourRoleSetArray) {
							CBackendRepresentativeMemoryLabelCacheItemIndividualRoleSetNeighbourArrayIndexExtensionData* neighbourRoleSetArrayIndexData = neighbourRoleSetArray->getIndexData();
							for (cint64 i = 0; i < neighbourRoleSetArrayIndexData->getArraySize(); ++i) {
								CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetlabel = neighbourRoleSetArrayIndexData->getNeighbourRoleSetLabel(i);

								// check whether neighbour role label has non-deterministic role
								// TODO: make check more efficient with label extension data
								mBackendCacheHandler->visitRolesOfAssociatedNeigbourRoleSetLabel(assocData, neighbourRoleSetlabel, [&](CRole* role, bool inversed, bool assertionLinkBase, bool nominalLinkBase, bool nondeterministic)->bool {
									if (nondeterministic && role && role->getRoleTag() > 1) {

										markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(modifingIndiNode, calcAlgContext);
										neighbourRoleSetArray->at(i).visitNeighbourIndividualIds([&](cint64 neighbourIndiId)->bool {

											if (isNominalIndividualNodeAvailable(-neighbourIndiId, calcAlgContext)) {
												bool requireLinkCreation = false;
												CIndividualProcessNode* neighbourNode = getCorrectedNominalIndividualNode(-neighbourIndiId, calcAlgContext);
												if (!neighbourNode) {
													requireLinkCreation = true;
												} else {
													if (!inversed) {
														if (!modifingIndiNode->getRoleSuccessorToIndividualLink(role, neighbourNode, true)) {
															requireLinkCreation = true;
														}
													} else {
														CRole* inverseRole = role->getInverseRole();
														if (inverseRole) {
															if (!modifingIndiNode->getRoleSuccessorToIndividualLink(inverseRole, neighbourNode, true)) {
																requireLinkCreation = true;
															}
														} else {
															if (!neighbourNode->getRoleSuccessorToIndividualLink(inverseRole, modifingIndiNode, false)) {
																requireLinkCreation = true;
															}
														}
													}
												}


												if (requireLinkCreation) {
													// first ensure creation of deterministic links
													CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
													if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
														CDependencyTrackPoint* backDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

														if (indiNode != modifingIndiNode) {
															CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* modLocBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(modifingIndiNode, calcAlgContext);
															CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* modNeighbourExpansionDataHash = modLocBackendSyncData->getNeighbourExpansionDataHash(true);
															CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& modNeighbourExpansionData = (*modNeighbourExpansionDataHash)[neighbourIndiId];

															CBackendRepresentativeMemoryCacheIndividualAssociationData* modAssocData = modLocBackendSyncData->getAssocitaionData();
															if (!modNeighbourExpansionData.isNeighbourPossiblyInfluenced()) {
																expandIndividualNeighbourNodeFromBackendCache(modifingIndiNode, modAssocData, neighbourIndiId, modNeighbourExpansionData, true, false, nullptr, backDepTrackPoint, calcAlgContext);
															}
														}

														expandIndividualNeighbourNodeFromBackendCache(modifingIndiNode, assocData, neighbourIndiId, neighbourExpansionData, true, false, nullptr, backDepTrackPoint, calcAlgContext);
													} 
													if (-neighbourIndiId != neighbourNode->getIndividualNodeID()) {
														cint64 mergedIntoNeighbourIndiId = neighbourNode->getNominalIndividual()->getIndividualID();
														CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[mergedIntoNeighbourIndiId];
														if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
															CDependencyTrackPoint* backDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

															if (indiNode != modifingIndiNode) {
																CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* modLocBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(modifingIndiNode, calcAlgContext);
																CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* modNeighbourExpansionDataHash = modLocBackendSyncData->getNeighbourExpansionDataHash(true);
																CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& modNeighbourExpansionData = (*modNeighbourExpansionDataHash)[mergedIntoNeighbourIndiId];

																CBackendRepresentativeMemoryCacheIndividualAssociationData* modAssocData = modLocBackendSyncData->getAssocitaionData();
																if (!modNeighbourExpansionData.isNeighbourPossiblyInfluenced()) {
																	expandIndividualNeighbourNodeFromBackendCache(modifingIndiNode, modAssocData, mergedIntoNeighbourIndiId, modNeighbourExpansionData, true, false, nullptr, backDepTrackPoint, calcAlgContext);
																}
															}

															expandIndividualNeighbourNodeFromBackendCache(modifingIndiNode, assocData, mergedIntoNeighbourIndiId, neighbourExpansionData, true, false, nullptr, backDepTrackPoint, calcAlgContext);
														}
													}

													CIndividualProcessNode* locNeighbourNode = getLocalizedIndividual(neighbourNode, true, calcAlgContext);
													CDependencyTrackPoint* nominalConDepTrackPoint = nullptr;
													if (-neighbourIndiId != locNeighbourNode->getIndividualNodeID() && locNeighbourNode->getIndividualMergingHash(false)) {
														nominalConDepTrackPoint = locNeighbourNode->getIndividualMergingHash(false)->value(neighbourIndiId).getDependencyTrackPoint();
													}


													if (!inversed) {
														// create dependency
														CDependencyTrackPoint* nextDepTrackPoint = nullptr;

														if (nominalLinkBase) {
															CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint, modifingIndiNode, nullptr, reuseExpDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
														} else {
															CREUSEBACKENDVALUEDependencyNode* valueDepNode = createREUSEBACKENDVALUEDependency(nextDepTrackPoint, modifingIndiNode, nullptr, reuseExpDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
														}
														// create link
														createNewIndividualsLinksReapplyed(modifingIndiNode, locNeighbourNode, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, true, calcAlgContext);
													} else {
														// create dependency
														CDependencyTrackPoint* nextDepTrackPoint = nullptr;
														if (nominalLinkBase) {
															CVALUEDependencyNode* valueDepNode = createVALUEDependency(nextDepTrackPoint, modifingIndiNode, nullptr, reuseExpDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
														} else {
															CREUSEBACKENDVALUEDependencyNode* valueDepNode = createREUSEBACKENDVALUEDependency(nextDepTrackPoint, modifingIndiNode, nullptr, reuseExpDepTrackPoint, nominalConDepTrackPoint, calcAlgContext);
														}

														// create link
														createNewIndividualsLinksReapplyed(locNeighbourNode, modifingIndiNode, role->getIndirectSuperRoleList(), role, nextDepTrackPoint, true, calcAlgContext);
													}
													propagateIndividualNodeModified(locNeighbourNode, calcAlgContext);
													addIndividualToProcessingQueue(locNeighbourNode, calcAlgContext);
												}
											}

											return true;
										});
									}
									return true;
								});


							}
						}
					}





					if (!backendSyncData->hasReuseNonDeterministicDifferentIndividualStated() && assocData) {
						CDependencyTrackPoint* reuseExpDepTrackPoint = backendSyncData->getBackendExpansionReuseDependencyTrackPoint();
						CBackendRepresentativeMemoryLabelCacheItem* nonDetDiffIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_DIFFRENT_INDIVIDUAL_SET_LABEL);
						CBackendRepresentativeMemoryLabelCacheItem* detSameIndiLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
						if (nonDetDiffIndiLabel) {
							// add distinct links for all non-deterministic different individuals

							mBackendCacheHandler->visitIndividualIdsOfAssociatedIndividualSetLabel(assocData, nonDetDiffIndiLabel, [&](cint64 diffIndiId)->bool {

								if (diffIndiId != indiNode->getNominalIndividual()->getIndividualID() && !mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, detSameIndiLabel, diffIndiId)) {
									CIndividualProcessNode* locDifferentIndiNode = getLocalizedForcedBackendInitializedNominalIndividualNode(diffIndiId, calcAlgContext);

									CIndividualProcessNode* corrIndiNode = getCorrectedMergedIntoIndividualNode(modifingIndiNode, calcAlgContext);
									CIndividualMergingHash* mergedHash = corrIndiNode->getIndividualMergingHash(false);
									if (mergedHash && mergedHash->hasMergedIndividual(diffIndiId)) {
										// clash

										CClashedDependencyDescriptor* clashDescriptors = nullptr;
										CDependencyTrackPoint* depTrackPoint = mergedHash->value(diffIndiId).getDependencyTrackPoint();
										clashDescriptors = createClashedConceptDescriptor(clashDescriptors, locDifferentIndiNode, nullptr, reuseExpDepTrackPoint, calcAlgContext);
										clashDescriptors = createClashedConceptDescriptor(clashDescriptors, corrIndiNode, nullptr, depTrackPoint, calcAlgContext);
										throw CCalculationClashProcessingException(clashDescriptors);

									} else {
										createIndividualsDistinct(corrIndiNode, locDifferentIndiNode, reuseExpDepTrackPoint, calcAlgContext);
									}
								}
								return true;

							}, calcAlgContext);
						}

						locBackendSyncData->setReuseNonDeterministicDifferentIndividualStated(true);
					}







					return lazyNeighboursExpansionSucceded;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::ensurePropagationCutLinksToExpandedIndividual(CIndividualProcessNode* propCutIndiNode, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locPropCutIndiBackendSyncData, CBackendNeighbourExpansionQueueDataLinker* backendNeighbourExpDataLinker, cint64 neighbourIndiId, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool expanded = false;
					CIndividualProcessNode* baseIndiNode = propCutIndiNode;
					baseIndiNode = getLocalizedIndividual(baseIndiNode, true, calcAlgContext);
					CIndividualProcessNode* mergedIntoBaseIndiNode = getCorrectedMergedIntoIndividualNode(baseIndiNode, calcAlgContext);
					mergedIntoBaseIndiNode = getLocalizedIndividual(mergedIntoBaseIndiNode, true, calcAlgContext);

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = locPropCutIndiBackendSyncData;

					CIndividualProcessNode* backendSyncDataIndiNode = propCutIndiNode;
					if (backendNeighbourExpDataLinker) {
						backendSyncDataIndiNode = backendNeighbourExpDataLinker->getBackendSyncDataIndividualNode();
					}
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locHandlingBackendSyncData = locBackendSyncData;
					if (backendSyncDataIndiNode->getIndividualNodeID() != baseIndiNode->getIndividualNodeID()) {
						backendSyncDataIndiNode = getLocalizedIndividual(backendSyncDataIndiNode, true, calcAlgContext);
						locHandlingBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(backendSyncDataIndiNode, calcAlgContext);
					}
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locHandlingBackendSyncData->getAssocitaionData();
					CDependencyTrackPoint* backSyncDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();
					// TODO/FIX: update dependency track point


					CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
					if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, calcAlgContext);


						bool expandable = true;
						bool forceExpansion = true;
						if (backendNeighbourExpDataLinker) {
							forceExpansion = backendNeighbourExpDataLinker->isForceExpansion();
						}
						if (backendNeighbourExpDataLinker && backendNeighbourExpDataLinker->getConcept()) {
							expandable = canExpandDirectlyInfluencedNeighbourWithPropagation(mergedIntoBaseIndiNode, locHandlingBackendSyncData, backSyncDepTrackPoint, backendNeighbourExpDataLinker->getConcept(), backendNeighbourExpDataLinker->getConceptNegation(), backendNeighbourExpDataLinker->getConceptNondeterministic(), assocData, neighbourExpansionData, neighbourIndiId, neighbourAssData, calcAlgContext);
							forceExpansion = true;
						}
						if (expandable) {
							expanded = expandIndividualNeighbourNodeFromBackendCache(mergedIntoBaseIndiNode, assocData, neighbourIndiId, neighbourExpansionData, forceExpansion, forceExpansion, nullptr, backSyncDepTrackPoint, calcAlgContext);
						}
					}

					if (expanded) {
						addIndividualToProcessingQueue(mergedIntoBaseIndiNode, calcAlgContext);
					}

					return expanded;
				}








































				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedForcedBackendInitializedNominalIndividualNode(cint64 nominalId, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* differentIndiNode = getCorrectedNominalIndividualNode(-nominalId, calcAlgContext);
					return getLocalizedForcedBackendInitializedNominalIndividualNode(differentIndiNode, calcAlgContext);
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedForcedBackendInitializedNominalIndividualNode(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* locIndi = getLocalizedIndividual(indi, false, calcAlgContext);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locIndi->getIndividualBackendCacheSynchronisationData(false);
					if (backendSyncData && !backendSyncData->isBackendConceptSetInitializationRequired() && locIndi->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENPROCESSINGDELAYING)) {
						CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indi, calcAlgContext);
						locBackendSyncData->setBackendConceptSetInitializationRequired(true);
						if (locBackendSyncData->isBackendConceptSetInitializationQueued()) {
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHash* useBackendConceptSetLabelProcessingHash = calcAlgContext->getProcessingDataBox()->getBackendCacheConceptSetLabelProcessingHash(true);
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher hasher = getIndividualRepresentativeBackendCacheConceptSetLabelProcessingHasher(indi, calcAlgContext);
							CIndividualRepresentativeBackendCacheConceptSetLabelProcessingData& processingData = (*useBackendConceptSetLabelProcessingHash)[hasher];
							processingData.decQueuedNodeInitializingCount();
						}
					}
					if (!backendSyncData || !backendSyncData->isBackendConceptSetInitialized() || indi != locIndi) {
						locIndi = getForcedInitializedNominalIndividualNode(locIndi, calcAlgContext);
					}
					return locIndi;
				}



				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getForcedInitializedNominalIndividualNode(CIndividualProcessNode* indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					++mCurrentRecProcDepth;
					CIndividualProcessNode* nominalIndividual = indi;
					initialNodeInitialize(nominalIndividual, false, calcAlgContext);
					--mCurrentRecProcDepth;
					return nominalIndividual;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::expandDirectlyInfluencedNeighboursWithPropagation(CConcept* concept, bool conNegation, bool nondeterministic, CIndividualProcessNode* indiNode, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, CIndividualProcessNode* locBackendSyncDataIndiNode, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CDependencyTrackPoint* backSyncDepTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConceptOperator* conOperator = concept->getConceptOperator();
					CRole* role = concept->getRole();
					
					cint64 opCode = concept->getOperatorCode();
					CSortedNegLinker<CConcept*>* opConcepts = concept->getOperandList();
					if (mConfSpecializedAutomateRules && (opCode == CCAQAND || opCode == CCIMPLAQAND || opCode == CCBRANCHAQAND)) {
						while (opConcepts) {
							CConcept* opCon = opConcepts->getData();
							bool opConNeg = opConcepts->isNegated();
							expandDirectlyInfluencedNeighboursWithPropagation(opCon, opConNeg, nondeterministic, indiNode, assocData, locBackendSyncDataIndiNode, locBackendSyncData, backSyncDepTrackPoint, calcAlgContext);
							opConcepts = opConcepts->getNext();
						}
						return true;
					} else if (!conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCF_ATMOST) || conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_SOME_TYPE | CConceptOperator::CCF_ATLEAST)) {
						// TODO: verify cardinality is indeed critical
						if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST) ||
							mBackendCacheHandler->hasRoleInAssociatedCombinedNeigbourRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false) ||
							mBackendCacheHandler->hasRoleInAssociatedCombinedNeigbourRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false)) {

							if (role) {
								mBackendCacheHandler->visitNeighbourArrayIdsForRole(assocData, role, [&](cint64 neighbourArrayId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic)->bool {

									initializeNeighbourExpansionWithPropagation(indiNode, locBackendSyncDataIndiNode, locBackendSyncData, backSyncDepTrackPoint, neighbourArrayId, concept, conNegation, nondeterministic, role, true, false, false, calcAlgContext);
									return true;

								}, false, calcAlgContext);


							}
						}
						return true;
					}

					return false;
				}







				bool CCalculationTableauCompletionTaskHandleAlgorithm::ensureBaseLinkExpansion(CIndividualProcessNode* expIndiNode, CIndividualProcessNode* indiNode, cint64 neighbourNodeId, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool expanded = false;
					CDependencyTrackPoint* baseDepTrackPoint = calcAlgContext->getBaseDependencyNode()->getContinueDependencyTrackPoint();

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* indiNodeBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* indiNodeAssocData = indiNodeBackendSyncData->getAssocitaionData();
					if (indiNodeAssocData) {
						CBackendRepresentativeMemoryLabelCacheItem* neighbourLabel = nullptr;
						CBackendRepresentativeMemoryCacheIndividualNeighbourRoleSetHash* indiNodeHash = indiNodeAssocData->getNeighbourRoleSetHash();
						if (indiNodeHash) {
							neighbourLabel = indiNodeHash->getNeighbourRoleSetLabel(neighbourNodeId);
						}

						if (neighbourLabel) {
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData tmpExpansionData;
							expanded = expandIndividualNeighbourNodeFromBackendCache(indiNode, indiNodeAssocData, neighbourNodeId, tmpExpansionData, true, false, nullptr, baseDepTrackPoint, calcAlgContext);
						} else {
							CIndividualProcessNode* neighbourIndiNode = getLocalizedIndividual(-neighbourNodeId, calcAlgContext);
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* neighbourIndiNodeBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(neighbourIndiNode, calcAlgContext);
							CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourIndiNodeAssocData = neighbourIndiNodeBackendSyncData->getAssocitaionData();
							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData tmpExpansionData;
							expanded = expandIndividualNeighbourNodeFromBackendCache(neighbourIndiNode, neighbourIndiNodeAssocData, expIndiNode->getNominalIndividual()->getIndividualID(), tmpExpansionData, true, false, nullptr, baseDepTrackPoint, calcAlgContext);
						}
					}

					return expanded;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::initializeNeighbourExpansionWithPropagation(CIndividualProcessNode* indiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CDependencyTrackPoint* backSyncDepTrackPoint, cint64 arrayId, CConcept* concept, bool conNegation, bool nondeterministic, CRole* role, bool forceExpansion, bool propCutExpansion, bool nonDeterministicConsequencesMissingExpansion, CCalculationAlgorithmContextBase* calcAlgContext) {
					markIndividualNodeBackendNonConceptSetRelatedAndNeighbourLabelRelatedProcessing(indiNode, calcAlgContext);
					cint64 currentDirectNeighbourExpansionCount = 0;
					bool maxDirectNeighbourExpansionReached = false;
					cint64 lastExpansionVisitedNeighbourNode = -1;
					cint64 checkedNeighbourNodeCount = 0;
					cint64 iteratedNeighbourNodeCount = 0;
					cint64 deterministicFoundSkippedNeighbourNodeCount = 0;
					cint64 lastCursor = 0;
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = locBackendSyncData->getAssocitaionData();

					bool forceAllDirectExpansion = false;

					if (mConfAtmostAllDirectBackendNeighbourExpansion && concept) {
						CConceptOperator* conOperator = concept->getConceptOperator();
						if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
							forceAllDirectExpansion = true;
						}
					}



					//QString indiName = CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker());
					//if (indiName.contains("#Baseball") || indiName.contains("#BasketBall") || indiName.contains("#Tennis")) {
					//	bool debug = true;
					//}
					bool queuedExpansion = false;


					cint64 minBackendNeighbourDirectExpansionCount = mOptMinBackendNeighbourDirectExpansionCount;
					cint64 expandedCount = calcAlgContext->getUsedProcessingDataBox()->getBackendCacheIntegratedIndividualNodeCount();
					if (expandedCount > mOptCriticalBackendNeighbourTotalExpansionCount) {
						if (mOptMinDirectNeighbourExpansionOverCriticalReductionSize > 0) {
							cint64 reductionCount = (expandedCount - mOptCriticalBackendNeighbourTotalExpansionCount) / mOptMinDirectNeighbourExpansionOverCriticalReductionSize;
							minBackendNeighbourDirectExpansionCount = qMax(minBackendNeighbourDirectExpansionCount - reductionCount, (cint64)0);
						} else if (mOptMinDirectNeighbourExpansionOverCriticalReductionSize < 0) {
							minBackendNeighbourDirectExpansionCount = 0;
						}
					}

					CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
					mBackendCacheHandler->visitNeighbourIndividualIdsForNeighbourArrayIdFromCursor(assocData, arrayId, [&](cint64 neighbourIndiId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic, cint64 nextCursor)->bool {

						++iteratedNeighbourNodeCount;

						if (canExpansionPotentiallyInfluenceNeighbourWithPotentialPropagation(indiNode, concept, conNegation, nondeterministic, assocData, neighbourIndiId, calcAlgContext)) {

							CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData = (*neighbourExpansionDataHash)[neighbourIndiId];
							if (!neighbourExpansionData.isNeighbourPossiblyInfluenced()) {

								CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, calcAlgContext);

								checkedNeighbourNodeCount++;

								if (!forceAllDirectExpansion && mOptLimitBackendNeighbourExpansion && currentDirectNeighbourExpansionCount >= minBackendNeighbourDirectExpansionCount) {
									if (!mConfAllProblematicBackendNeighbourDirectExpansion || !neighbourAssData || !neighbourAssData->hasProblematicLevel()) {
										maxDirectNeighbourExpansionReached = true;
									}
								}


								if (!maxDirectNeighbourExpansionReached) {
									lastExpansionVisitedNeighbourNode = neighbourIndiId;
									lastCursor = nextCursor;



									bool expanded = false;
									bool expandable = true;
									if (concept) {
										expandable = canExpandDirectlyInfluencedNeighbourWithPropagation(indiNode, locBackendSyncData, backSyncDepTrackPoint, concept, conNegation, nondeterministic, assocData, neighbourExpansionData, neighbourIndiId, neighbourAssData, calcAlgContext);
									}
									if (nonDeterministicConsequencesMissingExpansion) {
										expandable = false;
										CBackendRepresentativeMemoryLabelCacheItem* neighbourConSetLabel = neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
										CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData* cardExtData = (CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData*)neighbourConSetLabel->getExtensionData(CBackendRepresentativeMemoryLabelCacheItemCardinalityExtensionData::CARDINALITY_HASH);
										if (cardExtData || neighbourConSetLabel->hasNondeterministicElements()) {
											expandable = true;
										}
									}
									if (expandable) {
										bool redExpCons = false;
										bool redExp = false;
										if (indiNode != locBackendSyncDataIndiNode && (!backSyncDepTrackPoint || hasNondeterministicDependency(backSyncDepTrackPoint, calcAlgContext))) {
											redExpCons = ensureBaseLinkExpansion(indiNode, indiNode, neighbourIndiId, calcAlgContext);
											expanded |= redExpCons;
										}
										expanded |= expandIndividualNeighbourNodeFromBackendCache(indiNode, assocData, neighbourIndiId, neighbourExpansionData, forceExpansion, forceExpansion, nullptr, backSyncDepTrackPoint, calcAlgContext);
									}


									if (expanded) {
										CBackendNeighbourExpansionControllingData* backendNeighbourExpansionControllingData = calcAlgContext->getUsedProcessingDataBox()->getBackendNeighbourExpansionControllingData(true);
										backendNeighbourExpansionControllingData->incExpandedNeighbourLinkCount();
										++currentDirectNeighbourExpansionCount;
									}

									return true;

								} else {
									// store in a expansion-queue to be better able to manage a further expansion
									CBackendNeighbourExpansionQueueDataLinker* expQueueData = CObjectParameterizingAllocator<CBackendNeighbourExpansionQueueDataLinker, CProcessContext*>::allocateAndConstructAndParameterize(calcAlgContext->getUsedProcessTaskMemoryAllocationManager(), calcAlgContext->getUsedProcessContext());
									expQueueData->initQueueData(arrayId, role, concept, conNegation, nondeterministic, forceExpansion, indiNode, locBackendSyncDataIndiNode, lastExpansionVisitedNeighbourNode, lastCursor, propCutExpansion, nonDeterministicConsequencesMissingExpansion);
									locBackendSyncData->getBackendNeighbourExpansionQueue(true)->addNeighbourExpansionQueueDataLinker(expQueueData, false);
									addIndividualToBackendNeighbourExpansionQueue(locBackendSyncDataIndiNode, calcAlgContext);

									queuedExpansion = true;

									return false;
								}
							} else {
								lastExpansionVisitedNeighbourNode = neighbourIndiId;
								lastCursor = nextCursor;
								return true;
							}
						} else {
							lastExpansionVisitedNeighbourNode = neighbourIndiId;
							lastCursor = nextCursor;
							deterministicFoundSkippedNeighbourNodeCount++;
							return true;
						}

					}, lastCursor, false, calcAlgContext);

					return true;
				}




				CAnsweringPropagationSteeringController* CCalculationTableauCompletionTaskHandleAlgorithm::getPropagationSteeringController(CCalculationAlgorithmContextBase* calcAlgContext) {
					CSatisfiableTaskAnswererBindingPropagationAdapter* answererMessageAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableAnswererBindingPropagationAdapter();
					if (answererMessageAdapter) {
						CAnsweringPropagationSteeringController* propagationSteeringController = answererMessageAdapter->getAnswererPropagationSteeringController();
						if (propagationSteeringController) {
							return propagationSteeringController;
						}
					}
					CSatisfiableTaskAnswererInstancePropagationMessageAdapter* answererPropMessageAdapter = calcAlgContext->getSatisfiableCalculationTask()->getSatisfiableAnswererInstancePropagationMessageAdapter();
					if (answererPropMessageAdapter) {
						CAnsweringPropagationSteeringController* propagationSteeringController = answererPropMessageAdapter->getAnswererPropagationSteeringController();
						if (propagationSteeringController) {
							return propagationSteeringController;
						}
					}
					return nullptr;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isNeighbourExpansionWithPropagationAllowed(CIndividualProcessNode* indiNode, CConcept* concept, bool conNegation, cint64 neighbourIndiId, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mConfVariableBindingSteeringBackendNeighbourExpansion && concept->getVariable()) {
						CAnsweringPropagationSteeringController* propagationSteeringController = getPropagationSteeringController(calcAlgContext);
						if (propagationSteeringController) {
							CVariable* destVar = concept->getVariable();
							bool allowProp = propagationSteeringController->isPreparationBindingAllIndividuals(destVar);
							if (!allowProp) {
								allowProp = propagationSteeringController->isPreparationBindingNominalIndividual(destVar, neighbourIndiId);
							}
							if (!allowProp) {
								return false;
							}
						}
					}
					return true;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::canExpansionPotentiallyInfluenceNeighbourWithPotentialPropagation(CIndividualProcessNode* indiNode, CConcept* concept, bool conNegation, bool nondeterministic, CBackendRepresentativeMemoryCacheIndividualAssociationData* assData, cint64 neighbourIndiId, CCalculationAlgorithmContextBase* calcAlgContext) {

					if (!concept) {
						return true;
					}

					CConceptOperator* conOperator = concept->getConceptOperator();

					if (isNeighbourExpansionWithPropagationAllowed(indiNode, concept, conNegation, neighbourIndiId, calcAlgContext)) {
						bool neighbourPotentiallyInfluenced = false;

						CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, false, calcAlgContext);
						if (!neighbourAssData) {
							neighbourPotentiallyInfluenced = true;

							// mConfExpandDeterministicMergedHandledNeighbours must be true, otherwise cache may be incomplete since incompletely handled is only if there are changes despite a non matching update id
						} else if (mConfExpandDeterministicMergedHandledNeighbours || !neighbourAssData->hasDeterministicSameIndividualMerging()) {
							CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();
							if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_VALUE)) {
								neighbourPotentiallyInfluenced = true;
							}
							if (!neighbourPotentiallyInfluenced && !opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
								neighbourPotentiallyInfluenced = true;
							}
							if (!neighbourPotentiallyInfluenced && opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST | CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
								for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt && !neighbourPotentiallyInfluenced; opConLinkerIt = opConLinkerIt->getNext()) {
									CConcept* opConcept = opConLinkerIt->getData();
									bool opConceptNegation = opConLinkerIt->isNegated();
									bool opConceptTestingNegation = opConceptNegation;
									if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
										opConceptTestingNegation = !opConceptTestingNegation;
									}
									if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
										opConceptTestingNegation = !opConceptTestingNegation;
									}
									if (!mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighbourAssData, neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConceptTestingNegation, true, calcAlgContext)) {
										neighbourPotentiallyInfluenced = true;
									}
								}
							}
							if (!neighbourPotentiallyInfluenced && !opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
								neighbourPotentiallyInfluenced = true;
							}
						}

						if (neighbourPotentiallyInfluenced) {
							return true;
						}
					}
					return false;


				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::canExpandDirectlyInfluencedNeighbourWithPropagation(CIndividualProcessNode* indiNode, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CDependencyTrackPoint* backSyncDepTrackPoint, CConcept* concept, bool conNegation, bool nondeterministic, CBackendRepresentativeMemoryCacheIndividualAssociationData* assData, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData& neighbourExpansionData, cint64 neighbourIndiId, CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptOperator* conOperator = concept->getConceptOperator();

					if (isNeighbourExpansionWithPropagationAllowed(indiNode, concept, conNegation, neighbourIndiId, calcAlgContext)) {
						bool neighbourPotentiallyInfluenced = false;

						if (!neighbourAssData) {
							neighbourPotentiallyInfluenced = true;
						} else {
							CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();
							if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_VALUE)) {
								neighbourPotentiallyInfluenced = true;
							}
							if (!neighbourPotentiallyInfluenced && !opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
								neighbourPotentiallyInfluenced = true;
							}
							if (!neighbourPotentiallyInfluenced && opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST | CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
								for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt && !neighbourPotentiallyInfluenced; opConLinkerIt = opConLinkerIt->getNext()) {
									CConcept* opConcept = opConLinkerIt->getData();
									bool opConceptNegation = opConLinkerIt->isNegated();
									bool opConceptTestingNegation = opConceptNegation;
									if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
										opConceptTestingNegation = !opConceptTestingNegation;
									}
									if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
										opConceptTestingNegation = !opConceptTestingNegation;
									}
									if (!mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighbourAssData, neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConceptTestingNegation, true, calcAlgContext)
										|| nondeterministic && !mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighbourAssData, neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConceptTestingNegation, false, calcAlgContext)) {

										neighbourPotentiallyInfluenced = true;
									}
								}
							}
							if (!neighbourPotentiallyInfluenced && !opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
								neighbourPotentiallyInfluenced = true;
							}
						}

						if (neighbourPotentiallyInfluenced) {
							return true;
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheNewMergings(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {

					CIndividualMergingHash* mergingHash = indiNode->getIndividualMergingHash(false);
					bool hasNewMergedIndividuals = false;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);

					if (mergingHash) {
						if (backendSyncData->getLastMergedIndividualCount() != mergingHash->getMergedIndividualCount()) {
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
							locBackendSyncData->setLastMergedIndividualCount(mergingHash->getMergedIndividualCount());

							CXLinker<cint64>* mergedIndiLinker = mergingHash->getMergedIndividualLinker();
							CXLinker<cint64>* lastProcessedMergedIndiLinker = backendSyncData->getLastProcessedMergedIndividualLinker();

							CPROCESSSET<cint64>* mergedIntegratedIndividualSet = locBackendSyncData->getIntegratedMergedIndividualIdSet(true);

							visitIndividualsRelevantMergingsBackendSynchronisationDataIndividuals(indiNode, mergedIndiLinker, lastProcessedMergedIndiLinker, false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {

								if (locBackendSyncDataIndiNode != baseIndiNode) {
									if (!mergedIntegratedIndividualSet->contains(locBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID())) {
										mergedIntegratedIndividualSet->insert(locBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID());
										locBackendSyncDataIndiNode = getLocalizedIndividual(locBackendSyncDataIndiNode, false, calcAlgContext);

										CXLinker<CIndividualProcessNode*>* mergedIndiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
										mergedIndiNodeLinker->initLinker(locBackendSyncDataIndiNode);
										locBackendSyncData->addMergedIndividualNodeLinker(mergedIndiNodeLinker);
										hasNewMergedIndividuals = true;
									}
								}
								return true;
							}, calcAlgContext);

							locBackendSyncData->setLastProcessedMergedIndividualLinker(mergedIndiLinker);
						}
					}

					return hasNewMergedIndividuals;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheNominalIndirectConnectionBlockingCritical(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool nominalIndirectExpansionBlockingCritical = false;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);

					if (backendSyncData) {
						if (!backendSyncData->isCriticalIndirectConnectionIndividualExpansionBlocking() && assocData) {
							bool requiredIndirectConnectedIndividualExpansion = false;

							testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
							backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);


							bool indirectlyConnectedNominalIndividual = assocData && assocData->isIndirectlyConnectedNominalIndividual() || backendSyncData->hasMergedIndirectlyConnectedNominalIndividuals();

							if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastIndirectlyConnectedNominalIndividualsTestedMergedNodeLinker()) {
								CBackendRepresentativeMemoryLabelCacheItem* nondetSameIndiSetLabel = nullptr;
								if (assocData) {
									nondetSameIndiSetLabel = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL);
								}
								visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastIndirectlyConnectedNominalIndividualsTestedMergedNodeLinker(), false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {


									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
									CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = mergedBackendSyncData->getAssocitaionData();
									if (mergedAssocData->isIndirectlyConnectedNominalIndividual()) {
										indirectlyConnectedNominalIndividual = true;
									}


									if (!mBackendCacheHandler->hasIndividualIdsInAssociatedIndividualSetLabel(assocData, nondetSameIndiSetLabel, locBackendSyncDataIndiNode->getNominalIndividual()->getIndividualID())) {
										requiredIndirectConnectedIndividualExpansion = true;
										return false;
									}
									return true;
								}, calcAlgContext);
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setLastIndirectlyConnectedNominalIndividualsTestedMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
								if (indirectlyConnectedNominalIndividual) {
									locBackendSyncData->setMergedIndirectlyConnectedNominalIndividuals(true);
								}
							}


							if (indirectlyConnectedNominalIndividual && !requiredIndirectConnectedIndividualExpansion) {

								CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
								if (conSet) {
									CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
									CIndividualLinkEdge* lastAddedLinkEdge = indiNode->getLastAddedRoleLink();

									visitIndividualsRelevantBackendSynchronisationDataIndividuals(indiNode, false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {


										CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
										CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
										if (assocData && assocData->isIndirectlyConnectedNominalIndividual()) {
											CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(true);
											CConceptDescriptor* lastTestedConDes = backendSyncData->getLastIndirectConnectedIndividualExpansionTestedConceptDescriptor();

											CIndividualLinkEdge* lastTestedLinkEdge = backendSyncData->getLastIndirectConnectedIndividualExpansionTestedLinkEdge();
											if (lastAddedLinkEdge != lastTestedLinkEdge) {
												lastTestedConDes = nullptr;
											}

											if (assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL)->hasNondeterministicElements() || !testIndividualNodeBackendCacheConceptsSynchronization(indiNode, calcAlgContext)) {
												requiredIndirectConnectedIndividualExpansion = true;
											} else {
												for (CConceptDescriptor* conDesLinkerIt = conDesLinker; conDesLinkerIt && conDesLinkerIt != lastTestedConDes && !requiredIndirectConnectedIndividualExpansion; conDesLinkerIt = conDesLinkerIt->getNext()) {

													CConcept* concept = conDesLinkerIt->getConcept();
													bool conNegation = conDesLinkerIt->getNegation();
													CConceptOperator* conOperator = concept->getConceptOperator();
													CRole* role = concept->getRole();
													if (!conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST) || conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATLEAST)) {
														CRoleSuccessorLinkIterator roleSuccLinkIt = indiNode->getRoleSuccessorLinkIterator(role);
														while (roleSuccLinkIt.hasNext() && !requiredIndirectConnectedIndividualExpansion) {
															CIndividualLinkEdge* succLink = roleSuccLinkIt.next(true);
															CIndividualProcessNode* succIndiNode = getSuccessorIndividual(indiNode, succLink, calcAlgContext);
															if (succIndiNode->isNominalIndividualNode() && succIndiNode->getIndividualNominalLevelOrAncestorDepth() > 0 && !succIndiNode->getNominalIndividual()) {
																requiredIndirectConnectedIndividualExpansion = true;
															}
														}
													}
												}
											}

											locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
											backendSyncData->setLastIndirectConnectedIndividualExpansionTestedLinkEdge(lastAddedLinkEdge);
											backendSyncData->setLastIndirectConnectedIndividualExpansionTestedConceptDescriptor(conDesLinker);
										}
										return !requiredIndirectConnectedIndividualExpansion;
									}, calcAlgContext);

								}
							}
							if (indirectlyConnectedNominalIndividual && requiredIndirectConnectedIndividualExpansion) {
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setCriticalIndirectConnectionIndividualExpansionBlocking(true);
								nominalIndirectExpansionBlockingCritical = true;
							}

						} else {
							nominalIndirectExpansionBlockingCritical = true;
						}
					}

					return nominalIndirectExpansionBlockingCritical;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheSameMergedBlockingCritical(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {


					bool expansionBlockingCritical = false;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);

					if (backendSyncData) {

						testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
						backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);


						if (backendSyncData->getMergedIndividualNodeLinker()) {
							expansionBlockingCritical = true;
						} else {
							CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
							if (assocData && assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_SAME_INDIVIDUAL_SET_LABEL)) {
								expansionBlockingCritical = true;
							}
						}
					
					}

					return expansionBlockingCritical;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheNeighbourExpansionBlockingCritical(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {



					bool expansionBlockingCritical = false;

					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);

					if (backendSyncData) {
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						if (assocData && !backendSyncData->isCriticalNeighbourExpansionBlocking()) {


							//CConceptDescriptor* propConDesLinker = nullptr;


							//if (indiNode->getNominalIndividual() && CIRIName::getRecentIRIName(indiNode->getNominalIndividual()->getIndividualNameLinker()).startsWith("http://www.festo.com/edrive#HHM00")) {
							//	CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);

							//	CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
							//	CConceptDescriptor* conDesIt = conDesLinker;
							//	while (conDesIt) {
							//		CConcept* concept = conDesIt->getConcept();
							//		bool conNegation = conDesIt->getNegation();

							//		if (debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(concept, conNegation, indiNode, assocData, locBackendSyncData, calcAlgContext)) {
							//			bool debug = true;
							//			propConDesLinker = conDesIt;

							//			if (!testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(concept, conNegation, assocData, calcAlgContext)) {
							//				bool debug = true;
							//				debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(concept, conNegation, indiNode, assocData, locBackendSyncData, calcAlgContext);
							//				testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(concept, conNegation, assocData, calcAlgContext);
							//				debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(concept, conNegation, indiNode, assocData, locBackendSyncData, calcAlgContext);
							//				testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(concept, conNegation, assocData, calcAlgContext);
							//			}
							//			testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(concept, conNegation, assocData, calcAlgContext);

							//			conDesIt = nullptr;
							//		} else {
							//			conDesIt = conDesIt->getNext();
							//		}
							//	}
							//}


							testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
							backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);

							if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastCriticalNeighboursTestedMergedNodeLinker()) {
								visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastCriticalNeighboursTestedMergedNodeLinker(), false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {
									expansionBlockingCritical = true;
									return false;
								}, calcAlgContext);
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setLastCriticalNeighboursTestedMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
							}


							if (backendSyncData->getMergedIndividualNodeLinker()) {
								expansionBlockingCritical = true;
							} else {
								if (!testIndividualNodeBackendCacheConceptsSynchronization(indiNode, calcAlgContext)) {
									CConceptDescriptor* lastTestedConDes = backendSyncData->getLastCriticalNeighbourExpansionTestedConceptDescriptor();
									CConceptDescriptor* lastSynchedConDes = backendSyncData->getLastSynchedConceptDescriptor();
									if (!assocData->isCompletelyPropagated()) {
										lastSynchedConDes = nullptr;
									}
									CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
									if (conSet) {
										CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
										CConceptDescriptor* newLastTestedConDes = conDesLinker;
										if (conDesLinker != lastTestedConDes) {
											CConceptDescriptor* conDesIt = conDesLinker;

											bool conceptExpansionBlockingCritical = false;
											while (conDesIt && conDesIt != lastTestedConDes && conDesIt != lastSynchedConDes) {
												CConcept* concept = conDesIt->getConcept();
												bool conNegation = conDesIt->getNegation();

												//if (conDesIt == propConDesLinker) {
												//	bool debug = true;
												//}
												bool nondeterministic = hasNondeterministicDependency(conDesIt->getDependencyTrackPoint(), calcAlgContext);

												if (assocData && testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(concept, conNegation, nondeterministic, assocData, calcAlgContext)) {
													conceptExpansionBlockingCritical = true;
													newLastTestedConDes = conDesIt;
												}
												conDesIt = conDesIt->getNext();
											}
											locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
											if (conceptExpansionBlockingCritical && newLastTestedConDes) {
												newLastTestedConDes = newLastTestedConDes->getNext();
											}
											locBackendSyncData->setLastCriticalNeighbourExpansionTestedConceptDescriptor(newLastTestedConDes);
											if (conceptExpansionBlockingCritical) {
												expansionBlockingCritical = true;
											}

										}
									}
								}
							}

							if (expansionBlockingCritical) {
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setCriticalNeighbourExpansionBlocking(expansionBlockingCritical);
							} 
							/*else if (propConDesLinker) {
								bool debug = true;

								CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);

								CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
								CConceptDescriptor* conDesIt = conDesLinker;
								while (conDesIt) {
									CConcept* concept = conDesIt->getConcept();
									bool conNegation = conDesIt->getNegation();


									debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(concept, conNegation, indiNode, assocData, locBackendSyncData, calcAlgContext);
									conDesIt = conDesIt->getNext();
								}


							}*/


						} else {
							expansionBlockingCritical = true;
						}
					}

					return expansionBlockingCritical;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(CConcept* concept, bool conNegation, bool nondeterministic, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool expansionBlockingCritical = false;
					CConceptOperator* conOperator = concept->getConceptOperator();
					cint64 opCode = concept->getOperatorCode();
					CSortedNegLinker<CConcept*>* opConcepts = concept->getOperandList();
					if (mConfSpecializedAutomateRules && (opCode == CCAQAND || opCode == CCIMPLAQAND || opCode == CCBRANCHAQAND)) {
						while (opConcepts && !expansionBlockingCritical) {
							CConcept* opCon = opConcepts->getData();
							bool opConNeg = opConcepts->isNegated();
							expansionBlockingCritical |= testIndividualNodeConceptBackendCacheNeighbourExpansionBlockingCritical(opCon, opConNeg, nondeterministic, assocData, calcAlgContext);
							opConcepts = opConcepts->getNext();
						}
					} else if (!conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCF_ATMOST) || conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_SOME_TYPE | CConceptOperator::CCF_ATLEAST | CConceptOperator::CCF_VALUE)) {
						CRole* role = concept->getRole();
						if (assocData->isCompletelyPropagated()) {
							if (!mBackendCacheHandler || !mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), concept, conNegation, !nondeterministic, calcAlgContext)) {
								expansionBlockingCritical = true;
							}
						} else {
							if (!mBackendCacheHandler || mBackendCacheHandler->hasRoleInAssociatedCompinationRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false)
								|| mBackendCacheHandler->hasRoleInAssociatedCompinationRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false)) {
								expansionBlockingCritical = true;
							}
						}
					}												
					return expansionBlockingCritical;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(CConcept* concept, bool conNegation, CIndividualProcessNode* indiNode, CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool someNeighbourPotentiallyInfluenced = false;
					CConceptOperator* conOperator = concept->getConceptOperator();
					CRole* role = concept->getRole();

					cint64 opCode = concept->getOperatorCode();
					CSortedNegLinker<CConcept*>* opConcepts = concept->getOperandList();
					if (mConfSpecializedAutomateRules && (opCode == CCAQAND || opCode == CCIMPLAQAND || opCode == CCBRANCHAQAND)) {
						while (opConcepts) {
							CConcept* opCon = opConcepts->getData();
							bool opConNeg = opConcepts->isNegated();
							someNeighbourPotentiallyInfluenced |= debugCheckDirectlyInfluencedNeighbourWithPropagationPossible(opCon, opConNeg, indiNode, assocData, locBackendSyncData, calcAlgContext);
							opConcepts = opConcepts->getNext();
						}
					} else if (!conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCF_ATMOST) || conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_SOME_TYPE | CConceptOperator::CCF_ATLEAST)) {
						// TODO: verify cardinality is indeed critical
						if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST) ||
							mBackendCacheHandler->hasRoleInAssociatedCombinedNeigbourRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::DETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false) ||
							mBackendCacheHandler->hasRoleInAssociatedCombinedNeigbourRoleSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::NONDETERMINISTIC_COMBINED_NEIGHBOUR_INSTANTIATED_ROLE_SET_LABEL), role, false)) {


							if (role) {

								mBackendCacheHandler->visitNeighbourIndividualIdsForRole(assocData, role, [&](cint64 neighbourIndiId, CBackendRepresentativeMemoryLabelCacheItem* neighbourRoleSetLabel, bool nondeterministic)->bool {

									CPROCESSHASH< cint64, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationNeighbourExpansionData >* neighbourExpansionDataHash = locBackendSyncData->getNeighbourExpansionDataHash(true);
									bool neighbourPotentiallyInfluenced = false;
									CBackendRepresentativeMemoryCacheIndividualAssociationData* neighbourAssData = mBackendCacheHandler->getIndividualAssociationData(neighbourIndiId, calcAlgContext);
									if (!neighbourAssData) {
										neighbourPotentiallyInfluenced = true;
									} else {
										CSortedNegLinker<CConcept*>* opConLinker = concept->getOperandList();
										if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_VALUE)) {
											neighbourPotentiallyInfluenced = true;
										}
										if (!neighbourPotentiallyInfluenced && !opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
											neighbourPotentiallyInfluenced = true;
										}
										if (!neighbourPotentiallyInfluenced && opConLinker && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST | CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
											for (CSortedNegLinker<CConcept*>* opConLinkerIt = opConLinker; opConLinkerIt && !neighbourPotentiallyInfluenced; opConLinkerIt = opConLinkerIt->getNext()) {
												CConcept* opConcept = opConLinkerIt->getData();
												bool opConceptNegation = opConLinkerIt->isNegated();
												bool opConceptTestingNegation = opConceptNegation;
												if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCF_ATMOST | CConceptOperator::CCF_ATLEAST)) {
													opConceptTestingNegation = !opConceptTestingNegation;
												}
												if (conNegation && conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_ALL_AQALL_TYPE | CConceptOperator::CCFS_SOME_TYPE)) {
													opConceptTestingNegation = !opConceptTestingNegation;
												}
												if (!mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(neighbourAssData, neighbourAssData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), opConcept, opConceptTestingNegation, true, calcAlgContext)) {
													neighbourPotentiallyInfluenced = true;
												}
											}
										}
									}

									if (neighbourPotentiallyInfluenced) {
										someNeighbourPotentiallyInfluenced = true;
										return false;
									}
									return true;
								}, false, calcAlgContext);

							}
						}
					}

					return someNeighbourPotentiallyInfluenced;
				}




				bool CCalculationTableauCompletionTaskHandleAlgorithm::testIndividualNodeBackendCacheConceptsSynchronization(CIndividualProcessNode* indiNode, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool backendSynched = true;		


					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);
					CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* locBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(true);

					if (backendSyncData && backendSyncData->isBackendCacheSynchron()) {

						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();

						if (!assocData || !assocData->isCompletelyHandled()) {
							backendSynched = false;
						} else {

							CBackendRepresentativeMemoryLabelCacheItem* conceptLabelItem = assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL);
							testIndividualNodeBackendCacheNewMergings(indiNode, calcAlgContext);
							backendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)indiNode->getIndividualBackendCacheSynchronisationData(false);

							if (backendSyncData->getMergedIndividualNodeLinker() != backendSyncData->getLastSynchronizedConceptsTestedMergedNodeLinker()) {

								visitNewlyMergedOnlyDeterministicRepresentativeIndividualsBackendSynchronisationData(indiNode, backendSyncData->getMergedIndividualNodeLinker(), backendSyncData->getLastSynchronizedConceptsTestedMergedNodeLinker(), false, [&](CIndividualProcessNode* baseIndiNode, CIndividualProcessNode* locBackendSyncDataIndiNode, CDependencyTrackPoint* backSyncDepTrackPoint)->bool {

									CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* mergedBackendSyncData = (CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData*)locBackendSyncDataIndiNode->getIndividualBackendCacheSynchronisationData(false);
									CBackendRepresentativeMemoryCacheIndividualAssociationData* mergedAssocData = mergedBackendSyncData->getAssocitaionData();
									if (mergedAssocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL) != conceptLabelItem) {
										backendSynched = false;
									}

									return false;
								}, calcAlgContext);
								locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
								locBackendSyncData->setLastSynchronizedConceptsTestedMergedNodeLinker(backendSyncData->getMergedIndividualNodeLinker());
							}


							CConceptDescriptor* lastTestedConDes = backendSyncData->getLastSynchronizationTestedConceptDescriptor();
							CReapplyConceptLabelSet* conSet = indiNode->getReapplyConceptLabelSet(false);
							if (conSet && backendSynched) {
								CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
								if (conDesLinker != lastTestedConDes) {
									CConceptDescriptor* conDesIt = conDesLinker;
									CConceptDescriptor* lastSyncConDes = lastTestedConDes;
									CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();

									CConcept* nominalConcept = indiNode->getNominalIndividual()->getIndividualNominalConcept();
									while (conDesIt && conDesIt != lastTestedConDes && conDesIt) {
										if (conDesIt->getConcept() != nominalConcept || conDesIt->isNegated()) {
											bool nondeterministic = hasNondeterministicDependency(conDesIt->getDependencyTrackPoint(), calcAlgContext);
											if (!mBackendCacheHandler || !mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(assocData, conceptLabelItem, conDesIt->getConcept(), conDesIt->isNegated(), !nondeterministic, calcAlgContext)) {
												backendSynched = false;
												lastSyncConDes = conDesIt;
											}
										}
										conDesIt = conDesIt->getNext();
									}
									if (!backendSynched && lastSyncConDes) {
										lastSyncConDes = lastSyncConDes->getNext();
									}
									locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
									locBackendSyncData->setLastSynchronizationTestedConceptDescriptor(conDesLinker);
									locBackendSyncData->setLastSynchedConceptDescriptor(lastSyncConDes);
								}
							} else {
								backendSynched = false;
							}
						}

						if (!backendSynched) {
							locBackendSyncData = getLocalizedIndividualBackendCacheSnychronisationData(indiNode, calcAlgContext);
							locBackendSyncData->setBackendCacheSynchron(backendSynched);
						}

					} else {
						backendSynched = false;
					}
					return backendSynched;

					return backendSynched;
				}





				bool CCalculationTableauCompletionTaskHandleAlgorithm::validateBackendSynchronisationContinued(CIndividualProcessNode* indi, CIndividualNodeRepresentativeMemoryBackendCacheSynchronisationData* backendSyncData, CConcept* addedConcept, bool addedConceptNegation, CCalculationAlgorithmContextBase* calcAlgContext) {
					bool backendSynched = true;			

					if (backendSyncData && backendSyncData->isBackendCacheSynchron()) {
						CConceptDescriptor* lastTestedConDes = backendSyncData->getLastSynchronizationTestedConceptDescriptor();
						CReapplyConceptLabelSet* conSet = indi->getReapplyConceptLabelSet(false);
						CBackendRepresentativeMemoryCacheIndividualAssociationData* assocData = backendSyncData->getAssocitaionData();
						if (conSet && assocData) {
							CConceptDescriptor* conDesLinker = conSet->getAddingSortedConceptDescriptionLinker();
							CConceptDescriptor* conDesIt = conDesLinker;

							if (addedConcept && conDesIt != lastTestedConDes) {
								if (conDesIt->getConcept() == addedConcept || conDesIt->isNegated() == addedConceptNegation) {
									conDesIt = conDesIt->getNext();
								}
							}
							CConcept* nominalConcept = indi->getNominalIndividual()->getIndividualNominalConcept();
							while (conDesIt != lastTestedConDes && backendSynched && conDesIt) {
								if (conDesIt->getConcept() != nominalConcept || conDesIt->isNegated()) {
									bool nondeterministic = hasNondeterministicDependency(conDesIt->getDependencyTrackPoint(), calcAlgContext);
									if (!mBackendCacheHandler || !mBackendCacheHandler->hasConceptInAssociatedFullConceptSetLabel(assocData, assocData->getLabelCacheEntry(CBackendRepresentativeMemoryLabelCacheItem::FULL_CONCEPT_SET_LABEL), conDesIt->getConcept(),conDesIt->isNegated(), !nondeterministic, calcAlgContext)) {
										backendSynched = false;
									}
								}
								if (backendSynched) {
									backendSyncData->setLastSynchedConceptDescriptor(conDesIt);
								}
								conDesIt = conDesIt->getNext();
							}
							backendSyncData->setLastSynchronizationTestedConceptDescriptor(conDesLinker);
						} else {
							backendSynched = false;
						}

						backendSyncData->setBackendCacheSynchron(backendSynched);
					} else {
						backendSynched = false;
					}
					return backendSynched;
				}




				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedIndividual(cint64 indiID, CCalculationAlgorithmContextBase* calcAlgContext) {
					return getLocalizedIndividual(getUpToDateIndividual(indiID,calcAlgContext),false,calcAlgContext);
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedIndividual(CIndividualProcessNode* indi, bool updateIndividual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!indi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
						if (updateIndividual) {
							indi = getUpToDateIndividual(indi,calcAlgContext);
						}
						if (!indi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
							STATINC(INDINODELOCALIZEDLOADCOUNT,calcAlgContext);
							CMemoryAllocationManager* taskMemMan = nullptr;
							taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
							CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
							CIndividualProcessNode* localicedIndi = CObjectParameterizingAllocator< CIndividualProcessNode,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
							localicedIndi->initIndividualProcessNode(indi);
							indiProcNodeVec->setLocalData(localicedIndi->getIndividualNodeID(),localicedIndi);

							if (calcAlgContext->hasCompletionGraphCachedIndividualNodes() && mConfCompletionGraphCaching) {
								if (localicedIndi->getIndividualNodeID() <= calcAlgContext->getMaxCompletionGraphCachedIndividualNodeID()) {
									if (indi->getLocalizationTag() <= calcAlgContext->getCompletionGraphCachedLocalizationTag()) {
										trackIndividualReferredDependence(indi->getIndividualNodeID(),calcAlgContext);
										localicedIndi->clearProcessingQueued();
										localicedIndi->clearProcessingRestrictionFlags(CIndividualProcessNode::PRFCACHEDCOMPUTEDTYPESADDED);
										localicedIndi->addProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED);
									}
								}
							}
							return localicedIndi;
						}
					}
					return indi;
				}

				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getSuccessorIndividual(CIndividualProcessNode*& indi, CIndividualLinkEdge* link, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* succIndi = nullptr;
					
					if (link->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
						succIndi = link->getOppositeIndividual(indi);
					} else {
						STATINC(INDINODEUPDATELOADCOUNT,calcAlgContext);
						succIndi = link->getOppositeIndividual(indi);
						if (!succIndi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag()) && succIndi->isRelocalized()) {
							cint64 succIndiId = link->getOppositeIndividualID(indi);
							CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
							succIndi = indiProcNodeVec->getData(succIndiId);
						}
					}
					return succIndi;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getLocalizedSuccessorIndividual(CIndividualProcessNode*& indi, CIndividualLinkEdge* link, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* succIndi = nullptr;

					if (link->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
						succIndi = link->getOppositeIndividual(indi);
					} else {
						STATINC(INDINODEUPDATELOADCOUNT,calcAlgContext);
						cint64 succIndiId = link->getOppositeIndividualID(indi);
						CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
						succIndi = indiProcNodeVec->getData(succIndiId);
						succIndi = getLocalizedIndividual(succIndi,false,calcAlgContext);
					}
					return succIndi;
				}


				CIndividualProcessNode* CCalculationTableauCompletionTaskHandleAlgorithm::getAncestorIndividual(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualProcessNode* ancIndi = nullptr;

					CIndividualLinkEdge* ancLink = indi->getAncestorLink();
					if (ancLink) {
						ancIndi = getSuccessorIndividual(indi,ancLink,calcAlgContext);
					}
					return ancIndi;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyExtendedReapplyConceptDescriptor(CIndividualProcessNode*& processIndi, CConcept* concept, bool negation, CCondensedReapplyConceptDescriptor* reapplyConceptDes, CCalculationAlgorithmContextBase* calcAlgContext) {					
					CExtendedCondensedReapplyConceptDescriptor* extendedReapplyConceptDes = (CExtendedCondensedReapplyConceptDescriptor*)reapplyConceptDes;
					if (extendedReapplyConceptDes->getExtentionType() == REAPPLYCONCEPTDESCRIPTOREXTENSIONTYPEATMOST) {
						CExtendedCondensedReapplyConceptDescriptorATMOSTReactivation* atmostReapplyConDes = (CExtendedCondensedReapplyConceptDescriptorATMOSTReactivation*)extendedReapplyConceptDes;
						CIndividualProcessNode* reapplicationIndiNode = atmostReapplyConDes->getReapplicationIndividualNode();
						CIndividualLinkEdge* indiLinkEdge = atmostReapplyConDes->getIndividualLink();
						CIndividualProcessNode* locReapplicationIndiNode = getLocalizedIndividual(reapplicationIndiNode,true,calcAlgContext);

						if (!locReapplicationIndiNode->hasProcessingRestrictionFlags(CIndividualProcessNode::PRFPURGEDBLOCKED)) {

							CSuccessorIndividualATMOSTReactivationData* succIndiATMOSTReactivationData = locReapplicationIndiNode->getSuccessorIndividualATMOSTReactivationData(true);
							CConceptDescriptor* atmostConDes = atmostReapplyConDes->getConceptDescriptor();
							succIndiATMOSTReactivationData->addReactivationSuccessorIndividualLink(atmostConDes,indiLinkEdge);

							CRole* role = atmostConDes->getConcept()->getRole();
							CReapplyQueueIterator roleReapplyQueueIt = locReapplicationIndiNode->getRoleReapplyIterator(role,false);
							bool roleQueueReapplied = false;
							while (roleReapplyQueueIt.hasNext() && !roleQueueReapplied) {
								CReapplyConceptDescriptor* roleReapplyConceptDes = roleReapplyQueueIt.next();
								if (roleReapplyConceptDes->getConceptDescriptor() == atmostConDes) {
									applyReapplyQueueConcepts(locReapplicationIndiNode,role,calcAlgContext);
									roleQueueReapplied = true;
								}
							}
						}

					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::applyReapplyQueueConcepts(CIndividualProcessNode*& processIndi, CConcept* concept, bool negation, CCalculationAlgorithmContextBase* calcAlgContext) {					
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CCondensedReapplyQueueIterator reapplyQueueIt = processIndi->getConceptReapplyIterator(concept,negation,true);
					CConceptProcessingQueue* conProQueue = nullptr;
					CProcessingRestrictionSpecification* procRest = nullptr;
					while (reapplyQueueIt.hasNext()) {
						STATINC(REAPPLIEDCONCEPTSCOUNT,calcAlgContext);
						CCondensedReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt.next();
						CConceptDescriptor* conDes = reapplyConceptDes->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = reapplyConceptDes->getDependencyTrackPoint();
						procRest = reapplyConceptDes->getReapplyProcessingRestriction();
						if (reapplyConceptDes->isExtended()) {
							applyExtendedReapplyConceptDescriptor(processIndi,concept,negation,reapplyConceptDes,calcAlgContext);
						} else {
							if (!conProQueue) {
								conProQueue = processIndi->getConceptProcessingQueue(true);
							}
							addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,reapplyConceptDes->isStaticDescriptor(),procRest,calcAlgContext);
						}
					}
					if (conProQueue) {
						addIndividualToProcessingQueue(processIndi,calcAlgContext);
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::applyReapplyQueueConcepts(CIndividualProcessNode*& processIndi, CRole* role, CCalculationAlgorithmContextBase* calcAlgContext) {					
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CReapplyQueueIterator reapplyQueueIt = processIndi->getRoleReapplyIterator(role,true);
					CConceptProcessingQueue* conProQueue = nullptr;
					CProcessingRestrictionSpecification* procRest = nullptr;
					while (reapplyQueueIt.hasNext()) {
						STATINC(REAPPLIEDCONCEPTSCOUNT,calcAlgContext);
						CReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt.next();
						CConceptDescriptor* conDes = reapplyConceptDes->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = reapplyConceptDes->getDependencyTrackPoint();
						procRest = reapplyConceptDes->getReapplyProcessingRestriction();
						if (!conProQueue) {
							conProQueue = processIndi->getConceptProcessingQueue(true);
						}
						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,reapplyConceptDes->isStaticDescriptor(),procRest,calcAlgContext);
					}
					if (conProQueue) {
						addIndividualToProcessingQueue(processIndi,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyReapplyQueueConceptsRestricted(CIndividualProcessNode*& processIndi, CReapplyQueueIterator* reapplyQueueIt, CIndividualLinkEdge* restrictedLink, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = nullptr;
					CLinkProcessingRestrictionSpecification* linkProcRest = nullptr;
					CProcessingRestrictionSpecification* procRest = nullptr;
					while (reapplyQueueIt->hasNext()) {
						STATINC(REAPPLIEDCONCEPTSCOUNT,calcAlgContext);
						CReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt->next();
						CConceptDescriptor* conDes = reapplyConceptDes->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = reapplyConceptDes->getDependencyTrackPoint();
						procRest = reapplyConceptDes->getReapplyProcessingRestriction();
						if (!conProQueue) {
							conProQueue = processIndi->getConceptProcessingQueue(true);
						}
						if (!procRest) {
							if (!linkProcRest) {
								linkProcRest = CObjectAllocator< CLinkProcessingRestrictionSpecification >::allocateAndConstruct(taskMemMan);
								linkProcRest->initLinkRestriction(restrictedLink);
							}
							procRest = linkProcRest;
						}
						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,reapplyConceptDes->isStaticDescriptor(),procRest,calcAlgContext);
					}
					if (conProQueue) {
						addIndividualToProcessingQueue(processIndi,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::applyReapplyQueueConcepts(CIndividualProcessNode*& processIndi, CCondensedReapplyQueueIterator* reapplyQueueIt, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = nullptr;
					CProcessingRestrictionSpecification* procRest = nullptr;
					while (reapplyQueueIt->hasNext()) {
						STATINC(REAPPLIEDCONCEPTSCOUNT,calcAlgContext);
						CReapplyConceptDescriptor* reapplyConceptDes = reapplyQueueIt->next();
						CConceptDescriptor* conDes = reapplyConceptDes->getConceptDescriptor();
						CDependencyTrackPoint* depTrackPoint = reapplyConceptDes->getDependencyTrackPoint();
						procRest = reapplyConceptDes->getReapplyProcessingRestriction();
						if (!conProQueue) {
							conProQueue = processIndi->getConceptProcessingQueue(true);
						}
						addConceptRestrictedToProcessingQueue(conDes,depTrackPoint,conProQueue,processIndi,reapplyConceptDes->isStaticDescriptor(),procRest,calcAlgContext);
					}
					if (conProQueue) {
						addIndividualToProcessingQueue(processIndi,calcAlgContext);
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToReapplyQueue(CConceptDescriptor *conceptDescriptor, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConcept* concept = conceptDescriptor->getConcept();
					CRole* role = concept->getRole();
					return addConceptToReapplyQueue(conceptDescriptor,role,processIndi,true,dependencyTrackPoint,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToReapplyQueue(CConceptDescriptor *conceptDescriptor, CRole* role, CIndividualProcessNode*& processIndi, bool isStaticDes, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					STATINC(INSERTCONCEPTREAPPLICATIONSCOUNT,calcAlgContext);
					CReapplyQueue* reapplyQueue = processIndi->getRoleReapplyQueue(role,true);
					CReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint,isStaticDes);
					reapplyQueue->addReapplyConceptDescriptor(reapplyConDes);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToReapplyQueue(CConceptDescriptor *conceptDescriptor, CConcept* concept, bool negation, CIndividualProcessNode*& processIndi, bool isStaticDes, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					STATINC(INSERTCONCEPTREAPPLICATIONSCOUNT,calcAlgContext);
					CCondensedReapplyQueue* reapplyQueue = processIndi->getConceptReapplyQueue(concept,negation,true);
					CCondensedReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CCondensedReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint,!negation);
					reapplyQueue->addReapplyConceptDescriptor(reapplyConDes);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToReapplyQueue(CConceptDescriptor *conceptDescriptor, CRole* role, CIndividualProcessNode*& processIndi, CProcessingRestrictionSpecification* procRest, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					STATINC(INSERTCONCEPTREAPPLICATIONSCOUNT,calcAlgContext);
					CReapplyQueue* reapplyQueue = processIndi->getRoleReapplyQueue(role,true);
					CReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint,procRest);
					reapplyQueue->addReapplyConceptDescriptor(reapplyConDes);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToReapplyQueue(CConceptDescriptor *conceptDescriptor, CConcept* concept, bool negation, CIndividualProcessNode*& processIndi, CProcessingRestrictionSpecification* procRest, CDependencyTrackPoint* dependencyTrackPoint, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					STATINC(INSERTCONCEPTREAPPLICATIONSCOUNT,calcAlgContext);
					CCondensedReapplyQueue* reapplyQueue = processIndi->getConceptReapplyQueue(concept,negation,true);
					CCondensedReapplyConceptDescriptor* reapplyConDes = CObjectAllocator<CCondensedReapplyConceptDescriptor>::allocateAndConstruct(taskMemMan);
					reapplyConDes->initReapllyDescriptor(conceptDescriptor,dependencyTrackPoint,!negation,procRest);
					reapplyQueue->addReapplyConceptDescriptor(reapplyConDes);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptInReapplyQueue(CConceptDescriptor* conceptDescriptor, CConcept* concept, bool negation, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CCondensedReapplyQueue* reapplyQueue = processIndi->getConceptReapplyQueue(concept,negation,false);
					if (reapplyQueue) {
						return reapplyQueue->hasConceptDescriptor(conceptDescriptor);
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptInReapplyQueue(CConceptDescriptor* conceptDescriptor, CRole* role, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CReapplyQueue* reapplyQueue = processIndi->getRoleReapplyQueue(role,false);
					if (reapplyQueue) {
						return reapplyQueue->hasConceptDescriptor(conceptDescriptor);
					}
					return false;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToIndividualSkipANDProcessing(CConcept* addingConcept, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, bool markModification, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");
					KONCLUDE_ASSERT_X(addingConcept,"adding concept to individual","concept missing");

					CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
					conceptDescriptor->initConceptDescriptor(addingConcept,negate,dependencyTrackPoint);
					CCondensedReapplyQueueIterator reapplyIt;
					bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
					if (!contained) {
						++mStatConDesInsertionCount;
						STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
						addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
						if (markModification) {
							setIndividualNodeConceptLabelSetModified(processIndi, calcAlgContext);
						}
						addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext,&CCalculationTableauCompletionTaskHandleAlgorithm::applyANDRule);
						if (reapplyIt.hasNext()) {
							// reapply reapplying concept
							applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
						}
					} else {
						++mStatConDesContainedCount;
						releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToIndividual(CConcept* addingConcept, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");
					KONCLUDE_ASSERT_X(addingConcept,"adding concept to individual","concept missing");

					CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
					conceptDescriptor->initConceptDescriptor(addingConcept,negate,dependencyTrackPoint);
					CCondensedReapplyQueueIterator reapplyIt;
					bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
					if (!contained) {
						STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
						++mStatConDesInsertionCount;
						addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
						setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
						addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
						if (reapplyIt.hasNext()) {
							// reapply reapplying concept
							applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
						}
					} else {
						++mStatConDesContainedCount;
						releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
					}
				}



				CConceptDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToIndividualReturnConceptDescriptor(CConcept* addingConcept, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");
					KONCLUDE_ASSERT_X(addingConcept,"adding concept to individual","concept missing");

					CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
					conceptDescriptor->initConceptDescriptor(addingConcept,negate,dependencyTrackPoint);
					CCondensedReapplyQueueIterator reapplyIt;
					insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
					++mStatConDesInsertionCount;

					STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
					addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
					setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
					addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
					if (reapplyIt.hasNext()) {
						// reapply reapplying concept
						applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
					}
					return conceptDescriptor;
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::setIndividualNodeAncestorConnectionModified(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					propagateIndividualNodeModified(indi,calcAlgContext);
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::setIndividualNodeConceptLabelSetModified(CIndividualProcessNode*& indi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessTagger* processTagger = calcAlgContext->getUsedProcessTagger();
					processTagger->incConceptLabelSetModificationTag();
					indi->getReapplyConceptLabelSet(true)->updateConceptLabelSetModificationTag(processTagger);
					calcAlgContext->setMinModificationIndividualCandidate(indi);
					propagateIndividualNodeModified(indi,calcAlgContext);
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isIndividualNodeConceptLabelSetModified(CIndividualProcessNode*& indi, cint64 modTag, CCalculationAlgorithmContextBase* calcAlgContext) {
					return indi->getReapplyConceptLabelSet(false)->isConceptLabelSetModificationTagUpToDate(modTag);
				}






				CConceptDescriptor* CCalculationTableauCompletionTaskHandleAlgorithm::createConceptDescriptor(CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
					CConceptDescriptor* conDes = processingDataBox->takeRemainingConceptDescriptor();
					if (!conDes) {
						CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
						conDes = CObjectAllocator<CConceptDescriptor>::allocateAndConstruct(taskMemMan);
					}
					return conDes;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::releaseConceptDescriptor(CConceptDescriptor* conDes, CCalculationAlgorithmContextBase* calcAlgContext) {
					conDes->clearNext();
					CProcessingDataBox* processingDataBox = calcAlgContext->getUsedProcessingDataBox();
					processingDataBox->addRemainingConceptDescriptor(conDes);
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptsToIndividual(CSortedNegLinker<CConcept*>* conceptAddLinkerIt, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, cint64* conceptCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");

					cint64 conCount = 0;
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);
					while (conceptAddLinkerIt) {
						CConcept* concept = conceptAddLinkerIt->getData();
						bool conNeg = conceptAddLinkerIt->isNegated()^negate;


						KONCLUDE_ASSERT_X(concept,"adding concept to individual","concept missing");

						CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
						conceptDescriptor->initConceptDescriptor(concept,conNeg,dependencyTrackPoint);
						CCondensedReapplyQueueIterator reapplyIt;
						bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
						if (!contained) {
							++mStatConDesInsertionCount;
							STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
							addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
							if (reapplyIt.hasNext()) {
								// reapply reapplying concept
								applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
							}
						} else {
							++mStatConDesContainedCount;
							releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
						}
						++conCount;
						conceptAddLinkerIt = conceptAddLinkerIt->getNext();
					}
					if (conceptCount) {
						*conceptCount = conCount;
					}
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addBlockingCoreConcept(CConceptDescriptor* conceptDescriptor, CIndividualProcessNode*& processIndi, CReapplyConceptLabelSet* conLabelSet, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (mConfSaveCoreBlockingConceptsCandidates) {
						CConceptData* conData = conceptDescriptor->getConcept()->getConceptData();
						if (conData) {
							CConceptProcessData* conProData = (CConceptProcessData*)conData;
							if (conProData->isCoreBlockingConcept(conceptDescriptor->isNegated())) {

								if (!processIndi->isNominalIndividualNode()) {
									STATINC(CORECONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
									CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
									CCoreConceptDescriptor* coreConceptDescriptor = CObjectAllocator<CCoreConceptDescriptor>::allocateAndConstruct(taskMemMan);
									coreConceptDescriptor->initCoreConceptDescriptor(conceptDescriptor);
									conLabelSet->addCoreConceptDescriptor(coreConceptDescriptor);

									CProcessingDataBox* procDataBox = calcAlgContext->getUsedProcessingDataBox();
									CBlockingIndividualNodeLinkedCandidateHash* blockingCandHash = procDataBox->getBlockingIndividualNodeLinkedCandidateHash(true);
									CBlockingIndividualNodeLinkedCandidateData* blockingCandData = blockingCandHash->getBlockingIndividualCandidateData(conceptDescriptor,true);
									blockingCandData->addBlockingCandidateIndividualNode(processIndi);
								}

								return true;
							}
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::isConceptUnsatisfiabilitySaturated(CConcept* concept, bool negation, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptData* conceptData = concept->getConceptData();
					CIndividualSaturationProcessNode* saturationIndiNode = nullptr;
					if (conceptData) {
						CConceptProcessData* conProcData = (CConceptProcessData*)conceptData;
						CConceptReferenceLinking* conRefLinking = conProcData->getConceptReferenceLinking();
						if (conRefLinking) {
							CConceptSaturationReferenceLinkingData* confSatRefLinkingData = (CConceptSaturationReferenceLinkingData*)conRefLinking;
							CSaturationConceptReferenceLinking* satCalcRefLinkData = confSatRefLinkingData->getConceptSaturationReferenceLinkingData(negation);
							if (satCalcRefLinkData) {
								saturationIndiNode = (CIndividualSaturationProcessNode*)satCalcRefLinkData->getIndividualProcessNodeForConcept();
							}
						}
					}

					if (saturationIndiNode) {
						if (saturationIndiNode->getIndirectStatusFlags()->hasClashedFlag()) {
							return true;
						}
					}
					return false;
				}



				bool CCalculationTableauCompletionTaskHandleAlgorithm::insertConceptsToIndividualConceptSet(CConceptDescriptor* conceptDescriptor, CDependencyTrackPoint* dependencyTrackPoint, CIndividualProcessNode*& processIndi, CReapplyConceptLabelSet* conLabelSet, CCondensedReapplyQueueIterator* reapplyIt, bool allowInitalization, CCalculationAlgorithmContextBase* calcAlgContext) {
					CConceptDescriptor* clashedConceptDescriptor = nullptr;
					CDependencyTrackPoint* clashedDependencyTrackPoint = nullptr;

					if (mConfConceptUnsatisfiabilitySaturatedTesting) {
						if (isConceptUnsatisfiabilitySaturated(conceptDescriptor->getConcept(),conceptDescriptor->isNegated(),calcAlgContext)) {
							CClashedDependencyDescriptor* clashConDesLinker = nullptr;
							clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conceptDescriptor,dependencyTrackPoint,calcAlgContext);
							throw CCalculationClashProcessingException(clashConDesLinker);
						}
					}


					bool contained = conLabelSet->insertConceptGetClash(conceptDescriptor,dependencyTrackPoint,reapplyIt,&clashedConceptDescriptor,&clashedDependencyTrackPoint);
					if (!contained) {
						if (allowInitalization) {
							if (!processIndi->getIndividualInitializationConcept()) {
								processIndi->setIndividualInitializationConcept(conceptDescriptor);
							}
						}
						bool nondeterministically = hasNondeterministicDependency(dependencyTrackPoint, calcAlgContext);
						if (conceptDescriptor->getConcept()->getOperatorCode() == CCMARKER) {
							calcAlgContext->getProcessingDataBox()->getMarkerIndividualNodeHash(true)->addMarkerIndividualNode(conceptDescriptor->getConcept(),processIndi,nondeterministically);
						}

						if (mConfOccurrenceStatisticsCollecting && mOptCollectOccurrenceStatistics) {
							mOccStatsCacheHandler->incConceptInstanceOccurrencceStatistics(conceptDescriptor->getConcept(), nondeterministically, processIndi->getNominalIndividual() == nullptr);
						}
					}
					if (contained && clashedConceptDescriptor) {

						//mClashedDebugIndiModelString = generateDebugIndiModelStringList(calcAlgContext);

						//QFile file = QString("model.txt");
						//if (file.open(QIODevice::WriteOnly)) {
						//	file.write(mClashedDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
						//	file.close();
						//}

						CClashedDependencyDescriptor* clashConDesLinker = nullptr;
						clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,clashedConceptDescriptor,clashedDependencyTrackPoint,calcAlgContext);
						clashConDesLinker = createClashedConceptDescriptor(clashConDesLinker,processIndi,conceptDescriptor,dependencyTrackPoint,calcAlgContext);


						//mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
						//mEndTaskDebugIndiModelString = writeGeneratedExtendedDebugIndiModelStringList("./Debugging/CompletionTasks/concept-clash.txt", calcAlgContext);
						//mBackendCacheHandler->getCache()->writeStringifiedRepresentativeCacheToFile();


						throw CCalculationClashProcessingException(clashConDesLinker);
					}



					//CConceptDescriptor* conDes = processIndi->getReapplyConceptLabelSet(false)->getAddingSortedConceptDescriptionLinker();
					//bool amountSubstanceFound = false;
					//for (CConceptDescriptor* conDesIt = conDes; conDesIt; conDesIt = conDesIt->getNext()) {
					//	CConcept* concept = conDesIt->getConcept();
					//	if (concept->getOperatorCode() == CCIMPLALL) {
					//		if (CIRIName::getRecentIRIName(concept->getRole()->getPropertyNameLinker()) == "http://purl.org/biotop/biotop.owl#granularPartOf") {
					//			CConcept* orCocnept = concept->getOperandList()->getData();
					//			if (orCocnept->getOperatorCode() == CCOR) {
					//				for (CSortedNegLinker<CConcept*>* opLinker = orCocnept->getOperandList(); opLinker; opLinker = opLinker->getNext()) {
					//					if (opLinker->getData()->getOperatorCode() == CCSUB && CIRIName::getRecentIRIName(opLinker->getData()->getClassNameLinker()) == "http://purl.org/imbi/dco/dco#AmountOfSubstance") {
					//						amountSubstanceFound = true;
					//					}
					//				}
					//			}
					//		}
					//	}
					//}
					//if (amountSubstanceFound) {
					//	bool base1Con = false;
					//	bool base2Con = false;
					//	for (CConceptDescriptor* conDesIt = conDes; conDesIt; conDesIt = conDesIt->getNext()) {
					//		if (CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://purl.org/biotop/biotop.owl#Atom") {
					//			base1Con = true;
					//		}
					//		if (CIRIName::getRecentIRIName(conDesIt->getData()->getClassNameLinker()) == "http://purl.org/biotop/biotop.owl#MonoMolecularEntity") {
					//			base2Con = true;
					//		}
					//	}
					//	if (!base2Con && !base1Con) {
					//		mEndTaskDebugIndiModelString = generateExtendedDebugIndiModelStringList(calcAlgContext);
					//		QFile file(QString("caching-error.txt"));
					//		if (file.open(QIODevice::WriteOnly)) {
					//			file.write(mEndTaskDebugIndiModelString.replace("<br>","\r\n").toLocal8Bit());
					//			file.close();
					//		}
					//		bool bug = true;
					//	}
					//}


					return contained;
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptsToIndividual(CConceptAssertionLinker* conceptAddLinkerIt, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, cint64* conceptCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");

					cint64 conCount = 0;
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);
					while (conceptAddLinkerIt) {
						CConcept* concept = conceptAddLinkerIt->getData();
						bool conNeg = conceptAddLinkerIt->isNegated()^negate;
						KONCLUDE_ASSERT_X(concept,"adding concept to individual","concept missing");


						CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
						conceptDescriptor->initConceptDescriptor(concept,conNeg,dependencyTrackPoint);
						CCondensedReapplyQueueIterator reapplyIt;
						bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
						if (!contained) {
							++mStatConDesInsertionCount;
							STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
							addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
							if (reapplyIt.hasNext()) {
								// reapply reapplying concept
								applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
							}
						} else {
							++mStatConDesContainedCount;
							releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
						}
						conceptAddLinkerIt = conceptAddLinkerIt->getNext();
					}
					if (conceptCount) {
						*conceptCount = conCount;
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptsToIndividual(CXNegLinker<CConcept*>* conceptAddLinkerIt, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, cint64* conceptCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");

					cint64 conCount = 0;
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);
					while (conceptAddLinkerIt) {
						CConcept* concept = conceptAddLinkerIt->getData();
						bool conNeg = conceptAddLinkerIt->isNegated()^negate;
						KONCLUDE_ASSERT_X(concept,"adding concept to individual","concept missing");


						CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
						conceptDescriptor->initConceptDescriptor(concept,conNeg,dependencyTrackPoint);
						CCondensedReapplyQueueIterator reapplyIt;
						bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
						if (!contained) {
							++mStatConDesInsertionCount;
							STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
							addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
							if (reapplyIt.hasNext()) {
								// reapply reapplying concept
								applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
							}
						} else {
							++mStatConDesContainedCount;
							releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
						}
						conceptAddLinkerIt = conceptAddLinkerIt->getNext();
					}
					if (conceptCount) {
						*conceptCount = conCount;
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptsToIndividual(CXSortedNegLinker<CConcept*>* conceptAddLinkerIt, bool negate, CIndividualProcessNode*& processIndi, CDependencyTrackPoint* dependencyTrackPoint, bool allowPreprocessing, bool allowInitalization, cint64* conceptCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					CConceptProcessingQueue* conProQueue = processIndi->getConceptProcessingQueue(true);

					KONCLUDE_ASSERT_X(dependencyTrackPoint,"adding concept to individual","dependency track point missing");

					cint64 conCount = 0;
					CReapplyConceptLabelSet* conLabelSet = processIndi->getReapplyConceptLabelSet(true);
					while (conceptAddLinkerIt) {
						CConcept* concept = conceptAddLinkerIt->getData();
						KONCLUDE_ASSERT_X(concept,"adding concept to individual","concept missing");
						bool conNeg = conceptAddLinkerIt->isNegated()^negate;


						CConceptDescriptor* conceptDescriptor = createConceptDescriptor(calcAlgContext);
						conceptDescriptor->initConceptDescriptor(concept,conNeg,dependencyTrackPoint);
						CCondensedReapplyQueueIterator reapplyIt;
						bool contained = insertConceptsToIndividualConceptSet(conceptDescriptor,dependencyTrackPoint,processIndi,conLabelSet,&reapplyIt,allowInitalization,calcAlgContext);
						if (!contained) {
							++mStatConDesInsertionCount;
							STATINC(CONCEPTSADDEDINDINODELABELSETCOUNT,calcAlgContext);
							addBlockingCoreConcept(conceptDescriptor,processIndi,conLabelSet,calcAlgContext);
							setIndividualNodeConceptLabelSetModified(processIndi,calcAlgContext);
							addConceptPreprocessedToProcessingQueue(conceptDescriptor,dependencyTrackPoint,conProQueue,processIndi,allowPreprocessing,calcAlgContext);
							if (reapplyIt.hasNext()) {
								// reapply reapplying concept
								applyReapplyQueueConcepts(processIndi,&reapplyIt,calcAlgContext);
							}
						} else {
							++mStatConDesContainedCount;
							releaseConceptDescriptor(conceptDescriptor,calcAlgContext);
						}
						conceptAddLinkerIt = conceptAddLinkerIt->getNext();
					}
					if (conceptCount) {
						*conceptCount = conCount;
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::insertConceptProcessDescriptorToProcessingQueue(CConceptProcessDescriptor* conProDes, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConcept* concept = conProDes->getConceptDescriptor()->getConcept();
					CConceptOperator* conOperator = concept->getConceptOperator();

					if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_PROPAGATION_TYPE)) {
						CProcessingDataBox* procDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualConceptBatchProcessingQueue* varBindConBatchProcQueue = procDataBox->getVariableBindingConceptBatchProcessingQueue(true);
						varBindConBatchProcQueue->insertIndiviudalForConcept(concept,processIndi,conProDes);
					} else {
						conceptProcessingQueue->insertConceptProcessDescriptor(conProDes);
					}
				}

				void CCalculationTableauCompletionTaskHandleAlgorithm::insertConceptProcessDescriptorToProcessingQueue(CConceptProcessDescriptor* conProDes, CConceptProcessingQueue*& conceptProcessingQueue, cint64 bindingCount, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {

					CConcept* concept = conProDes->getConceptDescriptor()->getConcept();
					CConceptOperator* conOperator = concept->getConceptOperator();

					if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_PROPAGATION_ALL_TYPE | CConceptOperator::CCFS_PROPAGATION_AND_TYPE)) {
						CProcessingDataBox* procDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualConceptBatchProcessingQueue* varBindConBatchProcQueue = procDataBox->getVariableBindingConceptBatchProcessingQueue(true);
						varBindConBatchProcQueue->insertIndiviudalForBindingCount(concept,bindingCount,processIndi,conProDes);
					} else if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_PROPAGATION_TYPE)) {
						CProcessingDataBox* procDataBox = calcAlgContext->getProcessingDataBox();
						CIndividualConceptBatchProcessingQueue* varBindConBatchProcQueue = procDataBox->getVariableBindingConceptBatchProcessingQueue(true);
						varBindConBatchProcQueue->insertIndiviudalForConcept(concept,processIndi,conProDes);
					} else {
						conceptProcessingQueue->insertConceptProcessDescriptor(conProDes);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool reapplied, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					if (needsProcessingForConcept(conceptDescriptor,depTrackPoint,processIndi,calcAlgContext)) {

						STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
						CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
						CConceptProcessPriority conProPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(conceptDescriptor,processIndi);
						conProDes->init(conceptDescriptor,conProPriority,reapplied,depTrackPoint);
						
						insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,processIndi,calcAlgContext);

						//propagateIndividualUnprocessed(processIndi,calcAlgContext);
					}
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::needsProcessingForConcept(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					TableauRuleFunction func = nullptr;
					cint64 opCode = conceptDescriptor->getConcept()->getOperatorCode();
					bool conNeg = conceptDescriptor->isNegated();
					if (conNeg) {
						func = mNegJumpFuncVec[opCode];
					} else {
						func = mPosJumpFuncVec[opCode];
					}
					return func != nullptr;
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptPreprocessedToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, cint64 bindingCount, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
					CConceptProcessPriority conProPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(conceptDescriptor,processIndi);					
					
					CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
					conProDes->init(conceptDescriptor,conProPriority,false,depTrackPoint);
					insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,bindingCount,processIndi,calcAlgContext);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptPreprocessedToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool allowPreprocessing, CCalculationAlgorithmContextBase* calcAlgContext, TableauRuleFunction skipFunction) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					// TODO: check necessary 
					TableauRuleFunction func = nullptr;
					cint64 opCode = conceptDescriptor->getConcept()->getOperatorCode();
					bool conNeg = conceptDescriptor->isNegated();
					if (conNeg) {
						func = mNegJumpFuncVec[opCode];
					} else {
						func = mPosJumpFuncVec[opCode];
					}
					if (!func || func == skipFunction) {
						return;
					}


					allowPreprocessing &= mConfDirectRulePreprocessing;
					if (mCurrentRecProcDepth > mCurrentRecProcDepthLimit) {
						allowPreprocessing = false;
					}


					CConcept* concept = conceptDescriptor->getConcept();
					CConceptOperator* conOperator = concept->getConceptOperator();

					if (conOperator->hasPartialOperatorCodeFlag(CConceptOperator::CCFS_PROPAGATION_TYPE)) {
						allowPreprocessing = false;
					} 


					STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
					CConceptProcessPriority conProPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(conceptDescriptor,processIndi);
					
					
					CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
					conProDes->init(conceptDescriptor,conProPriority,false,depTrackPoint);

					if (allowPreprocessing && conProPriority.getPriority() >= mImmediatelyProcessPriority) {
						STATINC(RULEAPPLICATIONCOUNT,calcAlgContext);
						tableauRuleChoice(processIndi,conProDes,calcAlgContext);
					} else {
						insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,processIndi,calcAlgContext);
						//propagateIndividualUnprocessed(processIndi,calcAlgContext);
					}
				}




				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptToProcessingQueue(CConceptProcessDescriptor* reinsertConProDes, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
					conceptProcessingQueue->reinsertConceptProcessDescriptor(reinsertConProDes);
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addCopiedConceptToProcessingQueue(CConceptProcessDescriptor* copyConProDes, CIndividualProcessNode*& processIndi, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					if (!processIndi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
						processIndi = getUpToDateIndividual(processIndi,calcAlgContext);
						if (!processIndi->isLocalizationTagUpToDate(calcAlgContext->getUsedProcessTagger()->getCurrentLocalizationTag())) {
							STATINC(INDINODELOCALIZEDLOADCOUNT,calcAlgContext);
							CMemoryAllocationManager* taskMemMan = nullptr;
							CIndividualProcessNodeVector* indiProcNodeVec = calcAlgContext->getProcessingDataBox()->getIndividualProcessNodeVector();
							CIndividualProcessNode* localicedIndi = CObjectParameterizingAllocator< CIndividualProcessNode,CProcessContext* >::allocateAndConstructAndParameterize(taskMemMan,calcAlgContext->getUsedProcessContext());
							localicedIndi->initIndividualProcessNode(processIndi);
							indiProcNodeVec->setLocalData(localicedIndi->getIndividualNodeID(),localicedIndi);
							processIndi = localicedIndi;
							calcAlgContext->getUsedProcessTagger()->incLocalizationTag();
						}
					}

					CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
					CConceptProcessPriority conProPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(copyConProDes->getConceptDescriptor(),processIndi);
					conProDes->initCopy(copyConProDes);
					CConceptProcessingQueue* conceptProcessingQueue = processIndi->getConceptProcessingQueue(true);
					insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,processIndi,calcAlgContext);
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptRestrictedToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool reapplied, CProcessingRestrictionSpecification* procRestriction, CCalculationAlgorithmContextBase* calcAlgContext) {

					bool insertedWithPriorityOffset = false;
					if (procRestriction) {
						double priorityOffset = procRestriction->getPriorityOffset();
						insertedWithPriorityOffset = true;
						addConceptRestrictedToProcessingQueue(conceptDescriptor,depTrackPoint,conceptProcessingQueue,processIndi,reapplied,procRestriction,priorityOffset,calcAlgContext);
					}
					if (!insertedWithPriorityOffset) {
						addConceptRestrictedToProcessingQueue(conceptDescriptor,depTrackPoint,conceptProcessingQueue,processIndi,reapplied,procRestriction,0,calcAlgContext);
					}
				}


				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptRestrictedToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool reapplied, CProcessingRestrictionSpecification* procRestriction, double priorityOffset, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					if (needsProcessingForConcept(conceptDescriptor,depTrackPoint,processIndi,calcAlgContext)) {

						STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
						CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
						CConceptProcessPriority conProPriority = calcAlgContext->getUsedConceptPriorityStrategy()->getPriorityForConcept(conceptDescriptor,processIndi);
						conProPriority.addPriorityOffset(priorityOffset);
						conProDes->init(conceptDescriptor,conProPriority,reapplied,depTrackPoint,procRestriction);
						insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,processIndi,calcAlgContext);


						//propagateIndividualUnprocessed(processIndi,calcAlgContext);
					}
				}



				void CCalculationTableauCompletionTaskHandleAlgorithm::addConceptRestrictedFixedPriorityToProcessingQueue(CConceptDescriptor *conceptDescriptor, CDependencyTrackPoint* depTrackPoint, CConceptProcessingQueue*& conceptProcessingQueue, CIndividualProcessNode*& processIndi, bool reapplied, CProcessingRestrictionSpecification* procRestriction, double priority, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = nullptr;
					taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();

					STATINC(CONCEPTSADDEDINDINODEPROCESSINGQUEUECOUNT,calcAlgContext);
					CConceptProcessDescriptor* conProDes = CObjectAllocator<CConceptProcessDescriptor>::allocateAndConstruct(taskMemMan);
					CConceptProcessPriority conProPriority(priority);
					conProDes->init(conceptDescriptor,conProPriority,reapplied,depTrackPoint,procRestriction);
					insertConceptProcessDescriptorToProcessingQueue(conProDes,conceptProcessingQueue,processIndi,calcAlgContext);

					//propagateIndividualUnprocessed(processIndi,calcAlgContext);
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToProcessingQueueBasedOnProcessingConcepts(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();
					bool individualInserted = false;
					CConceptProcessingQueue* conProQueue = individual->getConceptProcessingQueue(false);
					if (!conProQueue || individual->getLastAssertedDataLiteralLinker() != individual->getAssertedDataLiteralLinker() || individual->getAssertionDataLinker() != individual->getLastProcessedAssertionDataLinker() || individual->getAdditionalDataAssertionsLinker() != individual->getLastProcessedAdditionalDataAssertionLinker()) {
						if (!mConfCurrentIndividualQueuing && calcAlgContext->getCurrentIndividualNode() == individual) {
							individualInserted = true;
						} else if (!individual->isImmediatelyProcessingQueued()) {
							individual->setImmediatelyProcessingQueued(true);
							CIndividualUnsortedProcessingQueue* unPrQueue = processingDataBox->getIndividualImmediatelyProcessingQueue(true);
							unPrQueue->insertIndiviudalProcessNode(individual);
							individualInserted = true;
						}
					} else if (!conProQueue->isEmpty()) {
						CConceptProcessPriority conProPri;
						if (conProQueue->getNextConceptProcessPriority(&conProPri)) {
							double priority = conProPri.getPriority();
							if (priority >= mImmediatelyProcessPriority) {
								if (!mConfCurrentIndividualQueuing && calcAlgContext->getCurrentIndividualNode() == individual) {
									individualInserted = true;
								} else if (!individual->isImmediatelyProcessingQueued()) {
									individual->setImmediatelyProcessingQueued(true);
									CIndividualUnsortedProcessingQueue* unPrQueue = processingDataBox->getIndividualImmediatelyProcessingQueue(true);
									unPrQueue->insertIndiviudalProcessNode(individual);
									individualInserted = true;
								}
							} else if ((mOptDetExpPreporcessing || individual->isNominalIndividualNode() && individual->getIndividualNominalLevelOrAncestorDepth() <= 0) && priority >= mDeterministicProcessPriority) {
								if (!individual->isDeterministicExpandingProcessingQueued()) {
									individual->setDeterministicExpandingProcessingQueued(true);
									CIndividualDepthProcessingQueue* unPrQueue = processingDataBox->getIndividualDepthDeterministicExpansionPreprocessingQueue(true);
									unPrQueue->insertProcessIndiviudal(individual);
									individualInserted = true;
								}
							} else {
								if (!individual->isRegularDepthProcessingQueued()) {
									individual->setRegularDepthProcessingQueued(true);

									if (individual->isNominalIndividualNode() && individual->getIndividualNominalLevelOrAncestorDepth() <= 0) {
										if (!processingDataBox->hasNominalNonDeterministicProcessingNodesSorted()) {
											CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
											CXLinker<CIndividualProcessNode*>* linker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(taskMemMan);
											linker->initLinker(individual);
											processingDataBox->addSortedNominalNonDeterministicProcessingNodeLinker(linker);
										} else {
											CIndividualDepthProcessingQueue* nominalProQueue = processingDataBox->getNominalProcessingQueue(true);										
											nominalProQueue->insertProcessIndiviudal(individual);
										}
									} else {
										CIndividualDepthProcessingQueue* inDepthProQueue = processingDataBox->getIndividualDepthProcessingQueue(true);
										inDepthProQueue->insertProcessIndiviudal(individual);
									}
									individualInserted = true;
								}
							}
						}
					}
					return individualInserted;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToProcessingQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					CMemoryAllocationManager* taskMemMan = calcAlgContext->getUsedProcessTaskMemoryAllocationManager();
					bool individualInserted = false;

					CProcessingDataBox* processingDataBox = calcAlgContext->getProcessingDataBox();

					if (mConfDepthOrientatedProcessing && !individual->isNominalIndividualNode() && !individual->isExtendedQueueProcessing()) {

						if (!individual->isProcessingQueued()) {
							bool deterministicPreprocessingQueued = false;
							if (mOptDetExpPreporcessing) {
								deterministicPreprocessingQueued = true;
								CConceptProcessingQueue* conProQueue = individual->getConceptProcessingQueue(false);
								if (!conProQueue) {
									CConceptProcessPriority conProPri;
									if (conProQueue->getNextConceptProcessPriority(&conProPri)) {
										double priority = conProPri.getPriority();
										if (priority < mDeterministicProcessPriority) {
											deterministicPreprocessingQueued = false;
										}
									}
								}
							}
							if (deterministicPreprocessingQueued) {
								CIndividualUnsortedProcessingQueue* unPrQueue = processingDataBox->getIndividualDepthFirstDeterministicExpansionProcessingQueue(true);
								unPrQueue->insertIndiviudalProcessNode(individual);
							} else {
								CIndividualUnsortedProcessingQueue* depthProcessingQueue = processingDataBox->getIndividualDepthFirstProcessingQueue(true);
								depthProcessingQueue->insertIndiviudalProcessNode(individual);
							}
							individual->setProcessingQueued(true);
							individualInserted = true;
						}

					} else {

						bool insertIndividual = true;
						bool individualBlocked = false;
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFDIRECTBLOCKED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEDIRECTMODIFIED | CIndividualProcessNode::PRFBLOCKINGRETESTDUEBLOCKERMODIFIED)) {
								insertIndividual = false;
							}
						}
						//if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSATISFIABLECACHED)) {
						//	individualBlocked = true;
						//	if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSATISFIABLECACHEDDUEDIRECTMODIFIED)) {
						//		insertIndividual = false;
						//	}
						//}
						//if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSIGNATUREBLOCKINGCACHED)) {
						//	individualBlocked = true;
						//	if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTSIGNATUREBLOCKINGCACHEDDUEDIRECTMODIFIED)) {
						//		insertIndividual = false;
						//	}
						//}
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFRETESTCOMPLETIONGRAPHCACHEDDUEDIRECTMODIFIED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALIDATED | CIndividualProcessNode::PRFCOMPLETIONGRAPHCACHINGINVALID)) {
								insertIndividual = false;
							}
						}

						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFINDIRECTBLOCKED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFBLOCKINGRETESTDUEINDIRECTBLOCKERLOSS)) {
								insertIndividual = false;
							}
						}
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATISFIABLECACHEDABOLISHED)) {
								insertIndividual = false;
							}
						}
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSIGNATUREBLOCKINGCACHEDABOLISHED)) {
								insertIndividual = false;
							}
						}
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHED)) {
							individualBlocked = true;
							if (!individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFANCESTORSATURATIONBLOCKINGCACHEDABOLISHED)) {
								insertIndividual = false;
							}
						}
						if (insertIndividual && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKEND) && individual->hasPartialProcessingRestrictionFlags(CIndividualProcessNode::PRFSYNCHRONIZEDBACKENDSUCCESSOREXPANSIONBLOCKED)) {
							individualBlocked = true;
							insertIndividual = false;
						}
						if (insertIndividual && individual->isDelayedNominalProcessingQueued()) {
							individualBlocked = true;
							insertIndividual = false;
						}

						if (individualBlocked && insertIndividual) {
							if (mConfLateBlockingResolving) {
								if (!individual->isBlockedReactivationProcessingQueued()) {
									individual->setBlockedReactivationProcessingQueued(true);

									CIndividualDepthProcessingQueue* blockReactProQueue = processingDataBox->getBlockedReactivationProcessingQueue(true);
									blockReactProQueue->insertProcessIndiviudal(individual);

									//CXLinker<CIndividualProcessNode*>* indiNodeLinker = CObjectAllocator< CXLinker<CIndividualProcessNode*> >::allocateAndConstruct(calcAlgContext->getUsedProcessTaskMemoryAllocationManager());
									//indiNodeLinker->initLinker(individual);
									//processingDataBox->addIndividualNodeBlockedResolveLinker(indiNodeLinker);
									individualInserted = true;
								}
							} else {
								individualInserted = addIndividualToProcessingQueueBasedOnProcessingConcepts(individual,calcAlgContext);
								if (!individualInserted) {
									if (!individual->isRegularDepthProcessingQueued()) {
										individual->setRegularDepthProcessingQueued(true);
										CIndividualDepthProcessingQueue* inDepthProQueue = processingDataBox->getIndividualDepthProcessingQueue(true);
										inDepthProQueue->insertProcessIndiviudal(individual);
										individualInserted = true;
									}
								}
							}							
						}

						if (!individualBlocked) {
							individualInserted = addIndividualToProcessingQueueBasedOnProcessingConcepts(individual,calcAlgContext);
						}


					}
					if (individualInserted) {
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
					}
					return individualInserted;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToIncrementalCompatibilityCheckingQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isIncrementalCompatibilityCheckingQueued() && individual->isNominalIndividualNode()) {
						individual->setIncrementalCompatibilityCheckingQueued(true);
						CIndividualDepthProcessingQueue* incCompCheckingQueue = calcAlgContext->getProcessingDataBox()->getIncrementalCompatibilityCheckingQueue(true);
						incCompCheckingQueue->insertProcessIndiviudal(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
						return true;
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToIncrementalExpansionQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isIncrementalExpansionQueued()) {
						CIndividualNodeIncrementalExpansionData* incExpData = individual->getIncrementalExpansionData(false);
						if (!incExpData || !incExpData->isIncremetnalExpansionListInitialized()) {
							individual->setIncrementalExpansionQueued(true);
							CIndividualDepthProcessingQueue* incExpInitQueue = calcAlgContext->getProcessingDataBox()->getIncrementalExpansionInitializingProcessingQueue(true);
							incExpInitQueue->insertProcessIndiviudal(individual);
							STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
							return true;
						} else if (incExpData->requiresFurtherIncrementalExpansion()) {
							individual->setIncrementalExpansionQueued(true);
							double nextExpPriority = incExpData->getNextIncrementalExpansionPriority();
							CIndividualCustomPriorityProcessingQueue* incExpQueue = calcAlgContext->getProcessingDataBox()->getIncrementalExpansionProcessingQueue(true);
							incExpQueue->insertIndiviudal(nextExpPriority,individual);
							STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
							return true;
						}
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBackendSynchronisationRetestQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isBackendSynchronRetestProcessingQueued()) {
						individual->setBackendSynchronRetestProcessingQueued(true);
						CIndividualUnsortedProcessingQueue* backendCacheSyncQueue = calcAlgContext->getProcessingDataBox()->getBackendCacheSynchronizationProcessingQueue(true);
						backendCacheSyncQueue->insertIndiviudalProcessNode(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
						return true;
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBackendDirectInfluenceExpansionQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isBackendDirectInfluenceExpansionQueued()) {
						individual->setBackendDirectInfluenceExpansionQueued(true);
						CIndividualUnsortedProcessingQueue* backendCacheSyncQueue = calcAlgContext->getProcessingDataBox()->getBackendDirectInfluenceExpansionQueue(true);
						backendCacheSyncQueue->insertIndiviudalProcessNode(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT, calcAlgContext);
						return true;
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBackendIndirectCompatibilityExpansionQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isBackendIndirectCompatibilityExpansionQueued()) {
						individual->setBackendIndirectCompatibilityExpansionQueued(true);
						CIndividualUnsortedProcessingQueue* backendCacheSyncQueue = calcAlgContext->getProcessingDataBox()->getBackendIndirectCompatibilityExpansionQueue(true);
						backendCacheSyncQueue->insertIndiviudalProcessNode(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT, calcAlgContext);
						return true;
					}
					return false;
				}


				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBackendReuseExpansionQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isBackendReuseExpansionQueued()) {
						individual->setBackendReuseExpansionQueued(true);
						CIndividualUnsortedProcessingQueue* backendCacheSyncQueue = calcAlgContext->getProcessingDataBox()->getBackendIndividualReuseExpansionQueue(true);
						backendCacheSyncQueue->insertIndiviudalProcessNode(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT, calcAlgContext);
						return true;
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBackendNeighbourExpansionQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					if (!individual->isBackendNeighbourExpansionQueued()) {
						individual->setBackendNeighbourExpansionQueued(true);
						CIndividualLinkerRotationProcessingQueue* backendCacheSyncQueue = calcAlgContext->getProcessingDataBox()->getBackendIndividualNeighbourExpansionQueue(true);
						backendCacheSyncQueue->insertIndiviudalProcessNode(individual);
						STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT, calcAlgContext);
						return true;
					}
					return false;
				}

				bool CCalculationTableauCompletionTaskHandleAlgorithm::addIndividualToBlockingUpdateReviewProcessingQueue(CIndividualProcessNode* individual, CCalculationAlgorithmContextBase* calcAlgContext) {
					CIndividualDepthProcessingQueue* sigBlockUpdProQueue = calcAlgContext->getProcessingDataBox()->getBlockingUpdateReviewProcessingQueue(true);
					sigBlockUpdProQueue->insertProcessIndiviudal(individual);
					STATINC(INDINODESADDEDPROCESSINGQUEUECOUNT,calcAlgContext);
					return true;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedANDRuleCount() {
					return mAppliedANDRuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedORRuleCount() {
					return mAppliedORRuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedSOMERuleCount() {
					return mAppliedSOMERuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedATLEASTRuleCount() {
					return mAppliedATLEASTRuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedALLRuleCount() {
					return mAppliedALLRuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedATMOSTRuleCount() {
					return mAppliedATMOSTRuleCount;
				}

				cint64 CCalculationTableauCompletionTaskHandleAlgorithm::getAppliedTotalRuleCount() {
					return mAppliedTOTALRuleCount;
				}



			}; // end namespace Algorithm 

		}; // end namespace Kernel

	}; // end namespace Reasoner

}; // end namespace Konclude
